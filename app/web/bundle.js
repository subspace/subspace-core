(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Subspace = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (Buffer){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@subspace/reed-solomon-erasure.wasm", "../crypto/crypto", "../main/constants", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const reed_solomon_erasure_wasm_1 = require("@subspace/reed-solomon-erasure.wasm");
    const crypto = require("../crypto/crypto");
    const constants_1 = require("../main/constants");
    const utils_1 = require("../utils/utils");
    // ToDo
    // optimize/import encode/decode in Rust
    // actual hourglass function (from filecoin rust proofs?)
    /**
     * Adds deterministic hashes to a piece s.t. it is a exactly 4096 bytes.
     */
    function padPiece(piece) {
        const paddingLength = constants_1.PIECE_SIZE - piece.length;
        const numberOfFullHashes = Math.floor(paddingLength / constants_1.HASH_LENGTH);
        const lastPartialHashLength = paddingLength % constants_1.HASH_LENGTH;
        let hashPadding = crypto.hash(piece);
        for (let i = 0; i < numberOfFullHashes; ++i) {
            piece = Buffer.concat([piece, hashPadding]);
            hashPadding = crypto.hash(hashPadding);
        }
        return Buffer.concat([piece, hashPadding.subarray(0, lastPartialHashLength)]);
    }
    exports.padPiece = padPiece;
    /**
     * Adds deterministic hashes to level source data s.t. it is a multiple of 4096 bytes.
     */
    function padLevel(levelData) {
        const numberOfFullPieces = Math.floor(levelData.length / constants_1.PIECE_SIZE);
        const finalPieceLength = levelData.length % constants_1.PIECE_SIZE;
        if (finalPieceLength) {
            const lastPartialPiece = levelData.subarray(constants_1.PIECE_SIZE * numberOfFullPieces);
            const padding = padPiece(lastPartialPiece);
            levelData = Buffer.concat([levelData.subarray(0, constants_1.PIECE_SIZE * numberOfFullPieces), padding]);
        }
        return Uint8Array.from(levelData);
    }
    exports.padLevel = padLevel;
    const readSolomonErasure = reed_solomon_erasure_wasm_1.ReedSolomonErasure.fromCurrentDirectory();
    const SHARD_SIZE = constants_1.PIECE_SIZE;
    /**
     * Returns the Reed-Solomon erasure coding of source data.
     */
    async function erasureCodeLevel(data) {
        const DATA_SHARDS = data.length / SHARD_SIZE;
        const PARITY_SHARDS = DATA_SHARDS;
        if (DATA_SHARDS + PARITY_SHARDS > 254) {
            throw new Error('Cannot create more than 254 shards');
        }
        const shards = new Uint8Array(SHARD_SIZE * (DATA_SHARDS + PARITY_SHARDS));
        shards.set(data);
        const result = (await readSolomonErasure).encode(shards, DATA_SHARDS, PARITY_SHARDS);
        if (result !== reed_solomon_erasure_wasm_1.ReedSolomonErasure.RESULT_OK) {
            throw new Error(`Erasure coding failed with code ${result}`);
        }
        return shards;
    }
    exports.erasureCodeLevel = erasureCodeLevel;
    /**
     * Converts erasure coded data into a set of fixed length pieces.
     */
    function sliceLevel(erasureCodedLevelData) {
        const pieceCount = erasureCodedLevelData.length / constants_1.PIECE_SIZE;
        const pieceSet = [];
        for (let i = 0; i < pieceCount; ++i) {
            const piece = erasureCodedLevelData.subarray(i * constants_1.PIECE_SIZE, (i + 1) * constants_1.PIECE_SIZE);
            pieceSet.push(Uint8Array.from(piece));
        }
        return pieceSet;
    }
    exports.sliceLevel = sliceLevel;
    /**
     * Reconstructs the source data of an erasure coding given a sufficient number of pieces.
     */
    async function reconstructLevel(data, DATA_SHARDS, PARITY_SHARDS, shardsAvailable) {
        const shards = data.slice();
        const result = (await readSolomonErasure).reconstruct(shards, DATA_SHARDS, PARITY_SHARDS, shardsAvailable);
        if (result !== reed_solomon_erasure_wasm_1.ReedSolomonErasure.RESULT_OK) {
            throw new Error(`Erasure coding reconstruction failed with code ${result}`);
        }
        return shards.subarray(0, SHARD_SIZE * DATA_SHARDS);
    }
    exports.reconstructLevel = reconstructLevel;
    /**
     * Encodes a piece with a key using a simple XOR based Chained Block Cipher (CBC-XOR).
     * TODO: Create a faster implementation in Rust.
     */
    function encodePiece(piece, key, rounds = constants_1.ROUNDS) {
        const output = new Uint8Array(piece);
        // variable round cipherless chain block encoding using node id as the initialization vector
        for (let r = 0; r < rounds; ++r) {
            if (!r) {
                // encode the first block of the first round with the key
                const encodedFirstBlock = utils_1.xorUint8Array(output.subarray(0, constants_1.HASH_LENGTH), key);
                output.set(encodedFirstBlock, 0);
            }
            else {
                // encode the first block of subsequent rounds with the last encoded block of the previous round
                const finalEncodedBlock = output.subarray(constants_1.HASH_LENGTH * (constants_1.BLOCKS_PER_PIECE - 1), constants_1.HASH_LENGTH * constants_1.BLOCKS_PER_PIECE);
                const originalFirstBlock = output.subarray(0, constants_1.HASH_LENGTH);
                const encodedFirstBlock = utils_1.xorUint8Array(finalEncodedBlock, originalFirstBlock);
                output.set(encodedFirstBlock, 0);
            }
            for (let b = 1; b < constants_1.BLOCKS_PER_PIECE; ++b) {
                // encode each following block with its preceding block
                const previousEncodedBlock = output.subarray(constants_1.HASH_LENGTH * (b - 1), (constants_1.HASH_LENGTH * b));
                const originalBlock = output.subarray(constants_1.HASH_LENGTH * b, constants_1.HASH_LENGTH * (b + 1));
                const encodedBlock = utils_1.xorUint8Array(previousEncodedBlock, originalBlock);
                output.set(encodedBlock, constants_1.HASH_LENGTH * b);
            }
        }
        return output;
    }
    exports.encodePiece = encodePiece;
    /**
     * Returns the original piece, given an encoding and a key by applying CBC-XOR in reverse.
     * TODO: Create a faster implementation in Rust, that decodes in //.
     */
    function decodePiece(encodedPiece, key, rounds = constants_1.ROUNDS) {
        const output = new Uint8Array(encodedPiece);
        // variable round cipherless chain block decoding using node id as the initialization vector
        for (let r = rounds; r > 0; --r) {
            for (let b = constants_1.BLOCKS_PER_PIECE; b > 1; --b) {
                // decode each block using its current state and its encoded predecessor
                const previousEncodedBlock = output.subarray(constants_1.HASH_LENGTH * (b - 2), constants_1.HASH_LENGTH * (b - 1));
                const encodedBlock = output.subarray(constants_1.HASH_LENGTH * (b - 1), constants_1.HASH_LENGTH * b);
                const decodedBlock = utils_1.xorUint8Array(previousEncodedBlock, encodedBlock);
                output.set(decodedBlock, constants_1.HASH_LENGTH * (b - 1));
            }
            if (r === 1) {
                // if the final round, decode the first block with its current state and the key
                const decodedFirstBlock = utils_1.xorUint8Array(output.subarray(0, constants_1.HASH_LENGTH), key);
                output.set(decodedFirstBlock, 0);
            }
            else {
                // if any other round, decode the first block with its current state and the final encoded block of the message
                const lastEncodedBlock = output.subarray(constants_1.HASH_LENGTH * (constants_1.BLOCKS_PER_PIECE - 1), constants_1.HASH_LENGTH * constants_1.BLOCKS_PER_PIECE);
                const encodedFirstBlock = output.subarray(0, constants_1.HASH_LENGTH);
                const decodedFirstBlock = utils_1.xorUint8Array(lastEncodedBlock, encodedFirstBlock);
                output.set(decodedFirstBlock, 0);
            }
        }
        return output;
    }
    exports.decodePiece = decodePiece;
    /**
     * TODO: Encodes a piece with an hourglass function that is efficiently invertible.
     */
    function sealPiece(piece) {
        return piece;
    }
    exports.sealPiece = sealPiece;
    /**
     * TODO: Efficiently returns the original piece.
     */
    function openPiece(sealedPiece) {
        return sealedPiece;
    }
    exports.openPiece = openPiece;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../main/constants":12,"../utils/utils":19,"@subspace/reed-solomon-erasure.wasm":40,"buffer":98}],2:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@subspace/jump-consistent-hash", "bls-signatures", "crypto", "merkle-tree-binary"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const jump_consistent_hash_1 = require("@subspace/jump-consistent-hash");
    const bls_signatures_1 = require("bls-signatures");
    const crypto = require("crypto");
    const merkle_tree_binary_1 = require("merkle-tree-binary");
    // ToDo
    // rewrite JCH in Rust (Nazar)
    // rewrite merkle tree in Rust (Nazar)
    // aggregate signatures and public keys (Jeremiah)
    /**
     * Returns a binary sequence of random bytes, using native Node JS crypto.
     */
    function randomBytes(length) {
        return new Uint8Array(crypto.randomBytes(length));
    }
    exports.randomBytes = randomBytes;
    /**
     * Returns the binary hash of a binary value. Hash function and output length are configurable.
     */
    function hash(data, outputLength = 32, type = 'sha256') {
        const hasher = crypto.createHash(type);
        hasher.update(data);
        let hash = new Uint8Array(hasher.digest());
        hash = hash.subarray(0, outputLength);
        return hash;
    }
    exports.hash = hash;
    function merkleHash(data) {
        return hash(data, 32, 'whirlpool');
    }
    /**
     * Builds a merkle tree from input hashes, returning the root hash and an array of inclusion proofs.
     */
    function buildMerkleTree(items) {
        const tree = new merkle_tree_binary_1.Tree(items, merkleHash);
        const root = tree.getRoot();
        const proofs = [];
        for (const item of items) {
            proofs.push(tree.getProof(item));
        }
        return { root, proofs };
    }
    exports.buildMerkleTree = buildMerkleTree;
    /**
     * Validates that a merkle proof is valid for a given root.
     */
    function isValidMerkleProof(root, proof, item) {
        return merkle_tree_binary_1.Tree.checkProof(root, proof, item, merkleHash);
    }
    exports.isValidMerkleProof = isValidMerkleProof;
    /**
     * Returns a pseudo-random number within a specified range, from a binary seed.
     */
    function jumpHash(seed, buckets) {
        return jump_consistent_hash_1.jumpConsistentHash(seed, buckets);
    }
    exports.jumpHash = jumpHash;
    /**
     * Checks if a unix timestamp is within a specified time range.
     */
    function isDateWithinRange(date, range) {
        // checks to ensure a supplied unix timestamp is within a supplied range
        return Math.abs(Date.now() - date) <= range;
    }
    exports.isDateWithinRange = isDateWithinRange;
    /**
     * Returns a BLS-381 public/private key pair from a binary seed.
     */
    function generateBLSKeys(seed) {
        if (!seed) {
            seed = crypto.randomBytes(32);
        }
        const privateKey = bls_signatures_1.PrivateKey.fromSeed(seed);
        const publicKey = privateKey.getPublicKey();
        const binaryPrivateKey = privateKey.serialize();
        const binaryPublicKey = publicKey.serialize();
        return { binaryPrivateKey, binaryPublicKey };
    }
    exports.generateBLSKeys = generateBLSKeys;
    /**
     * Signs a binary message given a BLS private key.
     */
    function signMessage(binaryMessage, binaryPrivateKey) {
        const privateKey = bls_signatures_1.PrivateKey.fromBytes(binaryPrivateKey, false);
        const signature = privateKey.sign(binaryMessage);
        const binarySignature = signature.serialize();
        return binarySignature;
    }
    exports.signMessage = signMessage;
    /**
     * Verifies a BLS signature given a binary message and BLS public key.
     */
    function verifySignature(binaryMessage, binarySignature, binaryPublicKey) {
        const signature = bls_signatures_1.Signature.fromBytes(binarySignature);
        const publicKey = bls_signatures_1.PublicKey.fromBytes(binaryPublicKey);
        const aggregationInfo = bls_signatures_1.AggregationInfo.fromMsg(publicKey, binaryMessage);
        signature.setAggregationInfo(aggregationInfo);
        const isValid = signature.verify();
        return isValid;
    }
    exports.verifySignature = verifySignature;
});

},{"@subspace/jump-consistent-hash":21,"bls-signatures":65,"crypto":432,"merkle-tree-binary":548}],3:[function(require,module,exports){
(function (Buffer){
// tslint:disable: object-literal-sort-keys
// tslint:disable: no-console
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@subspace/red-black-tree", "../codes/codes", "../crypto/crypto", "../storage/storage", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const red_black_tree_1 = require("@subspace/red-black-tree");
    const codes = require("../codes/codes");
    const crypto = require("../crypto/crypto");
    const storage_1 = require("../storage/storage");
    const utils_1 = require("../utils/utils");
    // ToDo
    // Plots
    // modes: mem-db, disk-db, raw-disk, on-the-fly
    // manage multiple plots (create, read, update, delete)
    // red-black tree
    // in memory tree
    // disk based tree
    // hybrid tree
    /**
     * Manages all plots for this node. Plots store encoded pieces which are used to solve the block challenge.
     */
    class Farm {
        constructor(storage, diskPlot, mode) {
            this.memPlot = new Map();
            this.pieceOffset = 0;
            this.mode = mode;
            this.storage = storage;
            this.diskPlot = diskPlot;
            const nodeManager = new red_black_tree_1.NodeManagerJsUint8Array();
            this.memTree = new red_black_tree_1.Tree(nodeManager);
            this.address = new Uint8Array();
        }
        /**
         * Returns a new farm instance.
         */
        static async init(adapter, mode) {
            if (mode === 'mem-db') {
                adapter = 'memory';
            }
            const storage = new storage_1.Storage(adapter, `farm-${mode}`);
            const diskPlot = new storage_1.Storage(adapter, 'plot');
            const farm = new Farm(storage, diskPlot, mode);
            return farm;
        }
        /**
         * Adds a new encoded piece to plot, index, and metadata store.
         */
        async addPiece(piece, pieceData) {
            const encodedPiece = codes.encodePiece(piece, this.address);
            this.pieceOffset++;
            switch (this.mode) {
                case Farm.MODE_MEM_DB:
                    this.memPlot.set(this.pieceOffset, encodedPiece);
                    break;
                case Farm.MODE_DISK_DB:
                    await this.diskPlot.put(utils_1.num2Bin(this.pieceOffset), encodedPiece);
                    break;
            }
            this.memTree.addNode(pieceData.pieceHash, this.pieceOffset);
            await this.addPieceData(pieceData);
            // console.log(`Added encoding to plot: `);
            // console.log(encodedPiece);
        }
        getSize() {
            return this.memPlot.size;
        }
        /**
         * Searches index for closest piece id to target by XOR and returns the decoded piece with metadata.
         */
        async getClosestPiece(target) {
            const node = this.memTree.getClosestNode(target);
            if (node) {
                const [pieceHash, offset] = node;
                let encoding;
                switch (this.mode) {
                    case Farm.MODE_MEM_DB:
                        encoding = this.memPlot.get(offset);
                        break;
                    case Farm.MODE_DISK_DB:
                        encoding = await this.diskPlot.get(utils_1.num2Bin(offset));
                        break;
                }
                if (encoding) {
                    const piece = codes.decodePiece(encoding, this.address);
                    const data = await this.getPieceData(pieceHash);
                    return { piece, data };
                }
            }
        }
        /**
         * Searches the index for exact match based on piece id and returns the decoded piece with metadata.
         */
        async getExactPiece(pieceId) {
            const offset = this.memTree.getNodeValue(pieceId);
            if (offset) {
                let encoding;
                switch (this.mode) {
                    case Farm.MODE_MEM_DB:
                        encoding = this.memPlot.get(offset);
                        break;
                    case Farm.MODE_DISK_DB:
                        encoding = await this.diskPlot.get(utils_1.num2Bin(offset));
                        break;
                }
                if (encoding) {
                    const piece = codes.decodePiece(encoding, this.address);
                    const pieceHash = crypto.hash(piece);
                    if (pieceHash.toString() === pieceId.toString()) {
                        const data = await this.getPieceData(pieceId);
                        return { piece, data };
                    }
                }
            }
        }
        /**
         * Searches index for closest piece id to target by XOR and returns the associated encoding with metadata.
         */
        async getClosestEncoding(target) {
            const node = this.memTree.getClosestNode(target);
            if (node) {
                const [pieceHash, offset] = node;
                let encoding;
                switch (this.mode) {
                    case Farm.MODE_MEM_DB:
                        encoding = this.memPlot.get(offset);
                        break;
                    case Farm.MODE_DISK_DB:
                        encoding = await this.diskPlot.get(utils_1.num2Bin(offset));
                        break;
                }
                if (encoding) {
                    // console.log(`Got encoding and data for piece ${pieceHash} from farm:`);
                    // console.log(encoding);
                    const data = await this.getPieceData(pieceHash);
                    return { encoding, data };
                }
            }
        }
        /**
         * Searches the index for the exact match based on piece id and returns the associated encoding with metadata.
         */
        async getExactEncoding(pieceId) {
            const offset = this.memTree.getNodeValue(pieceId);
            if (offset) {
                let encoding;
                switch (this.mode) {
                    case Farm.MODE_MEM_DB:
                        encoding = this.memPlot.get(offset);
                        break;
                    case Farm.MODE_DISK_DB:
                        encoding = await this.diskPlot.get(utils_1.num2Bin(offset));
                        break;
                }
                if (encoding) {
                    const data = await this.getPieceData(pieceId);
                    return { encoding, data };
                }
            }
        }
        /**
         * Deletes an encoded piece from the plot, index, and metadata store.
         */
        async removePiece(pieceId) {
            const offset = this.memTree.getNodeValue(pieceId);
            if (offset) {
                switch (this.mode) {
                    case Farm.MODE_MEM_DB:
                        this.memPlot.delete(offset);
                        break;
                    case Farm.MODE_DISK_DB:
                        await this.diskPlot.del(utils_1.num2Bin(offset));
                        break;
                }
                this.memTree.removeNode(pieceId);
                await this.removePieceData(pieceId);
            }
        }
        /**
         * Initializes a new plot from seed data (typically at genesis).
         */
        async initPlot(address, pieceSet) {
            this.address = address;
            for (const piece of pieceSet) {
                await this.addPiece(piece.piece, piece.data);
            }
        }
        /**
         * Add piece metadata to storage.
         */
        async addPieceData(pieceData) {
            const binaryPieceData = Buffer.concat([
                utils_1.num2Bin(pieceData.pieceIndex),
                pieceData.stateHash,
                pieceData.proof,
            ]);
            await this.storage.put(pieceData.pieceHash, binaryPieceData);
        }
        /**
         * Retrieve piece metadata from storage.
         */
        async getPieceData(pieceHash) {
            const binaryPieceData = await this.storage.get(pieceHash);
            if (!binaryPieceData) {
                throw new Error('Cannot get piece data, does not exist in persistent storage');
            }
            return {
                pieceHash,
                pieceIndex: utils_1.bin2Num(binaryPieceData.subarray(0, 4)),
                stateHash: Uint8Array.from(binaryPieceData.subarray(4, 36)),
                proof: binaryPieceData.subarray(36),
            };
        }
        /**
         * Delete piece metadata from storage
         */
        async removePieceData(pieceHash) {
            await this.storage.del(pieceHash);
        }
    }
    Farm.MODE_MEM_DB = 'mem-db';
    Farm.MODE_DISK_DB = 'disk-db';
    exports.Farm = Farm;
});

}).call(this,require("buffer").Buffer)
},{"../codes/codes":1,"../crypto/crypto":2,"../storage/storage":18,"../utils/utils":19,"@subspace/red-black-tree":38,"buffer":98}],4:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "array-map-set", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // tslint:disable: no-console
    const array_map_set_1 = require("array-map-set");
    const utils_1 = require("../utils/utils");
    // ToDo
    // track nonce for each address
    // persist to disk
    // how big can this get in memory: 400 MB per 10M accounts
    /**
     * Manages the credit balance of all accounts on the ledger.
     */
    class Account {
        constructor() {
            this.accounts = array_map_set_1.ArrayMap();
        }
        /**
         * Updates the credit balance of an account, creating a new one if one does not exist.
         */
        update(address, amount) {
            let balance = this.accounts.get(address);
            if (balance) {
                balance += amount;
                if (balance < 0) {
                    throw new Error('Invalid account update, balance cannot be negative!');
                }
                this.accounts.set(address, balance);
            }
            else {
                this.accounts.set(address, amount);
            }
        }
        /**
         * Checks if an account exists within the ledger.
         */
        has(address) {
            return this.accounts.has(address);
        }
        /**
         * Returns the credit balance of an account, if the account exists.
         */
        get(address) {
            if (this.has(address)) {
                return this.accounts.get(address);
            }
        }
        /**
         * Returns the number of accounts recorded on the ledger.
         */
        getNumberOfAccounts() {
            return this.accounts.size;
        }
        /**
         * Returns the total number of credits being tracked on the ledger.
         */
        getSumOfBalances() {
            return [...this.accounts.values()]
                .reduce((sum, value) => sum + value);
        }
        /**
         * Prints the balance of all accounts, as account_address : account_balance.
         */
        printBalanceOfAccounts() {
            [...this.accounts.entries()]
                .map((entry) => {
                console.log(`Account ${utils_1.bin2Hex(entry[0])} has a balance of ${entry[1]} credits`);
            });
        }
    }
    exports.Account = Account;
});

},{"../utils/utils":19,"array-map-set":45}],5:[function(require,module,exports){
(function (Buffer){
// tslint:disable: object-literal-sort-keys
// tslint:disable: variable-name
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../crypto/crypto", "../utils/utils", "./content", "./proof"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const crypto = require("../crypto/crypto");
    const utils_1 = require("../utils/utils");
    const content_1 = require("./content");
    const proof_1 = require("./proof");
    /**
     * Record class for a logical block that contains the proof, content header, and coinbase tx.
     */
    class Block {
        /**
         * Creates an empty block record for a new chain as part of the genesis level.
         */
        static createGenesisBlock(previousProofHash, parentContentHash) {
            const genesisProof = proof_1.Proof.createGenesisProof(previousProofHash);
            const genesisContent = content_1.Content.createGenesisContent(parentContentHash, genesisProof.key);
            const genesisBlockValue = {
                proof: genesisProof,
                content: genesisContent,
            };
            return new Block(genesisBlockValue);
        }
        /**
         * Returns a new block record given correct inputs.
         */
        static create(proof, parentContentHash, txIds, coinbase) {
            const content = content_1.Content.create(parentContentHash, proof.key, txIds);
            const fullBlockValue = {
                proof,
                content,
                coinbase,
            };
            return new Block(fullBlockValue);
        }
        /**
         * Returns a record instance from existing data.
         */
        static load(blockData) {
            const proof = proof_1.Proof.load(blockData[0]);
            const content = content_1.Content.load(blockData[1]);
            const fullBlockValue = { proof, content };
            return new Block(fullBlockValue);
        }
        constructor(value) {
            this._value = value;
            this._key = this.setKey();
        }
        get key() {
            return this._key;
        }
        get value() {
            return this._value;
        }
        /**
         * Returns a compact binary representation of the block data for level encoding.
         */
        toBytes() {
            return Uint8Array.from(Buffer.concat([
                this._value.proof.toBytes(),
                this._value.content.toBytes(),
            ]));
        }
        /**
         * Returns a compact serialized representation of the block data.
         */
        toData() {
            return [
                this._value.proof.toData(),
                this._value.content.toData(),
                this._value.coinbase ? this._value.coinbase.toData() : undefined,
            ];
        }
        /**
         * Returns a tiny pointer to the proof and content for storage within in-memory chain objects.
         */
        toCompactData() {
            return [
                this._value.proof.key,
                this._value.content.key,
            ];
        }
        /**
         * Returns a human readable serialization of the block object.
         */
        print() {
            return {
                type: 'Block',
                key: utils_1.bin2Hex(this._key),
                value: {
                    proof: this.value.proof.print(),
                    content: this.value.content.print(),
                    coinbase: this.value.coinbase ? this.value.coinbase.print() : undefined,
                },
            };
        }
        /**
         * Validates that block follows schema and is internally consistent, but not that block is correct.
         */
        isValid() {
            if (this._value.proof.key !== this._value.content.value.proofHash) {
                throw new Error('Invalid block, content does not point to proof');
            }
            // validate content, will throw if invalid
            this._value.proof.isValid();
            // validate proof, will throw if invalid
            this._value.content.isValid();
            // if genesis block
            if (this._value.proof.value.previousLevelHash.length === 0) {
                // content record must be genesis type
                if (this._value.content.value.proofHash.length === 0) {
                    throw new Error('Invalid genesis block, must have a genesis content record');
                }
                // coinbase should be missing
                if (this._value.coinbase) {
                    throw new Error('Invalid genesis block, cannot have a coinbase transaction');
                }
                return true;
            }
            // else if normal block
            if (!this.value.coinbase) {
                throw new Error('Invalid block, must have a coinbase tx');
            }
            // validate coinbase, will throw if invalid
            this.value.coinbase.isValid();
            // validate the coinbase tx has same public key as proof
            if (this.value.coinbase.value.receiver.toString() !== this._value.proof.value.publicKey.toString()) {
                throw new Error('Invalid block, coinbase tx receiver must be creator of the proof');
            }
            // ensure coinbase tx is the first tx in content tx set
            if (this.value.coinbase.key.toString() !== this._value.content.value.payload[0].toString()) {
                throw new Error('Invalid block, coinbase tx must be first in content payload');
            }
            return true;
        }
        /**
         * Sets the block id as the content addressed hash of its value.
         */
        setKey() {
            return crypto.hash(this.toBytes());
        }
    }
    exports.Block = Block;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../utils/utils":19,"./content":7,"./proof":9,"buffer":98}],6:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "array-map-set"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const array_map_set_1 = require("array-map-set");
    // tslint:disable: variable-name
    // ToDo
    // has() will not work, need to implement array-map-set
    // treat the chain as a tree not a set
    /**
     * An in-memory object that tracks the pending state of a chain on the ledger.
     */
    class Chain {
        constructor(index) {
            this._index = index;
            this._height = 0;
            this._blocks = array_map_set_1.ArraySet();
            this._head = new Uint8Array();
        }
        /**
         * Returns the zero-indexed sequence number for this chain in the ledger.
         */
        get index() {
            return this._index;
        }
        /**
         * Returns the height of this chain in blocks, since genesis.
         */
        get height() {
            return this._height;
        }
        /**
         * Returns the number of pending blocks for this chain.
         */
        get size() {
            return this._blocks.size;
        }
        get head() {
            return this._head;
        }
        /**
         * Returns an array of pending block ids for this chain, in insertion order (oldest first).
         */
        get blocks() {
            return [...this._blocks.values()];
        }
        /**
         * Checks if a pending block is in this chain.
         */
        hasBlock(id) {
            return this._blocks.has(id);
        }
        /**
         * Adds a new pending block to the head of this chain.
         */
        addBlock(id) {
            this._blocks.add(id);
            this._height += 1;
            this._head = id;
        }
        /**
         * Removes a block and all of its children blocks from the chain. Called on a chain fork.
         */
        removeBlocks(stopId) {
            if (this.hasBlock(stopId)) {
                let stopPoint = false;
                for (const id of this.blocks.reverse()) {
                    if (!stopPoint) {
                        if (id === stopId) {
                            stopPoint = true;
                            this._head = stopId;
                        }
                    }
                    else {
                        this._blocks.delete(id);
                        this._height -= 1;
                    }
                }
            }
        }
        /**
         * Removes all pending blocks from the chain. Called when a new level is confirmed.
         */
        reset() {
            this._blocks.clear();
        }
    }
    exports.Chain = Chain;
});

},{"array-map-set":45}],7:[function(require,module,exports){
(function (Buffer){
// tslint:disable: object-literal-sort-keys
// tslint:disable: variable-name
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../crypto/crypto", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const crypto = require("../crypto/crypto");
    const utils_1 = require("../utils/utils");
    /**
     * Record class for malleable block contents for the ledger.
     */
    class Content {
        /**
         * Returns a new content record given correct inputs.
         */
        static create(parentContentHash, proofHash, payload) {
            const contentValue = {
                parentContentHash,
                proofHash,
                payload,
            };
            const content = new Content(contentValue);
            content.setKey();
            return content;
        }
        /**
         * Creates an empty content record for a new chain as part of the genesis level.
         */
        static createGenesisContent(parentContentHash, proofHash) {
            return Content.create(parentContentHash, proofHash, []);
        }
        /**
         * Returns a record instance from existing data.
         */
        static load(contentData) {
            const contentValue = {
                parentContentHash: contentData[0],
                proofHash: contentData[1],
                payload: contentData[2],
            };
            const content = new Content(contentValue);
            content.setKey();
            return content;
        }
        constructor(value) {
            this._value = value;
            this._key = crypto.hash(this.toBytes());
        }
        get key() {
            return this._key;
        }
        get value() {
            return this._value;
        }
        /**
         * Returns a compact binary representation of the content data.
         */
        toBytes() {
            return Uint8Array.from(Buffer.concat([
                this._value.parentContentHash,
                this._value.proofHash,
                ...this._value.payload,
            ]));
        }
        /**
         * Returns a compact serialized representation of the content data.
         */
        toData() {
            return [
                this._value.parentContentHash,
                this._value.proofHash,
                this._value.payload,
            ];
        }
        /**
         * Returns a human readable serialization of the content object.
         */
        print() {
            return {
                type: 'Content',
                key: utils_1.bin2Hex(this._key),
                value: {
                    parentContentHash: utils_1.bin2Hex(this._value.parentContentHash),
                    proofHash: utils_1.bin2Hex(this._value.proofHash),
                    payload: this._value.payload.forEach((txId) => utils_1.bin2Hex(txId)),
                },
            };
        }
        /**
         * Validates that content follows schema and is internally consistent, but not that content is correct.
         */
        isValid() {
            // genesis content
            if (this._value.parentContentHash.length === 0) {
                if (this._value.proofHash.length !== 32 || this._value.payload.length > 0) {
                    throw new Error('Invalid genesis content, should have proof hash and content should be empty');
                }
                return true;
            }
            // normal content
            // parent content hash is 32 bytes
            if (this._value.parentContentHash.length !== 32) {
                throw new Error('Invalid content, parent content hash must be 32 bytes');
            }
            // parent proof hash is 32 bytes
            if (this._value.proofHash.length !== 32) {
                throw new Error('Invalid content, proof hash must be 32 bytes');
            }
            // all tx id in payload must be 32 bytes
            for (const txId of this._value.payload) {
                if (txId.length !== 32) {
                    throw new Error('Invalid payload, tx id must be 32 bytes');
                }
            }
            return true;
        }
        /**
         * Sets the content id as the content addressed hash of its value.
         */
        setKey() {
            this._key = crypto.hash(this.toBytes());
        }
    }
    exports.Content = Content;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../utils/utils":19,"buffer":98}],8:[function(require,module,exports){
(function (Buffer){
// tslint:disable: max-classes-per-file
// tslint:disable: object-literal-sort-keys
// tslint:disable: no-console
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "array-map-set", "events", "../codes/codes", "../crypto/crypto", "../main/constants", "../storage/storage", "../utils/utils", "./accounts", "./block", "./chain", "./content", "./proof", "./state", "./tx"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const array_map_set_1 = require("array-map-set");
    const events_1 = require("events");
    const codes = require("../codes/codes");
    const crypto = require("../crypto/crypto");
    const constants_1 = require("../main/constants");
    const storage_1 = require("../storage/storage");
    const utils_1 = require("../utils/utils");
    const accounts_1 = require("./accounts");
    const block_1 = require("./block");
    const chain_1 = require("./chain");
    const content_1 = require("./content");
    const proof_1 = require("./proof");
    const state_1 = require("./state");
    const tx_1 = require("./tx");
    // ToDo
    // handle chain forks
    // handle level forks
    // decode level data
    // Refactor Level into a separate class
    // handle tx fees
    // handle validation where one farmer computes the next level and adds pieces before another
    // enforce a maximum block size of 4096 bytes
    // Basic Modes
    // do I store the chain data (full node)
    // do I store the piece set (plotting)
    // do I store the state chain (light client, full node, farmer)
    // Implementation
    // 1) Store the entire ledger in memory, create state blocks for each new level, encode and plot
    // 2) Only store the ledger in memory and create new state blocks
    // 3) Just store the state blocks, discard new blocks once they are created
    // 4) Store each chain state to disk after N levels are confirmed
    // 5) Discard each new block after N levels are confirmed
    // modes of operation
    // light client -- only stores the state chain, discards all level data after it is compressed
    // full node -- stores the full tx and block history (in memory or on disk)
    // farmer -- only stores the state chain but  encodes each new level into their plot
    // gateway node -- answers rpc requests for records over the DHT
    // farmer -- answers rpc requests for pieces
    class Ledger extends events_1.EventEmitter {
        constructor(storageAdapter, path) {
            super();
            this.isFarming = true;
            this.isServing = true;
            this.previousLevelHash = new Uint8Array();
            this.parentProofHash = new Uint8Array();
            // persistent state
            this.chainCount = 0;
            this.lastConfirmedLevel = 0;
            this.stateMap = array_map_set_1.ArrayMap();
            this.lastStateHash = new Uint8Array();
            this.chains = [];
            // memory pool, may be cleared after each level is confirmed (if not serving)
            this.compactBlockMap = array_map_set_1.ArrayMap();
            this.proofMap = array_map_set_1.ArrayMap();
            this.contentMap = array_map_set_1.ArrayMap();
            this.txMap = array_map_set_1.ArrayMap();
            this.unconfirmedTxs = array_map_set_1.ArraySet(); // has not been included in a block
            this.unconfirmedBlocksByChain = []; // has not been included in a level
            this.unconfirmedChains = new Set(); // does not have any new blocks since last level was confirmed
            this.storage = new storage_1.Storage(storageAdapter, path);
            this.accounts = new accounts_1.Account();
        }
        static async init(storageAdapter) {
            const ledger = new Ledger(storageAdapter, 'ledger');
            return ledger;
        }
        /**
         * Creates a new genesis level.
         * Returns the initial erasure coded piece set with metadata.
         */
        async createGenesisLevel(chainCount) {
            // init the chains
            this.chainCount = chainCount;
            // init level data
            let previousProofHash = new Uint8Array();
            const parentContentHash = new Uint8Array();
            const levelRecords = [];
            let levelProofs = new Uint8Array();
            // init each chain with a genesis block
            for (let i = 0; i < this.chainCount; ++i) {
                const chain = new chain_1.Chain(i);
                const block = block_1.Block.createGenesisBlock(previousProofHash, parentContentHash);
                const encoding = new Uint8Array();
                this.emit('block', block, encoding);
                // print(block.print());
                previousProofHash = block.value.proof.key;
                // save the proof, append to level data
                this.proofMap.set(block.value.proof.key, block.value.proof.toData());
                const binProof = block.value.proof.toBytes();
                levelRecords.push(binProof);
                levelProofs = Buffer.concat([levelProofs, binProof]);
                // save the content, append to level data
                this.contentMap.set(block.value.content.key, block.value.content.toData());
                levelRecords.push(block.value.content.toBytes());
                // extend the chain and to ledger
                chain.addBlock(block.key);
                this.chains.push(chain);
                // add compact block
                const compactBlockData = [block.value.proof.key, block.value.content.key];
                this.compactBlockMap.set(block.key, compactBlockData);
                // init each chain as unconfirmed
                this.unconfirmedChains.add(i);
                this.unconfirmedBlocksByChain.push(array_map_set_1.ArraySet());
            }
            const levelHash = crypto.hash(levelProofs);
            this.parentProofHash = previousProofHash;
            return [levelRecords, levelHash];
        }
        /**
         * Creates a subsequent level once a new level is confirmed (at least one new block for each chain).
         * Returns a canonical erasure coded piece set with metadata that will be the same across all nodes.
         */
        async createLevel() {
            const levelRecords = [];
            let levelProofs = new Uint8Array();
            const uniqueTxSet = new Set();
            for (const chain of this.unconfirmedBlocksByChain) {
                for (const blockId of chain.values()) {
                    const compactBlockData = this.compactBlockMap.get(blockId);
                    if (!compactBlockData) {
                        throw new Error('Cannot create new level, cannot fetch requisite compact block data');
                    }
                    const proofData = this.proofMap.get(compactBlockData[0]);
                    const contentData = this.contentMap.get(compactBlockData[1]);
                    if (!proofData || !contentData) {
                        throw new Error('Cannot create new level, cannot fetch requisite proof or content data');
                    }
                    const proof = proof_1.Proof.load(proofData);
                    const binProof = proof.toBytes();
                    levelRecords.push(binProof);
                    levelProofs = Buffer.concat([levelProofs, binProof]);
                    const content = content_1.Content.load(contentData);
                    levelRecords.push(content.toBytes());
                    for (const txId of content.value.payload) {
                        uniqueTxSet.add(txId);
                    }
                    for (const txId of uniqueTxSet) {
                        const txData = this.txMap.get(txId);
                        if (!txData) {
                            throw new Error('Cannot create new level, cannot fetch requisite transaction data');
                        }
                        const tx = tx_1.Tx.load(txData);
                        levelRecords.push(tx.toBytes());
                    }
                }
                chain.clear();
            }
            const levelHash = crypto.hash(levelProofs);
            return [levelRecords, levelHash];
        }
        /**
         * Takes the source data for a level and applies padding, slices, erasure codes, and creates a piece index.
         * Compresses the encoded level into a state block.
         * Returns an erasure coded piece set with metadata.
         */
        async encodeLevel(levelRecords, levelHash) {
            this.previousLevelHash = levelHash;
            let levelData = new Uint8Array();
            for (const record of levelRecords) {
                levelData = Buffer.concat([levelData, utils_1.num2Bin(record.length), record]);
            }
            levelData = Uint8Array.from(levelData);
            const paddedLevelData = codes.padLevel(levelData);
            const pieceDataSet = paddedLevelData.length <= 4096 ?
                this.encodeSmallLevel(paddedLevelData, levelHash) :
                await this.encodeLargeLevel(paddedLevelData, levelHash);
            if (!this.isServing) {
                // clear the pending state from memory
                this.compactBlockMap.clear();
                this.proofMap.clear();
                this.contentMap.clear();
                this.txMap.clear();
                this.chains.forEach((chain) => chain.reset());
            }
            return pieceDataSet;
        }
        encodeSmallLevel(paddedLevelData, levelHash) {
            const pieceHash = crypto.hash(paddedLevelData);
            const state = state_1.State.create(this.lastStateHash, levelHash, pieceHash, constants_1.DIFFICULTY, constants_1.VERSION, new Uint8Array());
            const pieceData = {
                piece: paddedLevelData,
                data: {
                    pieceHash,
                    stateHash: state.key,
                    pieceIndex: 0,
                    proof: new Uint8Array(),
                },
            };
            this.stateMap.set(state.key, state.toData());
            this.lastStateHash = state.key;
            return [pieceData];
        }
        async encodeLargeLevel(paddedLevelData, levelHash) {
            // this level has at least two source pieces, erasure code parity shards and add index piece
            const erasureCodedLevel = await codes.erasureCodeLevel(paddedLevelData);
            const pieces = codes.sliceLevel(erasureCodedLevel);
            // create the index piece
            const pieceHashes = pieces.map((piece) => crypto.hash(piece));
            const indexData = Uint8Array.from(Buffer.concat([...pieceHashes]));
            const indexPiece = codes.padPiece(indexData);
            const indexPieceId = crypto.hash(indexPiece);
            pieces.push(indexPiece);
            pieceHashes.push(indexPieceId);
            // build merkle tree
            const { root, proofs } = crypto.buildMerkleTree(pieceHashes);
            // create state
            const state = state_1.State.create(this.lastStateHash, levelHash, root, constants_1.DIFFICULTY, constants_1.VERSION, indexPieceId);
            // compile piece data
            const pieceDataSet = [];
            for (let i = 0; i < pieces.length; ++i) {
                pieceDataSet[i] = {
                    piece: pieces[i],
                    data: {
                        pieceHash: pieceHashes[i],
                        stateHash: state.key,
                        pieceIndex: i,
                        proof: proofs[i],
                    },
                };
            }
            this.stateMap.set(state.key, state.toData());
            this.lastStateHash = state.key;
            return pieceDataSet;
        }
        /**
         * Takes any minimal subset of the erasure coded level and returns the original records (blocks, proofs, contents, and txs).
         */
        // public async decodeLevel(levelData: Uint8Array): Promise<void> {
        //   // parse record length value
        //   // parse record
        //   // load and validate all proofs
        //   // load and validate all content
        //   // load and validate all txs
        //   // ensure all txs described in content are included
        //   // reconstruct each block
        //   return;
        // }
        /**
         * Called when a new Block solution is generated locally.
         * Emits a fully formed Block for gossip by Node.
         * Passes the Block on to be applied to Ledger
         */
        async createBlock(proof, coinbaseTx, encoding) {
            // create the block
            const chainIndex = crypto.jumpHash(proof.key, this.chainCount);
            const parentBlockId = this.chains[chainIndex].head;
            const compactParentBlock = this.compactBlockMap.get(parentBlockId);
            if (!compactParentBlock) {
                throw new Error('Cannot get parent block when extending the chain.');
            }
            const parentContentHash = compactParentBlock[1];
            const txIds = [coinbaseTx.key, ...this.unconfirmedTxs.values()];
            const block = block_1.Block.create(proof, parentContentHash, txIds, coinbaseTx);
            // pass up to node for gossip across the network
            // this.emit('block', block, encoding);
            await this.isValidBlock(block, encoding);
            await this.applyBlock(block);
            return block;
        }
        /**
         * Validates a Block against the Ledger.
         * Ensures the Proof and Content are well-formed.
         * Ensures all included Txs are valid against the Ledger and well-formed.
         */
        async isValidBlock(block, encoding) {
            // console.log(`Got block and encoding in Block.isValidBlock():`);
            // console.log(encoding);
            // validate the block, proof, content, and coinbase tx are all well formed, will throw if not
            block.isValid();
            // handle genesis blocks ...
            if (block.value.proof.value.previousLevelHash.length === 0) {
                // previous proof hash should be null or in proof map
                if (block.value.proof.value.previousProofHash.length === 0) {
                    const genesisProof = this.proofMap.get(block.value.proof.key);
                    if (!genesisProof && this.proofMap.size) {
                        throw new Error('Invalid genesis block, already have a first genesis proof');
                    }
                }
                else {
                    // check in proof map
                    const previousProofData = this.proofMap.get(block.value.proof.value.previousProofHash);
                    if (!previousProofData) {
                        throw new Error('Invalid genesis block, does not reference a known proof');
                    }
                }
                // encoding should be null
                if (encoding.length > 0) {
                    throw new Error('Invalid genesis block, should not have an attached encoding');
                }
                return true;
            }
            // verify the proof ...
            // previous level hash is last seen level
            if (block.value.proof.value.previousLevelHash.toString() !== this.previousLevelHash.toString()) {
                throw new Error('Invalid block proof, points to incorrect previous level');
            }
            // previous proof hash is in proof map
            if (!this.proofMap.has(block.value.proof.value.previousProofHash)) {
                throw new Error('Invalid block proof, points to an unknown previous proof');
            }
            // solution is part of encoded piece
            let hasSolution = false;
            for (let i = 0; i < constants_1.PIECE_SIZE / constants_1.CHUNK_LENGTH; ++i) {
                const chunk = encoding.subarray((i * constants_1.CHUNK_LENGTH), (i + 1) * constants_1.CHUNK_LENGTH);
                if (chunk.toString() === block.value.proof.value.solution.toString()) {
                    hasSolution = true;
                    break;
                }
            }
            if (!hasSolution) {
                throw new Error('Invalid block proof, solution is not present in encoding');
            }
            // piece level is seen in state
            if (!this.stateMap.has(block.value.proof.value.pieceStateHash) && block.value.proof.value.pieceStateHash.length > 0) {
                console.log(block.value.proof.value.pieceStateHash);
                console.log(this.stateMap.keys());
                throw new Error('Invalid block proof, referenced piece level is unknown');
            }
            // piece proof is valid for a given state level, assuming their is more than one piece in the level
            if (block.value.proof.value.previousLevelHash.toString() !== block.value.proof.value.previousProofHash.toString()) {
                const pieceStateData = this.stateMap.get(block.value.proof.value.pieceStateHash);
                if (!pieceStateData) {
                    throw new Error('Invalid block proof, referenced state data is not in state map');
                }
                const state = state_1.State.load(pieceStateData);
                const validPieceProof = crypto.isValidMerkleProof(state.value.pieceRoot, block.value.proof.value.pieceProof, block.value.proof.value.pieceHash);
                if (!validPieceProof) {
                    console.log('Invalid block proof, piece proof is not a valid merkle path');
                }
            }
            // encoding decodes pack to piece
            const proverAddress = crypto.hash(block.value.proof.value.publicKey);
            const piece = codes.decodePiece(encoding, proverAddress);
            // console.log(`Encoding in  Block.isValidBlock() decodes to: ${piece}`);
            const pieceHash = crypto.hash(piece);
            if (pieceHash.toString() !== block.value.proof.value.pieceHash.toString()) {
                // console.log(`Address for decoding is ${proverAddress}`);
                // console.log(`Encoded piece hash is ${crypto.hash(encoding)}`);
                // console.log(`Decoded piece hash is ${pieceHash.toString()}`);
                // console.log(`Piece hash referenced in block is:  ${block.value.proof.value.pieceHash.toString()}`);
                // print(block.print());
                console.log('Invalid block proof, encoding does not decode back to parent piece');
            }
            // verify the content points to the correct chain
            // if parent block is the genesis block then the proof hash will hash to different a chain
            const correctChainIndex = crypto.jumpHash(block.value.proof.key, this.chainCount);
            const parentContentData = this.contentMap.get(block.value.content.value.parentContentHash);
            if (!parentContentData) {
                throw new Error('Invalid block content, cannot retrieve parent content block');
            }
            const parentContent = content_1.Content.load(parentContentData);
            if (parentContent.value.parentContentHash.length > 0) {
                const parentChainIndex = crypto.jumpHash(parentContent.value.proofHash, this.chainCount);
                if (parentChainIndex !== correctChainIndex) {
                    throw new Error('Invalid block content, does not hash to the same chain as parent');
                }
            }
            // validate the coinbase tx (since not in mempool)
            if (!block.value.coinbase) {
                throw new Error('Invalid block, does not have a coinbase tx');
            }
            this.isValidTx(block.value.coinbase);
            // verify each tx in the content (including coinbase)
            const txIds = block.value.content.value.payload;
            for (let i = 1; i < txIds.length; ++i) {
                const txData = this.txMap.get(txIds[i]);
                if (!txData) {
                    throw new Error('Invalid block content, cannot retrieve referenced tx id');
                }
                const tx = tx_1.Tx.load(txData);
                this.isValidTx(tx);
            }
            return true;
        }
        /**
         * Called when a new valid block is received over the network or generated locally.
         * Assumes the block has been validated on receipt over the network or correctly formed locally.
         * Applies the block to ledger state.
         */
        async applyBlock(block) {
            return new Promise(async (resolve) => {
                // extend the correct chain with block id and add to compact block map
                const chainIndex = crypto.jumpHash(block.value.proof.key, this.chainCount);
                this.chains[chainIndex].addBlock(block.key);
                this.compactBlockMap.set(block.key, [block.value.proof.key, block.value.content.key]);
                this.unconfirmedBlocksByChain[chainIndex].add(block.key);
                // add proof to proof map and update last proof seen
                this.proofMap.set(block.value.proof.key, block.value.proof.toData());
                this.parentProofHash = block.value.proof.key;
                // add content to content map
                this.contentMap.set(block.value.content.key, block.value.content.toData());
                if (!block.value.coinbase) {
                    throw new Error('Cannot apply block without a coinbase tx');
                }
                // apply the coinbase tx (skip unconfirmed)
                const coinbase = block.value.coinbase;
                this.txMap.set(coinbase.key, coinbase.toData());
                this.applyTx(coinbase);
                // for each credit tx, apply and remove from unconfirmed set, skipping the coinbase tx
                const txIds = block.value.content.value.payload;
                for (let i = 1; i < txIds.length; ++i) {
                    const txId = txIds[i];
                    const txData = this.txMap.get(txId);
                    if (!txData) {
                        throw new Error('Cannot apply tx that is not in the mempool');
                    }
                    const tx = tx_1.Tx.load(txData);
                    this.applyTx(tx);
                    this.unconfirmedTxs.delete(txId);
                }
                // tslint:disable-next-line: no-console
                console.log('Completed applying block, checking if level is confirmed');
                // update level confirmation cache and check if level is confirmed
                this.unconfirmedChains.delete(chainIndex);
                if (!this.unconfirmedChains.size) {
                    const [levelRecords, levelHash] = await this.createLevel();
                    this.emit('confirmed-level', levelRecords, levelHash);
                    for (let i = 0; i < this.chainCount; ++i) {
                        this.unconfirmedChains.add(i);
                    }
                    if (this.isFarming) {
                        this.once('completed-plotting', () => {
                            // tslint:disable-next-line: no-console
                            console.log('completed plotting new piece set');
                            resolve();
                        });
                    }
                    else {
                        resolve();
                    }
                }
                resolve();
            });
        }
        /**
         * Validates a Tx against the Ledger and ensures it is well-formed.
         * Validates schema.
         * Ensures the sender has funds to cover.
         * Ensures the nonce has been incremented.
         */
        async isValidTx(tx) {
            // validate schema, will throw if invalid
            tx.isValid();
            // does sender have funds to cover tx (if not coinbase)
            if (tx.value.sender.length > 0) {
                const senderBalance = this.accounts.get(tx.senderAddress);
                if (!senderBalance) {
                    throw new Error('Invalid tx, sender has no account on the ledger!');
                }
                if (senderBalance - tx.value.amount < 0) {
                    throw new Error('Invalid tx, sender does not have funds to cover the amount!');
                }
            }
            // has nonce been incremented? (prevent replay attack)
            // how to get the last tx for this account?
            // create secondary index in rocks for address and compile...
            // track the nonce in each address field in accounts
            return true;
        }
        /**
         * Called when a new valid tx is received over the network or generated locally.
         * Assumes the tx has been validated on receipt over the network or correctly formed locally.
         * Applies the tx to ledger state by adjust account balances.
         */
        applyTx(tx) {
            // debit the sender, if not coinbase tx
            if (tx.value.sender.length > 0) {
                this.accounts.update(tx.senderAddress, -tx.value.amount);
            }
            // always credit the receiver
            this.accounts.update(tx.receiverAddress, tx.value.amount);
            // apply the fee to the farmer?
            // note when tx is referenced (added to a block)
            // note when tx is confirmed (a block referencing is captured in a level)
            // note when tx is deep confirmed (N other levels have also been confirmed, 6?)
        }
    }
    exports.Ledger = Ledger;
});

}).call(this,require("buffer").Buffer)
},{"../codes/codes":1,"../crypto/crypto":2,"../main/constants":12,"../storage/storage":18,"../utils/utils":19,"./accounts":4,"./block":5,"./chain":6,"./content":7,"./proof":9,"./state":10,"./tx":11,"array-map-set":45,"buffer":98,"events":463}],9:[function(require,module,exports){
(function (Buffer){
// tslint:disable: object-literal-sort-keys
// tslint:disable: variable-name
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../crypto/crypto", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const crypto = require("../crypto/crypto");
    const utils_1 = require("../utils/utils");
    /**
     * Record class for canonical proofs of storage used to create new blocks for the ledger.
     */
    class Proof {
        /**
         * Returns a new unsigned proof given correct inputs.
         * Proof must be passed to wallet for signing before being valid.
         */
        static create(previousLevelHash, previousProofHash, solution, pieceHash, pieceStateHash, pieceProof, publicKey) {
            const proofValue = {
                previousLevelHash,
                previousProofHash,
                solution,
                pieceHash,
                pieceStateHash,
                pieceProof,
                publicKey,
                signature: new Uint8Array(),
            };
            const proof = new Proof(proofValue);
            return proof;
        }
        /**
         * Creates an empty proof for a new chain as part of the genesis level.
         * Does not need to be signed.
         */
        static createGenesisProof(previousProofHash = new Uint8Array()) {
            const nullArray = new Uint8Array();
            const proof = Proof.create(nullArray, previousProofHash, nullArray, nullArray, nullArray, nullArray, nullArray);
            proof.setKey();
            return proof;
        }
        /**
         * Returns a proof instance from existing data.
         */
        static load(proofData) {
            const proofValue = {
                previousLevelHash: proofData[0],
                previousProofHash: proofData[1],
                solution: proofData[2],
                pieceHash: proofData[3],
                pieceStateHash: proofData[4],
                pieceProof: proofData[5],
                publicKey: proofData[6],
                signature: proofData[7],
            };
            const proof = new Proof(proofValue);
            proof.setKey();
            return proof;
        }
        constructor(value) {
            this._value = value;
            this._key = crypto.hash(this.toBytes());
        }
        get key() {
            return this._key;
        }
        get value() {
            return this._value;
        }
        /**
         * Returns a compact binary representation of the proof data.
         */
        toBytes(signed = true) {
            const asBytes = Uint8Array.from(Buffer.concat([
                this._value.previousLevelHash,
                this._value.previousProofHash,
                this._value.solution,
                this._value.pieceHash,
                this._value.pieceStateHash,
                this._value.pieceProof,
                this._value.publicKey,
                signed ? this._value.signature : new Uint8Array(),
            ]));
            return asBytes;
        }
        /**
         * Returns a compact serialized representation of the proof data.
         */
        toData() {
            return [
                this._value.previousLevelHash,
                this._value.previousProofHash,
                this._value.solution,
                this._value.pieceHash,
                this._value.pieceStateHash,
                this._value.pieceProof,
                this._value.publicKey,
                this._value.signature,
            ];
        }
        /**
         * Returns a human readable serialization of the proof object.
         */
        print() {
            return {
                type: 'Proof',
                key: utils_1.bin2Hex(this._key),
                value: {
                    previousLevelHash: utils_1.bin2Hex(this._value.previousLevelHash),
                    previousProofHash: utils_1.bin2Hex(this._value.previousProofHash),
                    solution: utils_1.bin2Hex(this._value.solution),
                    pieceHash: utils_1.bin2Hex(this._value.pieceHash),
                    pieceStateHash: utils_1.bin2Hex(this._value.pieceStateHash),
                    pieceProof: utils_1.bin2Hex(this._value.pieceProof),
                    publicKey: utils_1.bin2Hex(this._value.publicKey),
                    signature: utils_1.bin2Hex(this._value.signature),
                },
            };
        }
        /**
         * Validates that proof follows schema and is internally consistent, but not the proof is correct.
         */
        isValid() {
            // validate genesis proof
            if (this._value.previousLevelHash.length === 0) {
                // ensure fields are null
                if (this._value.solution.length > 0 ||
                    this._value.pieceHash.length > 0 ||
                    this._value.pieceStateHash.length > 0 ||
                    this._value.pieceProof.length > 0 ||
                    this._value.publicKey.length > 0 ||
                    this._value.signature.length > 0) {
                    throw new Error('Invalid genesis proof, includes values for empty properties');
                }
                // previous proof must be null or 32 byte hash
                if (this._value.previousProofHash.length !== 0 && this._value.previousProofHash.length !== 32) {
                    throw new Error('Invalid genesis proof, must reference null or past proof');
                }
                return true;
            }
            // previous level hash is 32 bytes
            if (this._value.previousLevelHash.length !== 32) {
                throw new Error('Invalid proof, invalid length for previous level hash');
            }
            // previous proof hash is 32 bytes
            if (this._value.previousProofHash.length !== 32) {
                throw new Error('Invalid proof, invalid length for previous proof hash');
            }
            // solution is 8 bytes
            if (this._value.solution.length !== 8) {
                throw new Error('Invalid proof, invalid length for solution');
            }
            // piece hash is 32 bytes
            if (this._value.pieceHash.length !== 32) {
                throw new Error('Invalid proof, invalid length for piece hash');
            }
            // piece level is 4 bytes
            if (this._value.pieceStateHash.length !== 32) {
                throw new Error('Invalid proof, invalid length for piece level');
            }
            // // piece proof is greater than 0 bytes
            // if (this._value.pieceProof.length < 32) {
            //   // tslint:disable-next-line: no-console
            //   console.log(this.print());
            //   throw new Error('Invalid proof, invalid length for piece proof');
            // }
            // public key is 48 bytes
            if (this._value.publicKey.length !== 48) {
                throw new Error('Invalid proof, invalid length for public key');
            }
            // signature is 96 bytes
            if (this._value.signature.length !== 96) {
                throw new Error('Invalid proof, invalid length for signature');
            }
            // is signature valid for message and public key
            if (this._value.signature.length > 0) {
                if (!crypto.verifySignature(this.toBytes(false), this._value.signature, this._value.publicKey)) {
                    throw new Error('Invalid proof, invalid signature for message and public key');
                }
            }
            return true;
        }
        /**
         * Sets the proof id as the content addressed hash of its value.
         */
        setKey() {
            this._key = crypto.hash(this.toBytes());
        }
        /**
         * Appends a detached BLS signature to a newly created proof.
         */
        sign(privateKey) {
            this._value.signature = crypto.signMessage(this.toBytes(false), privateKey);
        }
    }
    exports.Proof = Proof;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../utils/utils":19,"buffer":98}],10:[function(require,module,exports){
(function (Buffer){
// tslint:disable: object-literal-sort-keys
// tslint:disable: variable-name
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../crypto/crypto", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const crypto = require("../crypto/crypto");
    const utils_1 = require("../utils/utils");
    /**
     * Record class for state blocks, which summarize all of the data (proofs, contents, and unique txs) for a given level in a compact form.
     */
    class State {
        /**
         * Returns a new state instance given correct inputs.
         */
        static create(previousStateHash, levelHash, pieceRoot, difficulty, version, indexPiece) {
            const stateValue = {
                previousStateHash,
                levelHash,
                pieceRoot,
                timestamp: Date.now(),
                difficulty,
                version,
                indexPiece,
            };
            const state = new State(stateValue);
            state.setKey();
            return state;
        }
        /**
         * Returns a state instance from existing data.
         */
        static load(stateData) {
            const stateValue = {
                previousStateHash: stateData[0],
                levelHash: stateData[1],
                pieceRoot: stateData[2],
                timestamp: stateData[3],
                difficulty: stateData[4],
                version: stateData[5],
                indexPiece: stateData[6],
            };
            const state = new State(stateValue);
            state.setKey();
            return state;
        }
        constructor(value) {
            this._value = value;
            this._key = crypto.hash(this.toBytes());
        }
        get key() {
            return this._key;
        }
        get value() {
            return this._value;
        }
        /**
         * Returns a compact binary representation of the state data.
         */
        toBytes() {
            return Buffer.concat([
                this._value.previousStateHash,
                this._value.levelHash,
                this._value.pieceRoot,
                utils_1.num2Bin(this._value.timestamp),
                utils_1.num2Bin(this._value.difficulty),
                utils_1.num2Bin(this._value.version),
            ]);
        }
        /**
         * Returns a compact serialized representation of the state data.
         */
        toData() {
            return [
                this._value.previousStateHash,
                this._value.levelHash,
                this._value.pieceRoot,
                this._value.timestamp,
                this._value.difficulty,
                this._value.version,
                this._value.indexPiece,
            ];
        }
        /**
         * Returns a human readable serialization of the state object.
         */
        print() {
            return {
                type: 'State',
                key: utils_1.bin2Hex(this._key),
                value: {
                    previousStateHash: utils_1.bin2Hex(this._value.previousStateHash),
                    levelHash: utils_1.bin2Hex(this._value.levelHash),
                    pieceRoot: utils_1.bin2Hex(this._value.pieceRoot),
                    timestamp: utils_1.num2Date(this._value.timestamp),
                    difficulty: this._value.difficulty,
                    version: this._value.version,
                },
            };
        }
        /**
         * Validates that state follows schema and is internally consistent, but not that it is accurate.
         */
        isValid() {
            return true;
        }
        /**
         * Sets the state id as the content addressed hash of its value.
         */
        setKey() {
            this._key = crypto.hash(this.toBytes());
        }
    }
    exports.State = State;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../utils/utils":19,"buffer":98}],11:[function(require,module,exports){
(function (Buffer){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../crypto/crypto", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // tslint:disable: object-literal-sort-keys
    // tslint:disable: variable-name
    const crypto = require("../crypto/crypto");
    const utils_1 = require("../utils/utils");
    /**
     * Record class for credit transactions used to transfer funds between accounts on the ledger.
     */
    class Tx {
        /**
         * Returns a new signed tx instance given correct inputs.
         */
        static create(senderPublicKey, receiverPublicKey, amount, nonce, senderPrivateKey) {
            const txValue = {
                sender: senderPublicKey,
                receiver: receiverPublicKey,
                amount,
                nonce,
                timestamp: Date.now(),
                signature: new Uint8Array(),
            };
            const tx = new Tx(txValue);
            tx.sign(senderPrivateKey);
            tx.setKey();
            return tx;
        }
        /**
         * Creates a coinbase tx to reward the farmer who creates a new block.
         */
        static createCoinbase(creatorPublicKey, amount, nonce, creatorPrivateKey) {
            return Tx.create(new Uint8Array(), creatorPublicKey, amount, nonce, creatorPrivateKey);
        }
        /**
         * Returns a tx instance from existing data.
         */
        static load(txData) {
            const txValue = {
                sender: txData[0],
                receiver: txData[1],
                amount: txData[2],
                nonce: txData[3],
                timestamp: txData[4],
                signature: txData[5],
            };
            const tx = new Tx(txValue);
            tx.setKey();
            return tx;
        }
        constructor(value) {
            this._value = value;
            this._key = crypto.hash(this.toBytes());
        }
        get key() {
            return this._key;
        }
        get value() {
            return this._value;
        }
        /**
         * Hashes the sender's public key, returning their address.
         */
        get senderAddress() {
            return crypto.hash(this._value.sender);
        }
        /**
         * Hashes the receiver's public key, returning their address.
         */
        get receiverAddress() {
            return crypto.hash(this._value.receiver);
        }
        /**
         * Returns a compact binary representation of the tx data.
         */
        toBytes(signed = true) {
            return Uint8Array.from(Buffer.concat([
                this._value.sender,
                this._value.receiver,
                utils_1.num2Bin(this._value.amount),
                utils_1.num2Bin(this._value.nonce),
                utils_1.num2Bin(this._value.timestamp),
                signed ? this._value.signature : new Uint8Array(),
            ]));
        }
        /**
         * Returns a compact serialized representation of the tx data.
         */
        toData() {
            return [
                this._value.sender,
                this._value.receiver,
                this._value.amount,
                this._value.nonce,
                this._value.timestamp,
                this._value.signature,
            ];
        }
        /**
         * Returns a human readable serialization of the proof object.
         */
        print() {
            return {
                type: 'Transaction',
                key: utils_1.bin2Hex(this._key),
                value: {
                    sender: utils_1.bin2Hex(this._value.sender),
                    receiver: utils_1.bin2Hex(this._value.receiver),
                    amount: this._value.amount,
                    nonce: this._value.nonce,
                    timestamp: utils_1.num2Date(this._value.timestamp),
                    signature: utils_1.bin2Hex(this._value.signature),
                },
            };
        }
        /**
         * Validates that tx follows schema and is internally consistent, but not that it has sufficient funds.
         */
        isValid() {
            // validate signature is 96 bytes (BLS signature)
            if (this._value.signature.length !== 96) {
                throw new Error('Invalid tx, invalid signature length');
            }
            // validate receiver is 48 bytes (BLS public key)
            if (this._value.receiver.length !== 48) {
                throw new Error('Invalid tx, invalid receiver key length');
            }
            // validate nonce is 4 bytes
            if (utils_1.num2Bin(this._value.nonce).length !== 4) {
                throw new Error('Invalid tx, incorrect nonce length');
            }
            // validate timestamp is 4 bytes
            if (utils_1.num2Bin(this._value.timestamp).length !== 4) {
                throw new Error('Invalid tx, incorrect timestamp length');
            }
            // validate amount is 4 bytes
            if (utils_1.num2Bin(this._value.amount).length !== 4) {
                throw new Error('Invalid tx, incorrect amount length');
            }
            // is date within +/- 10 minutes of now
            if (!crypto.isDateWithinRange(this._value.timestamp, 600000)) {
                throw new Error('Invalid tx, date is out of range');
            }
            // is signature valid for message and public key
            let sender;
            this._value.sender.length > 0 ? sender = this._value.sender : sender = this._value.receiver;
            if (!crypto.verifySignature(this.toBytes(false), this._value.signature, sender)) {
                throw new Error('Invalid tx, invalid signature for message and public key');
            }
            if (this._value.sender.length === 0 && this._value.amount !== 1) {
                throw new Error('Invalid coinbase tx, invalid amount');
            }
            return true;
        }
        /**
         * Sets the tx id as the content addressed hash of its value.
         */
        setKey() {
            this._key = crypto.hash(this.toBytes());
        }
        /**
         * Appends a detached BLS signature to a newly created tx.
         */
        sign(privateKey) {
            this._value.signature = crypto.signMessage(this.toBytes(false), privateKey);
        }
    }
    exports.Tx = Tx;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../utils/utils":19,"buffer":98}],12:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HASH_LENGTH = 32;
    exports.PIECE_SIZE = 4096;
    exports.BLOCKS_PER_PIECE = exports.PIECE_SIZE / exports.HASH_LENGTH;
    exports.ROUNDS = 3;
    exports.COINBASE_REWARD = 1;
    exports.DIFFICULTY = 64;
    exports.VERSION = 1;
    exports.CHUNK_LENGTH = 8;
});

},{}],13:[function(require,module,exports){
// tslint:disable: no-console
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../node/node"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    if (!globalThis.indexedDB) {
        // Only import when not preset (in Node.js)
        // tslint:disable-next-line:no-var-requires no-submodule-imports
        require('fake-indexeddb/auto');
    }
    const node_1 = require("../node/node");
    /**
     * Optional Init Params
     * chainCount (1 to 1024)
     * nodeMode (full node, farmer, validator, light client)
     * plotMode (memory, disk, raw memory, raw disk, on the fly)
     * plotDifficulty (encoding rounds)
     * storagePath (location for disk based storage)
     * seed (for public key)
     */
    const run = async () => {
        const node = await node_1.Node.init(
        // Use `memory` for Node.js for now
        typeof globalThis.document ? 'memory' : 'rocks', 'mem-db');
        await node.getOrCreateAddress();
        await node.createLedgerAndFarm(16);
    };
    run();
});

},{"../node/node":14,"fake-indexeddb/auto":465}],14:[function(require,module,exports){
(function (Buffer){
// tslint:disable: no-console
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../crypto/crypto", "../farm/farm", "../ledger/block", "../ledger/ledger", "../ledger/proof", "../ledger/tx", "../main/constants", "../utils/utils", "../wallet/wallet"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // import * as codes from '../codes/codes';
    const crypto = require("../crypto/crypto");
    const farm_1 = require("../farm/farm");
    const block_1 = require("../ledger/block");
    const ledger_1 = require("../ledger/ledger");
    const proof_1 = require("../ledger/proof");
    const tx_1 = require("../ledger/tx");
    const constants_1 = require("../main/constants");
    const utils_1 = require("../utils/utils");
    const wallet_1 = require("../wallet/wallet");
    // ToDo
    // detect type of storage for storage adapter
    // start a new ledger
    // define the full API
    // include the RPC interface
    // sync an existing ledger
    class Node {
        constructor(wallet, farm, ledger) {
            this.isFarming = true;
            this.isRelay = true;
            this.isServing = true;
            this.wallet = wallet;
            this.farm = farm;
            this.ledger = ledger;
            /**
             * A new level has been confirmed and encoded into a piece set.
             * Add each piece to the plot, if farming.
             */
            this.ledger.on('confirmed-level', async (levelRecords, levelHash) => {
                console.log('New level confirmation received in node.');
                if (this.isFarming) {
                    // how do you prevent race conditions here, a piece maybe partially plotted before it can be evaluated...
                    const pieceDataSet = await ledger.encodeLevel(levelRecords, levelHash);
                    for (const piece of pieceDataSet) {
                        await this.farm.addPiece(piece.piece, piece.data);
                    }
                    this.ledger.emit('completed-plotting');
                }
            });
            /**
             * A new block was created by this farmer from Ledger after solving the block challenge.
             * Encode the block as binary and gossip over the network.
             */
            this.ledger.on('block', async (block, encoding) => {
                console.log('New block received in node.');
                console.log(`Encoding length is ${encoding.length}`);
                await this.ledger.isValidBlock(block, encoding);
                console.log('block is valid!');
                return;
                // include the referenced encoding
                // encode to binary
                // wrap in message
                this.rpc.gossip(block.toData());
            });
            /**
             * A new credit tx was created by this node and applied to the local ledger.
             * Encode the tx as binary and gossip over the network.
             */
            this.ledger.on('tx', (tx) => {
                return;
                // encode to binary
                // wrap in message
                this.rpc.gossip(tx.toData());
            });
            // `this.rpc` is undefined
            return;
            /**
             * A new block is received over the network from another farmer.
             * Filter the block for duplicates or spam. Validate the block.
             * Apply the block to the ledger and gossip to all other peers.
             */
            this.rpc.on('block', (blockData, encoding) => {
                return;
                // should include the encoding
                // filter
                // validate
                // apply
                // re-gossip
                const block = block_1.Block.load(blockData);
                if (this.ledger.isValidBlock(block, encoding)) {
                    this.ledger.applyBlock(block);
                    this.rpc.gossip(blockData);
                }
            });
            /**
             * A new tx is received over the network from another node.
             * Filter the tx for duplicates or spam. Validate the tx.
             * Apply the tx to the ledger and gossip to all other peers.
             */
            this.rpc.on('tx', (txData) => {
                return;
                // filter
                // validate
                // apply
                // re-gossip
                const tx = tx_1.Tx.load(txData);
                if (this.ledger.isValidTx(tx)) {
                    this.ledger.applyTx(tx);
                    this.rpc.gossip(txData);
                }
            });
        }
        /**
         * Instantiate a new empty node with only environment variables.
         */
        static async init(storageAdapter = 'rocks', mode = 'mem-db') {
            const wallet = await wallet_1.Wallet.init(storageAdapter);
            const farm = await farm_1.Farm.init(storageAdapter, mode);
            const ledger = await ledger_1.Ledger.init(storageAdapter);
            return new Node(wallet, farm, ledger);
        }
        /**
         * Looks for an existing address within the wallet, creating a new one if one does not exist.
         */
        async getOrCreateAddress() {
            const existingAddress = await this.wallet.setMasterKeyPair();
            if (!existingAddress) {
                const seed = crypto.randomBytes(32);
                await this.wallet.createKeyPair(seed);
                await this.wallet.setMasterKeyPair();
            }
        }
        /**
         * Tests the plotting workflow for some random data.
         */
        // public async plot(): Promise<void> {
        //   const data = crypto.randomBytes(520191);
        //   const paddedData = codes.padLevel(data);
        //   const encodedData = await codes.erasureCodeLevel(paddedData);
        //   const pieceSet = codes.sliceLevel(encodedData);
        //   await this.farm.initPlot(this.address, pieceSet);
        //   console.log(`Completed plotting ${pieceSet.length} pieces.`);
        // }
        /**
         * Starts a new ledger from genesis and begins farming its own plot in isolation. Mostly for testing.
         * Retains both the original ledger data within storage and the encoded piece set in the plot.
         */
        async createLedgerAndFarm(chainCount) {
            this.isFarming = true;
            this.getOrCreateAddress();
            const [levelRecords, levelHash] = await this.ledger.createGenesisLevel(chainCount);
            // print(levelRecords);
            const pieceSet = await this.ledger.encodeLevel(levelRecords, levelHash);
            console.log(`Created genesis level with ${this.ledger.chainCount} chains.`);
            for (const piece of pieceSet) {
                await this.farm.addPiece(piece.piece, piece.data);
            }
            console.log(`Plotted ${pieceSet.length} genesis pieces`);
            // if (pieceSet.length === 1) {
            //   console.log('A single genesis piece has been encoded into the genesis level');
            //   const pieceData = pieceSet[0];
            //   // original piece data
            //   console.log(`Address for encoding is ${this.wallet.address}`);
            //   // console.log(`Original piece is ${pieceData.piece}`);
            //   console.log(`Attached piece hash is ${pieceData.data.pieceHash}`);
            //   console.log(`Actual piece hash is ${crypto.hash(pieceData.piece)}`);
            //   // encoded data
            //   const encoding = codes.encodePiece(pieceData.piece, this.wallet.address);
            //   const encodingHash = crypto.hash(encoding);
            //   // console.log(`Encoding is ${encoding}`);
            //   console.log(`Encoded hash is ${encodingHash}`);
            //   // decoded data
            //   const decoding = codes.decodePiece(encoding, this.wallet.address);
            //   const decodedHash = crypto.hash(decoding);
            //   // console.log(`Decoding is ${decoding}`);
            //   console.log(`Decoded hash is ${decodedHash}`);
            // }
            // print(pieceSet);
            // start a farming evaluation loop
            for (let i = 0; i < 256; ++i) {
                // find best encoding for challenge
                console.log('\nSolving a new block challenge');
                console.log('------------------------------\n');
                console.log(`${this.farm.getSize()} pieces in plot.`);
                const previousLevelHash = this.ledger.previousLevelHash;
                const parentProofHash = this.ledger.parentProofHash;
                const seed = Buffer.concat([previousLevelHash, parentProofHash]);
                const pieceTarget = crypto.hash(seed);
                const closestEncoding = await this.farm.getClosestEncoding(pieceTarget);
                if (!closestEncoding) {
                    throw new Error('Cannot find a piece within plot for target');
                }
                const encoding = closestEncoding.encoding;
                console.log(`Closest piece to target: ${utils_1.bin2Hex(pieceTarget)} is ${utils_1.bin2Hex(closestEncoding.data.pieceHash)}`);
                let bestChunkQuality = 0;
                let bestChunk = new Uint8Array();
                const chunkTarget = crypto.hash(pieceTarget).subarray(0, 8);
                // find best chunk for challenge
                for (let i = 0; i < constants_1.PIECE_SIZE / constants_1.CHUNK_LENGTH; ++i) {
                    const chunk = encoding.subarray(i * constants_1.CHUNK_LENGTH, (i + 1) * constants_1.CHUNK_LENGTH);
                    const quality = utils_1.measureProximity(chunk, chunkTarget);
                    if (quality > bestChunkQuality) {
                        bestChunkQuality = quality;
                        bestChunk = chunk;
                    }
                }
                console.log(`Closest chunk to target: ${utils_1.bin2Hex(chunkTarget)} is ${utils_1.bin2Hex(bestChunk)}`);
                // create proof of storage
                const unsignedProof = await proof_1.Proof.create(previousLevelHash, parentProofHash, bestChunk, closestEncoding.data.pieceHash, closestEncoding.data.stateHash, closestEncoding.data.proof, this.wallet.publicKey);
                const signedProof = this.wallet.signProof(unsignedProof);
                // create coinbase tx
                const coinbaseTx = await this.wallet.createCoinBaseTx(constants_1.COINBASE_REWARD);
                // const block =
                await this.ledger.createBlock(signedProof, coinbaseTx, encoding);
                // print(block.print());
            }
            return;
        }
        /**
         * Syncs the ledger from the network and begins farming. Default startup procedure for farmers.
         * Discards the original ledger data after several confirmed levels while retaining only the encoded pieces within its plot.
         */
        async syncLedgerAndFarm() {
            return;
        }
        /**
         * Syncs the ledger from existing nodes and serves RPC requests for structured data. Equivalent to a full validator node.
         * Retains the full unencoded ledger within persistent storage.
         */
        async syncLedgerAndServe() {
            return;
        }
        /**
         * Syncs the state chain from the network. Equivalent to a light client.
         * Listens for and validates new blocks, discarding them as they are compressed into new state blocks.
         */
        async syncStateAndListen() {
            return;
        }
    }
    exports.Node = Node;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../farm/farm":3,"../ledger/block":5,"../ledger/ledger":8,"../ledger/proof":9,"../ledger/tx":11,"../main/constants":12,"../utils/utils":19,"../wallet/wallet":20,"buffer":98}],15:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "level-js", "levelup"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const leveljs = require("level-js");
    // tslint:disable-next-line: no-implicit-dependencies
    const levelup_1 = require("levelup");
    class BrowserAdapter {
        constructor(path) {
            this.db = levelup_1.default(leveljs(path));
        }
        async put(key, value) {
            await this.db.put(key, value);
        }
        async get(key) {
            try {
                return await this.db.get(key);
            }
            catch (error) {
                if (error.notFound) {
                    return null;
                }
                throw error;
            }
        }
        async del(key) {
            try {
                await this.db.del(key);
            }
            catch (error) {
                // Ignore if value already deleted
                if (error.notFound) {
                    return;
                }
                throw error;
            }
        }
        async getKeys() {
            return new Promise(async (resolve) => {
                const keys = [];
                this.db.createKeyStream()
                    .on('data', (key) => {
                    keys.push(key);
                })
                    .on('end', () => {
                    resolve(keys);
                });
            });
        }
        async getLength() {
            const keys = await this.getKeys();
            return keys.length;
        }
        async clear() {
            const keys = await this.getKeys();
            for (const key of keys) {
                await this.del(key);
            }
        }
        async close() {
            try {
                await this.db.close();
            }
            catch (error) {
                throw error;
            }
        }
    }
    exports.default = BrowserAdapter;
});

},{"level-js":531,"levelup":544}],16:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class MemoryAdapter {
        constructor() {
            this.db = new Map();
        }
        async put(key, value) {
            await this.db.set(key, value);
        }
        async get(key) {
            const value = await this.db.get(key);
            if (value) {
                return value;
            }
            else {
                return null;
            }
        }
        async del(key) {
            await this.db.delete(key);
        }
        async getKeys() {
            return [...this.db.keys()];
        }
        async getLength() {
            return this.db.size;
        }
        async clear() {
            this.db.clear();
        }
        async close() {
            return;
        }
    }
    exports.default = MemoryAdapter;
});

},{}],17:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "level-rocksdb"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // TODO: Fix typings here
    // @ts-ignore
    const level = require("level-rocksdb");
    class RocksAdapter {
        constructor(path) {
            this.db = level(path, { valueEncoding: 'binary' });
        }
        async put(key, value) {
            await this.db.put(key, value);
        }
        async get(key) {
            try {
                return await this.db.get(key);
            }
            catch (error) {
                if (error.notFound) {
                    return null;
                }
                throw error;
            }
        }
        async del(key) {
            try {
                await this.db.del(key);
            }
            catch (error) {
                // Ignore if value already deleted
                if (error.notFound) {
                    return;
                }
                throw error;
            }
        }
        async getKeys() {
            return new Promise(async (resolve) => {
                const keys = [];
                this.db.createKeyStream()
                    .on('data', (key) => {
                    keys.push(Uint8Array.from(key.split(',').map(Number)));
                })
                    .on('end', () => {
                    resolve(keys);
                });
            });
        }
        async getLength() {
            const keys = await this.getKeys();
            return keys.length;
        }
        async clear() {
            const keys = await this.getKeys();
            for (const key of keys) {
                await this.del(key);
            }
        }
        async close() {
            try {
                await this.db.close();
            }
            catch (error) {
                throw error;
            }
        }
    }
    exports.default = RocksAdapter;
});

},{"level-rocksdb":68}],18:[function(require,module,exports){
(function (__dirname){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./BrowserAdapter", "./MemoryAdapter", "./RocksAdapter"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const BrowserAdapter_1 = require("./BrowserAdapter");
    const MemoryAdapter_1 = require("./MemoryAdapter");
    const RocksAdapter_1 = require("./RocksAdapter");
    // ToDo
    // close storage (handle error/callback)
    // fix browser storage using level-js: https://github.com/Level/level-js
    // handle JSON storage / type serialization
    // return boolean for del
    // mobile storage
    /**
     * A generic persistent storage interface to a simple key-value store that provides a standard interface across host environments. Currently supports node js and browser run times.
     */
    class Storage {
        constructor(adapterName, nameSpace) {
            this.adapterName = adapterName;
            this.nameSpace = nameSpace;
            let path = `${__dirname}/../../data`;
            if (nameSpace) {
                path = path.concat(`/${nameSpace}`);
            }
            switch (adapterName) {
                case 'browser':
                    this.adapter = new BrowserAdapter_1.default(path);
                    break;
                case 'rocks':
                    this.adapter = new RocksAdapter_1.default(path);
                    break;
                case 'memory':
                    this.adapter = new MemoryAdapter_1.default();
                    break;
                default:
                    throw new Error('Wrong adapter name, supported adapters: browser, memory, rocks');
            }
        }
        /**
         * Stores a binary value under a binary key.
         */
        put(key, value) {
            return this.adapter.put(key, value);
        }
        /**
         * Returns a binary value given a binary key.
         */
        get(key) {
            return this.adapter.get(key);
        }
        /**
         * Deletes a binary value given a binary key.
         */
        del(key) {
            return this.adapter.del(key);
        }
        /**
         * Returns an array of all binary keys for this store.
         */
        getKeys() {
            return this.adapter.getKeys();
        }
        /**
         * Returns the number of records held in this store.
         */
        getLength() {
            return this.adapter.getLength();
        }
        /**
         * Deletes all records from this store.
         */
        clear() {
            return this.adapter.clear();
        }
        /**
         * Closes the existing store to prevent IO errors.
         */
        close() {
            return this.adapter.close();
        }
    }
    exports.Storage = Storage;
});

}).call(this,"/dist/storage")
},{"./BrowserAdapter":15,"./MemoryAdapter":16,"./RocksAdapter":17}],19:[function(require,module,exports){
(function (Buffer){
// ToDo
// port to Rust/WASM?
// write tests
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "util"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const util_1 = require("util");
    /**
     * Returns the exclusive-or (XOR) of two byte arrays.
     */
    function xorUint8Array(a, b) {
        return a.map((byte, index) => {
            // tslint:disable-next-line:no-bitwise
            return byte ^ b[index];
        });
    }
    exports.xorUint8Array = xorUint8Array;
    /**
     * Returns the hamming distance (number of continuous similar bits) between two byte arrays of equal length.
     */
    function measureProximity(a, b, reverse = false) {
        if (a.length !== b.length) {
            throw new Error('Cannot measure proximity between byte arrays of unequal length');
        }
        let proximity = 0;
        let bitString = '';
        xorUint8Array(a, b).forEach((byte) => bitString += byte.toString(2).padStart(8, '0'));
        if (reverse) {
            bitString.split('').reverse().join('');
        }
        for (const bit of bitString) {
            if (bit === '0') {
                ++proximity;
            }
            else {
                break;
            }
        }
        return proximity;
    }
    exports.measureProximity = measureProximity;
    /**
     * Pauses execution synchronously for the specified time period.
     */
    async function wait(delay) {
        const startTime = Date.now();
        let now = startTime;
        while ((now - startTime) < delay) {
            now = Date.now();
            return;
        }
    }
    exports.wait = wait;
    /**
     * Returns the deep clone of an object.
     */
    function clone(data) {
        return JSON.parse(JSON.stringify(data));
    }
    exports.clone = clone;
    /**
     * Converts a unix timestamp to a human readable date.
     */
    function num2Date(num) {
        return (new Date(num)).toString();
    }
    exports.num2Date = num2Date;
    /**
     * Converts a positive integer in range 2^32 to binary format (4 bytes).
     */
    function num2Bin(num) {
        const arr = new ArrayBuffer(4); // an Int32 takes 4 bytes
        const view = new DataView(arr);
        view.setUint32(0, num, false); // byteOffset = 0; littleEndian = false
        return new Uint8Array(arr);
    }
    exports.num2Bin = num2Bin;
    /**
     * Converts a binary number (4 bytes) to positive integer in range 2^32.
     */
    function bin2Num(bin) {
        const view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
        return view.getUint32(0, false); // byteOffset = 0; littleEndian = false
    }
    exports.bin2Num = bin2Num;
    /**
     * Converts binary data to a hexadecimal string representation.
     */
    function bin2Hex(bin) {
        return Buffer.from(bin).toString('hex');
    }
    exports.bin2Hex = bin2Hex;
    /**
     * Converts a JSON object to binary data.
     */
    function JSON2Bin(data) {
        return new Uint8Array(Buffer.from(JSON.stringify(data)));
    }
    exports.JSON2Bin = JSON2Bin;
    /**
     * Converts binary data back to a JSON object.
     */
    function bin2JSON(data) {
        return JSON.parse(Buffer.from(data).toString());
    }
    exports.bin2JSON = bin2JSON;
    /**
     * Converts a string to binary data.
     */
    function str2Bin(data) {
        return new Uint8Array(Buffer.from(data));
    }
    exports.str2Bin = str2Bin;
    /**
     * Prints all properties of nested object to the console.
     */
    function print(data) {
        // tslint:disable-next-line: no-console
        console.log(util_1.inspect(data, false, null, true));
    }
    exports.print = print;
});

}).call(this,require("buffer").Buffer)
},{"buffer":98,"util":607}],20:[function(require,module,exports){
(function (Buffer){
// tslint:disable: variable-name
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../crypto/crypto", "../ledger/tx", "../main/constants", "../storage/storage", "../utils/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const crypto = require("../crypto/crypto");
    const tx_1 = require("../ledger/tx");
    const constants_1 = require("../main/constants");
    const storage_1 = require("../storage/storage");
    const utils_1 = require("../utils/utils");
    // ToDo
    // each address should have its own nonce
    // encrypt private keys at rest
    // create from user generated seeds
    // HD Wallet Functions (child keys)
    const STORAGE_ADDRESS = crypto.hash(utils_1.str2Bin('address'));
    const NONCE_ADDRESS = crypto.hash(utils_1.str2Bin('nonce'));
    /**
     * Class for securely creating, managing, and persisting keys.
     */
    class Wallet {
        constructor(storage, nonce = 0) {
            this.addresses = new Set();
            this.address = new Uint8Array();
            this.publicKey = new Uint8Array();
            this.privateKey = new Uint8Array();
            this.storage = storage;
            this._nonce = nonce;
        }
        /**
         * Returns a new wallet instance, loading any stored keys and nonce from disk.
         */
        static async init(storageAdapter) {
            const storage = new storage_1.Storage(storageAdapter, 'wallet');
            const wallet = new Wallet(storage);
            await wallet.loadAddresses();
            await wallet.loadNonce();
            return wallet;
        }
        get nonce() {
            return this._nonce;
        }
        /**
         * Creates a new key pair and address before storing to disk.
         */
        async createKeyPair(seed) {
            const keys = crypto.generateBLSKeys(seed);
            const address = crypto.hash(keys.binaryPublicKey);
            const binaryKeys = Buffer.concat([keys.binaryPrivateKey, keys.binaryPublicKey]);
            await this.storage.put(address, binaryKeys);
            this.addresses.add(address);
            const binaryAddresses = Buffer.concat([...this.addresses]);
            await this.storage.put(STORAGE_ADDRESS, binaryAddresses);
            return address;
        }
        /**
         * Retrieves an existing key pair from disk by address.
         */
        async getKeyPair(address) {
            if (this.addresses.has(address)) {
                const binaryKeys = await this.storage.get(address);
                if (!binaryKeys) {
                    return;
                }
                const binaryPrivateKey = binaryKeys.subarray(0, 32);
                const binaryPublicKey = binaryKeys.subarray(32, 80);
                if (crypto.hash(binaryPublicKey).toString() !== address.toString()) {
                    throw new Error('Cannot get keys, public key does not match address');
                }
                return {
                    binaryPrivateKey,
                    binaryPublicKey,
                };
            }
            return;
        }
        /**
         * Sets the default (master) address, private key, and public key from persistent storage.
         */
        async setMasterKeyPair() {
            if (this.addresses.size > 0) {
                this.address = [...this.addresses.values()][0];
                const keyPair = await this.getKeyPair(this.address);
                if (keyPair) {
                    this.privateKey = keyPair.binaryPrivateKey;
                    this.publicKey = keyPair.binaryPublicKey;
                    return true;
                }
                else {
                    throw new Error('Could not retrieve keys from storage');
                }
            }
            return false;
        }
        /**
         * Deletes an existing key pair from disk by address.
         */
        async deleteKeyPair(address) {
            if (await this.storage.get(address)) {
                await this.storage.del(address);
                this.addresses.delete(address);
                const binaryAddresses = Buffer.concat([...this.addresses]);
                await this.storage.put(STORAGE_ADDRESS, binaryAddresses);
                if (this.address.toString() === address.toString()) {
                    this.address = new Uint8Array();
                    this.publicKey = new Uint8Array();
                    this.privateKey = new Uint8Array();
                }
            }
            else {
                throw new Error('Cannot delete keys, no keys for this address');
            }
        }
        /**
         * Deletes all key pairs and associated addresses from disk.
         */
        async clear() {
            for (const address of this.addresses) {
                await this.deleteKeyPair(address);
            }
            await this.storage.del(STORAGE_ADDRESS);
            await this.storage.del(NONCE_ADDRESS);
            this._nonce = 0;
        }
        /**
         * Signs a proof deliberately so as not to expose BLS Private Keys outside wallet module.
         */
        signProof(proof) {
            if (proof.value.publicKey.length > 0) {
                proof.sign(this.privateKey);
            }
            proof.setKey();
            return proof;
        }
        /**
         * Creates a coinbase (block reward) tx using a farmers keys and nonce.
         */
        async createCoinBaseTx(reward) {
            const coinbaseTx = tx_1.Tx.createCoinbase(this.publicKey, reward, this.nonce, this.privateKey);
            await this.incrementNonce();
            return coinbaseTx;
        }
        async close() {
            await this.storage.close();
        }
        /**
         * Creates a simple credit tx using a farmers keys and nonce.
         */
        async createCreditTx(amount, receiver) {
            const tx = tx_1.Tx.create(this.publicKey, receiver, amount, this.nonce, this.privateKey);
            await this.incrementNonce();
            return tx;
        }
        /**
         * Loads all addresses from disk on initialization.
         */
        async loadAddresses() {
            const binaryAddresses = await this.storage.get(STORAGE_ADDRESS);
            if (binaryAddresses) {
                for (let i = 0; i < binaryAddresses.length / constants_1.HASH_LENGTH; ++i) {
                    const address = binaryAddresses.subarray(i * constants_1.HASH_LENGTH, (i + 1) * constants_1.HASH_LENGTH);
                    this.addresses.add(Uint8Array.from(address));
                }
            }
        }
        async loadNonce() {
            const nonce = await this.storage.get(NONCE_ADDRESS);
            if (nonce) {
                this._nonce = utils_1.bin2Num(nonce);
            }
        }
        /**
         * Increments the nonce for the master address to prevent replay attacks.
         */
        async incrementNonce() {
            this._nonce++;
            await this.storage.put(NONCE_ADDRESS, utils_1.num2Bin(this._nonce));
        }
    }
    exports.Wallet = Wallet;
});

}).call(this,require("buffer").Buffer)
},{"../crypto/crypto":2,"../ledger/tx":11,"../main/constants":12,"../storage/storage":18,"../utils/utils":19,"buffer":98}],21:[function(require,module,exports){
(function (Buffer){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @param {Uint8Array} key 8 bytes (represents uint64 number)
     * @param {number} numBuckets Up to 32-bit number
     *
     * @return {number} Bucket from `[0, numBuckets)` range
     */
    function jumpConsistentHash(key, numBuckets) {
        let keyBigInt = Buffer.from(key).readBigUInt64BE();
        let b = -1n;
        let j = 0n;
        while (j < numBuckets) {
            b = j;
            // We fit the number after multiplication within 64-bit range, just like in C++ implementation from paper
            keyBigInt = (keyBigInt * 2862933555777941757n) % (2n ** 64n) + 1n;
            // Here we need to divide numbers as double (like in C++ implementation from paper), hence converting back to numbers for that
            // tslint:disable-next-line:no-bitwise
            j = BigInt(Math.floor((Number(b) + 1) * Number(1n << 31n) / Number((keyBigInt >> 33n) + 1n)));
        }
        return Number(b);
    }
    exports.jumpConsistentHash = jumpConsistentHash;
});

}).call(this,require("buffer").Buffer)
},{"buffer":98}],22:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./RuntimeError"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const RuntimeError_1 = require("./RuntimeError");
    function isNullOrBlack(node) {
        return (!node ||
            !node.getIsRed());
    }
    function isRed(node) {
        return Boolean(node && node.getIsRed());
    }
    function fixTree(nodeManager, path) {
        while (path.length) {
            const targetNode = path.pop();
            if (!targetNode) {
                throw new RuntimeError_1.RuntimeError("Can't fix path without target node, this should never happen");
            }
            const parent = path.pop();
            // `targetNode` is root, nothing left to do
            if (!parent) {
                return;
            }
            // No conflict, nothing left to do
            if (!parent.getIsRed()) {
                return;
            }
            const grandParent = path.pop();
            if (!grandParent) {
                parent.setIsRed(false);
                return;
            }
            const grandParentLeft = grandParent.getLeft();
            const grandParentRight = grandParent.getRight();
            const uncle = grandParentLeft === parent ? grandParentRight : grandParentLeft;
            // Here we handle `null` as black `nil` node implicitly, since we do not create `nil` nodes as such
            if (uncle && uncle.getIsRed()) {
                parent.setIsRed(!parent.getIsRed());
                grandParent.setIsRed(grandParent === nodeManager.getRoot() ? false : !grandParent.getIsRed());
                uncle.setIsRed(false);
                path.push(grandParent);
                continue;
            }
            // Triangle cases
            if (parent.getLeft() === targetNode &&
                grandParentRight === parent) {
                rotateRight(nodeManager, parent, grandParent);
                path.push(grandParent, targetNode, parent);
                continue;
            }
            else if (parent.getRight() === targetNode &&
                grandParentLeft === parent) {
                rotateLeft(nodeManager, parent, grandParent);
                path.push(grandParent, targetNode, parent);
                continue;
            }
            const grandGrandParent = path.pop() || null;
            // Line cases
            if (parent.getLeft() === targetNode) {
                rotateRight(nodeManager, grandParent, grandGrandParent);
            }
            else {
                rotateLeft(nodeManager, grandParent, grandGrandParent);
            }
            parent.setIsRed(!parent.getIsRed());
            grandParent.setIsRed(!grandParent.getIsRed());
            break;
        }
    }
    exports.fixTree = fixTree;
    /**
     * @param nodeManager
     * @param rotationNode
     * @param parent       `null` if `rotationNode` is root
     */
    function rotateLeft(nodeManager, rotationNode, parent) {
        const originalRightNode = rotationNode.getRight();
        if (!originalRightNode) {
            throw new RuntimeError_1.RuntimeError('Right children of rotation node is null, this should never happen');
        }
        rotationNode.setRight(originalRightNode.getLeft());
        originalRightNode.setLeft(rotationNode);
        rotateFixParentConnection(nodeManager, rotationNode, originalRightNode, parent);
    }
    /**
     * @param nodeManager
     * @param rotationNode
     * @param parent       `null` if `rotationNode` is root
     */
    function rotateRight(nodeManager, rotationNode, parent) {
        const originalLeftNode = rotationNode.getLeft();
        if (!originalLeftNode) {
            throw new RuntimeError_1.RuntimeError('Left children of rotation node is null, this should never happen');
        }
        rotationNode.setLeft(originalLeftNode.getRight());
        originalLeftNode.setRight(rotationNode);
        rotateFixParentConnection(nodeManager, rotationNode, originalLeftNode, parent);
    }
    function rotateFixParentConnection(nodeManager, rotationNode, originalNode, parent) {
        if (parent) {
            if (parent.getLeft() === rotationNode) {
                parent.setLeft(originalNode);
            }
            else {
                parent.setRight(originalNode);
            }
        }
        else {
            nodeManager.setRoot(originalNode);
        }
    }
    function removeNodeImplementation(nodeManager, path) {
        const nodeToRemove = path.pop();
        const parentNode = path.pop() || null;
        const xPath = path.slice();
        const xAndReplacement = determineXAndReplacement(nodeToRemove, parentNode, xPath);
        const [x, replacement] = xAndReplacement;
        let replacementParent = xAndReplacement[2];
        if (!parentNode) {
            if (!replacement) {
                throw new Error('Deleting root mode, but replacement is null, this should never happen');
            }
            nodeManager.setRoot(replacement);
        }
        else {
            if (parentNode.getLeft() === nodeToRemove) {
                parentNode.setLeft(replacement);
            }
            else {
                parentNode.setRight(replacement);
            }
        }
        if (replacement) {
            const nodeToRemoveLeft = nodeToRemove.getLeft();
            const nodeToRemoveRight = nodeToRemove.getRight();
            if (nodeToRemoveRight === replacement) {
                replacement.setLeft(nodeToRemoveLeft);
                if (replacement !== x) {
                    replacement.setRight(x);
                    replacementParent = replacement;
                    xPath.pop();
                }
            }
            else if (nodeToRemoveLeft === replacement) {
                replacement.setRight(nodeToRemoveRight);
                if (replacement !== x) {
                    replacement.setLeft(x);
                    replacementParent = replacement;
                    xPath.pop();
                }
            }
            else {
                replacement.setLeft(nodeToRemoveLeft);
                replacement.setRight(nodeToRemoveRight);
                if (replacementParent) {
                    if (replacementParent.getLeft() === replacement) {
                        replacementParent.setLeft(x);
                    }
                    else {
                        replacementParent.setRight(x);
                    }
                }
            }
        }
        const nodeToRemoveIsRed = nodeToRemove.getIsRed();
        if (nodeToRemoveIsRed &&
            (!replacement ||
                replacement.getIsRed())) {
            return;
        }
        if (nodeToRemoveIsRed &&
            replacement &&
            !replacement.getIsRed()) {
            replacement.setIsRed(true);
            handleRemovalCases(nodeManager, x, replacementParent, xPath);
            return;
        }
        if (!nodeToRemoveIsRed &&
            replacement &&
            replacement.getIsRed()) {
            replacement.setIsRed(false);
            return;
        }
        handleRemovalCases(nodeManager, x, replacementParent, xPath);
    }
    exports.removeNodeImplementation = removeNodeImplementation;
    /**
     * @param nodeToRemove
     * @param nodeToRemoveParent
     * @param xPath
     *
     * @return [x, replacement, replacementParent, replacementToTheLeft]
     */
    function determineXAndReplacement(nodeToRemove, nodeToRemoveParent, xPath) {
        const nodeToRemoveLeft = nodeToRemove.getLeft();
        const nodeToRemoveRight = nodeToRemove.getRight();
        if (!nodeToRemoveLeft || !nodeToRemoveRight) {
            const replacement = nodeToRemoveLeft || nodeToRemoveRight;
            return [
                replacement,
                replacement,
                replacement ? nodeToRemove : nodeToRemoveParent,
                Boolean(nodeToRemoveLeft),
            ];
        }
        let replacement = nodeToRemoveRight;
        let replacementParent = nodeToRemove;
        if (nodeToRemoveParent) {
            xPath.push(nodeToRemoveParent);
        }
        const xPathExtra = [];
        let left = replacement.getLeft();
        while (left) {
            replacementParent = replacement;
            replacement = left;
            xPathExtra.push(replacementParent);
            left = replacement.getLeft();
        }
        xPathExtra.pop();
        xPath.push(replacement, ...xPathExtra);
        return [
            replacement.getRight(),
            replacement,
            replacementParent,
            false,
        ];
    }
    function handleRemovalCases(nodeManager, x, xParent, xPath) {
        while (true) {
            if (!xParent) {
                return;
            }
            let xParentLeft = xParent.getLeft();
            let xParentRight = xParent.getRight();
            if (!xParentLeft && !xParentRight) {
                xParent.setIsRed(false);
                return;
            }
            // Case 0
            if (x && x.getIsRed()) {
                x.setIsRed(false);
                return;
            }
            let w = xParentLeft === x ? xParentRight : xParentLeft;
            // Case 1
            if ((!x ||
                !x.getIsRed()) &&
                (w &&
                    w.getIsRed())) {
                w.setIsRed(false);
                xParent.setIsRed(true);
                const xParentParent = xPath.pop() || null;
                if (xParentLeft === x) {
                    rotateLeft(nodeManager, xParent, xParentParent);
                }
                else {
                    rotateRight(nodeManager, xParent, xParentParent);
                }
                xParentLeft = xParent.getLeft();
                xParentRight = xParent.getRight();
                xPath.push(w);
                w = xParentLeft === x ? xParentRight : xParentLeft;
            }
            let wLeft = w && w.getLeft();
            let wRight = w && w.getRight();
            // Case 2
            if ((!x ||
                !x.getIsRed()) &&
                w &&
                !w.getIsRed() &&
                (isNullOrBlack(wLeft) &&
                    isNullOrBlack(wRight))) {
                w.setIsRed(true);
                x = xParent;
                if (x.getIsRed()) {
                    x.setIsRed(false);
                    return;
                }
                else {
                    xParent = xPath.pop();
                    if (!xParent) {
                        return;
                    }
                    continue;
                }
            }
            // Case 3
            if ((!x ||
                !x.getIsRed()) &&
                w &&
                !w.getIsRed() &&
                ((xParentLeft === x &&
                    isRed(wLeft) &&
                    isNullOrBlack(wRight)) ||
                    (xParentRight === x &&
                        isRed(wRight) &&
                        isNullOrBlack(wLeft)))) {
                if (xParentLeft === x) {
                    const left = wLeft;
                    if (left) {
                        left.setIsRed(false);
                    }
                }
                else if (xParentRight === x) {
                    const right = wRight;
                    if (right) {
                        right.setIsRed(false);
                    }
                }
                w.setIsRed(true);
                if (xParentLeft === x) {
                    rotateRight(nodeManager, w, xParent);
                }
                else {
                    rotateLeft(nodeManager, w, xParent);
                }
                w = xParentLeft === x ? xParentRight : xParentLeft;
                wLeft = w && w.getLeft();
                wRight = w && w.getRight();
            }
            // Case 4
            if ((!x ||
                !x.getIsRed()) &&
                w &&
                !w.getIsRed() &&
                ((xParentLeft === x &&
                    isRed(wRight)) ||
                    (xParentRight === x &&
                        isRed(wLeft)))) {
                w.setIsRed(xParent.getIsRed());
                xParent.setIsRed(false);
                const xParentParent = xPath.pop() || null;
                if (xParentLeft === x) {
                    const right = wRight;
                    if (right) {
                        right.setIsRed(false);
                    }
                    rotateLeft(nodeManager, xParent, xParentParent);
                }
                else if (xParentRight === x) {
                    const left = wLeft;
                    if (left) {
                        left.setIsRed(false);
                    }
                    rotateRight(nodeManager, xParent, xParentParent);
                }
                return;
            }
        }
    }
    // Functions below are exactly the same as above, but use asynchronous node API
    /**
     * @param nodeManager
     * @param rotationNode
     * @param parent       `null` if `rotationNode` is root
     */
    async function rotateLeftAsync(nodeManager, rotationNode, parent) {
        const originalRightNode = await rotationNode.getRightAsync();
        if (!originalRightNode) {
            throw new RuntimeError_1.RuntimeError('Right children of rotation node is null, this should never happen');
        }
        rotationNode.setRight(await originalRightNode.getLeftAsync());
        originalRightNode.setLeft(rotationNode);
        rotateFixParentConnectionAsync(nodeManager, rotationNode, originalRightNode, parent);
    }
    /**
     * @param nodeManager
     * @param rotationNode
     * @param parent       `null` if `rotationNode` is root
     */
    async function rotateRightAsync(nodeManager, rotationNode, parent) {
        const originalLeftNode = await rotationNode.getLeftAsync();
        if (!originalLeftNode) {
            throw new RuntimeError_1.RuntimeError('Left children of rotation node is null, this should never happen');
        }
        rotationNode.setLeft(await originalLeftNode.getRightAsync());
        originalLeftNode.setRight(rotationNode);
        rotateFixParentConnectionAsync(nodeManager, rotationNode, originalLeftNode, parent);
    }
    async function rotateFixParentConnectionAsync(nodeManager, rotationNode, originalNode, parent) {
        if (parent) {
            if (await parent.getLeftAsync() === rotationNode) {
                parent.setLeft(originalNode);
            }
            else {
                parent.setRight(originalNode);
            }
        }
        else {
            nodeManager.setRoot(originalNode);
        }
    }
    async function removeNodeImplementationAsync(nodeManager, path) {
        const nodeToRemove = path.pop();
        const parentNode = path.pop() || null;
        const xPath = path.slice();
        const xAndReplacement = await determineXAndReplacementAsync(nodeToRemove, parentNode, xPath);
        const [x, replacement] = xAndReplacement;
        let replacementParent = xAndReplacement[2];
        if (!parentNode) {
            if (!replacement) {
                throw new Error('Deleting root mode, but replacement is null, this should never happen');
            }
            nodeManager.setRoot(replacement);
        }
        else {
            if (await parentNode.getLeftAsync() === nodeToRemove) {
                parentNode.setLeft(replacement);
            }
            else {
                parentNode.setRight(replacement);
            }
        }
        if (replacement) {
            const nodeToRemoveLeft = await nodeToRemove.getLeftAsync();
            const nodeToRemoveRight = await nodeToRemove.getRightAsync();
            if (nodeToRemoveRight === replacement) {
                replacement.setLeft(nodeToRemoveLeft);
                if (replacement !== x) {
                    replacement.setRight(x);
                    replacementParent = replacement;
                    xPath.pop();
                }
            }
            else if (nodeToRemoveLeft === replacement) {
                replacement.setRight(nodeToRemoveRight);
                if (replacement !== x) {
                    replacement.setLeft(x);
                    replacementParent = replacement;
                    xPath.pop();
                }
            }
            else {
                replacement.setLeft(nodeToRemoveLeft);
                replacement.setRight(nodeToRemoveRight);
                if (replacementParent) {
                    if (await replacementParent.getLeftAsync() === replacement) {
                        replacementParent.setLeft(x);
                    }
                    else {
                        replacementParent.setRight(x);
                    }
                }
            }
        }
        const nodeToRemoveIsRed = nodeToRemove.getIsRed();
        if (nodeToRemoveIsRed &&
            (!replacement ||
                replacement.getIsRed())) {
            return;
        }
        if (nodeToRemoveIsRed &&
            replacement &&
            !replacement.getIsRed()) {
            replacement.setIsRed(true);
            await handleRemovalCasesAsync(nodeManager, x, replacementParent, xPath);
            return;
        }
        if (!nodeToRemoveIsRed &&
            replacement &&
            replacement.getIsRed()) {
            replacement.setIsRed(false);
            return;
        }
        await handleRemovalCasesAsync(nodeManager, x, replacementParent, xPath);
    }
    exports.removeNodeImplementationAsync = removeNodeImplementationAsync;
    /**
     * @param nodeToRemove
     * @param nodeToRemoveParent
     * @param xPath
     *
     * @return [x, replacement, replacementParent, replacementToTheLeft]
     */
    async function determineXAndReplacementAsync(nodeToRemove, nodeToRemoveParent, xPath) {
        const nodeToRemoveLeft = await nodeToRemove.getLeftAsync();
        const nodeToRemoveRight = await nodeToRemove.getRightAsync();
        if (!nodeToRemoveLeft || !nodeToRemoveRight) {
            const replacement = nodeToRemoveLeft || nodeToRemoveRight;
            return [
                replacement,
                replacement,
                replacement ? nodeToRemove : nodeToRemoveParent,
                Boolean(nodeToRemoveLeft),
            ];
        }
        let replacement = nodeToRemoveRight;
        let replacementParent = nodeToRemove;
        if (nodeToRemoveParent) {
            xPath.push(nodeToRemoveParent);
        }
        const xPathExtra = [];
        let left = await replacement.getLeftAsync();
        while (left) {
            replacementParent = replacement;
            replacement = left;
            xPathExtra.push(replacementParent);
            left = await replacement.getLeftAsync();
        }
        xPathExtra.pop();
        xPath.push(replacement, ...xPathExtra);
        return [
            await replacement.getRightAsync(),
            replacement,
            replacementParent,
            false,
        ];
    }
    async function handleRemovalCasesAsync(nodeManager, x, xParent, xPath) {
        while (true) {
            if (!xParent) {
                return;
            }
            let xParentLeft = await xParent.getLeftAsync();
            let xParentRight = await xParent.getRightAsync();
            if (!xParentLeft && !xParentRight) {
                xParent.setIsRed(false);
                return;
            }
            // Case 0
            if (x && x.getIsRed()) {
                x.setIsRed(false);
                return;
            }
            let w = xParentLeft === x ? xParentRight : xParentLeft;
            // Case 1
            if ((!x ||
                !x.getIsRed()) &&
                (w &&
                    w.getIsRed())) {
                w.setIsRed(false);
                xParent.setIsRed(true);
                const xParentParent = xPath.pop() || null;
                if (xParentLeft === x) {
                    await rotateLeftAsync(nodeManager, xParent, xParentParent);
                }
                else {
                    await rotateRightAsync(nodeManager, xParent, xParentParent);
                }
                xParentLeft = await xParent.getLeftAsync();
                xParentRight = await xParent.getRightAsync();
                xPath.push(w);
                w = xParentLeft === x ? xParentRight : xParentLeft;
            }
            let wLeft = w && await w.getLeftAsync();
            let wRight = w && await w.getRightAsync();
            // Case 2
            if ((!x ||
                !x.getIsRed()) &&
                w &&
                !w.getIsRed() &&
                (isNullOrBlack(wLeft) &&
                    isNullOrBlack(wRight))) {
                w.setIsRed(true);
                x = xParent;
                if (x.getIsRed()) {
                    x.setIsRed(false);
                    return;
                }
                else {
                    xParent = xPath.pop();
                    if (!xParent) {
                        return;
                    }
                    continue;
                }
            }
            // Case 3
            if ((!x ||
                !x.getIsRed()) &&
                w &&
                !w.getIsRed() &&
                ((xParentLeft === x &&
                    isRed(wLeft) &&
                    isNullOrBlack(wRight)) ||
                    (xParentRight === x &&
                        isRed(wRight) &&
                        isNullOrBlack(wLeft)))) {
                if (xParentLeft === x) {
                    const left = wLeft;
                    if (left) {
                        left.setIsRed(false);
                    }
                }
                else if (xParentRight === x) {
                    const right = wRight;
                    if (right) {
                        right.setIsRed(false);
                    }
                }
                w.setIsRed(true);
                if (xParentLeft === x) {
                    await rotateRightAsync(nodeManager, w, xParent);
                }
                else {
                    await rotateLeftAsync(nodeManager, w, xParent);
                }
                w = xParentLeft === x ? xParentRight : xParentLeft;
                wLeft = w && await w.getLeftAsync();
                wRight = w && await w.getRightAsync();
            }
            // Case 4
            if ((!x ||
                !x.getIsRed()) &&
                w &&
                !w.getIsRed() &&
                ((xParentLeft === x &&
                    isRed(wRight)) ||
                    (xParentRight === x &&
                        isRed(wLeft)))) {
                w.setIsRed(xParent.getIsRed());
                xParent.setIsRed(false);
                const xParentParent = xPath.pop() || null;
                if (xParentLeft === x) {
                    const right = wRight;
                    if (right) {
                        right.setIsRed(false);
                    }
                    await rotateLeftAsync(nodeManager, xParent, xParentParent);
                }
                else if (xParentRight === x) {
                    const left = wLeft;
                    if (left) {
                        left.setIsRed(false);
                    }
                    await rotateRightAsync(nodeManager, xParent, xParentParent);
                }
                return;
            }
        }
    }
});

},{"./RuntimeError":23}],23:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class RuntimeError extends Error {
    }
    exports.RuntimeError = RuntimeError;
});

},{}],24:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./RedBlackTreeMechanics"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const RedBlackTreeMechanics_1 = require("./RedBlackTreeMechanics");
    /**
     * Resources used to write this:
     * * https://www.youtube.com/playlist?list=PL9xmBV_5YoZNqDI8qfOZgzbqahCUmUEin
     * * https://www.youtube.com/watch?v=YCo2-H2CL6Q
     * * https://www.youtube.com/watch?v=eO3GzpCCUSg
     */
    class Tree {
        constructor(nodeManager) {
            this.nodeManager = nodeManager;
        }
        /**
         * Add nodes to a tree one by one (for incremental updates)
         *
         * @param key
         * @param value Value to be associated with a key
         */
        addNode(key, value) {
            this.addNodeInternal(key, value);
            this.nodeManager.cleanup();
        }
        /**
         * Remove a node from the tree
         *
         * @param key
         */
        removeNode(key) {
            this.removeNodeInternal(key);
            this.nodeManager.cleanup();
        }
        /**
         * Get the node value by target key
         *
         * @param targetKey
         *
         * @return
         */
        getNodeValue(targetKey) {
            const result = this.getClosestNodeInternal(targetKey);
            if (result && this.nodeManager.compare(result[0], targetKey) === 0) {
                return result[1];
            }
            return null;
        }
        /**
         * Get the closest node key/value in a tree to a given target key
         *
         * @param targetKey
         *
         * @return The closest key and its value to the challenge or `null` if no nodes are available
         */
        getClosestNode(targetKey) {
            const result = this.getClosestNodeInternal(targetKey);
            this.nodeManager.cleanup();
            return result;
        }
        addNodeInternal(key, value) {
            const nodeManager = this.nodeManager;
            const nodeToInsert = nodeManager.addNode(key, value);
            const root = nodeManager.getRoot();
            if (!root) {
                nodeToInsert.setIsRed(false);
                nodeManager.setRoot(nodeToInsert);
            }
            else {
                let currentNode = root;
                const path = [];
                while (true) {
                    path.push(currentNode);
                    switch (nodeManager.compare(nodeToInsert.getKey(), currentNode.getKey())) {
                        case -1:
                            const left = currentNode.getLeft();
                            if (left) {
                                currentNode = left;
                                break;
                            }
                            else {
                                currentNode.setLeft(nodeToInsert);
                                path.push(nodeToInsert);
                                RedBlackTreeMechanics_1.fixTree(this.nodeManager, path);
                                return;
                            }
                        case 1:
                            const right = currentNode.getRight();
                            if (right) {
                                currentNode = right;
                                break;
                            }
                            else {
                                currentNode.setRight(nodeToInsert);
                                path.push(nodeToInsert);
                                RedBlackTreeMechanics_1.fixTree(this.nodeManager, path);
                                return;
                            }
                        default:
                            // We do not insert the same key again
                            return;
                    }
                }
            }
        }
        removeNodeInternal(key) {
            const nodeManager = this.nodeManager;
            const root = nodeManager.getRoot();
            if (!root) {
                throw new Error("Tree is empty, nothing to delete");
            }
            if (!root.getLeft() && !root.getRight()) {
                nodeManager.setRoot(null);
                return;
            }
            let currentNode = root;
            const path = [];
            while (true) {
                path.push(currentNode);
                switch (nodeManager.compare(key, currentNode.getKey())) {
                    case -1:
                        const left = currentNode.getLeft();
                        if (left) {
                            currentNode = left;
                            break;
                        }
                        else {
                            throw new Error("Can't delete a key, it doesn't exist");
                        }
                    case 1:
                        const right = currentNode.getRight();
                        if (right) {
                            currentNode = right;
                            break;
                        }
                        else {
                            throw new Error("Can't delete a key, it doesn't exist");
                        }
                    default:
                        if (currentNode === root && !root.getLeft() && !root.getRight()) {
                            nodeManager.setRoot(null);
                            return;
                        }
                        RedBlackTreeMechanics_1.removeNodeImplementation(this.nodeManager, path);
                        nodeManager.removeNode(currentNode);
                        return;
                }
            }
        }
        getClosestNodeInternal(targetKey) {
            const nodeManager = this.nodeManager;
            let currentNode = nodeManager.getRoot();
            if (!currentNode) {
                return null;
            }
            const path = [];
            while (true) {
                const key = currentNode.getKey();
                path.push(currentNode);
                switch (nodeManager.compare(targetKey, key)) {
                    case -1:
                        const left = currentNode.getLeft();
                        if (left) {
                            currentNode = left;
                            break;
                        }
                        else {
                            const closestNode = this.pickClosestNode(path, targetKey);
                            return [closestNode.getKey(), closestNode.getValue()];
                        }
                    case 1:
                        const right = currentNode.getRight();
                        if (right) {
                            currentNode = right;
                            break;
                        }
                        else {
                            const closestNode = this.pickClosestNode(path, targetKey);
                            return [closestNode.getKey(), closestNode.getValue()];
                        }
                    default:
                        return [key, currentNode.getValue()];
                }
            }
        }
        pickClosestNode(nodes, targetKey) {
            const nodeManager = this.nodeManager;
            const distances = new Map();
            for (const node of nodes) {
                distances.set(node, nodeManager.distance(node.getKey(), targetKey));
            }
            return nodes.sort((nodeA, nodeB) => {
                const distanceA = distances.get(nodeA);
                const distanceB = distances.get(nodeB);
                if (distanceA === distanceB) {
                    return 0;
                }
                return distanceA < distanceB ? -1 : 1;
            })[0];
        }
    }
    exports.Tree = Tree;
});

},{"./RedBlackTreeMechanics":22}],25:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./RedBlackTreeMechanics"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const RedBlackTreeMechanics_1 = require("./RedBlackTreeMechanics");
    class TreeAsync {
        constructor(nodeManager) {
            this.nodeManager = nodeManager;
        }
        /**
         * Add nodes to a tree one by one (for incremental updates)
         *
         * @param key  A key to be indexed, e.g. a 32 byte piece id
         * @param value Value to be associated with a key
         */
        async addNode(key, value) {
            await this.nodeManager.writeTransaction(() => {
                return this.addNodeInternal(key, value);
            });
            this.nodeManager.cleanup();
        }
        /**
         * Remove a node from the tree
         *
         * @param key A key to be removed, e.g. a 32 byte piece id
         */
        async removeNode(key) {
            await this.nodeManager.writeTransaction(() => {
                return this.removeNodeInternal(key);
            });
            this.nodeManager.cleanup();
        }
        /**
         * Get the node value by target key
         *
         * @param targetKey
         *
         * @return
         */
        async getNodeValue(targetKey) {
            const result = await this.getClosestNodeInternal(targetKey);
            if (result && this.nodeManager.compare(result[0], targetKey) === 0) {
                return result[1];
            }
            return null;
        }
        /**
         * Get the closest node key/value in a tree to a given target key
         *
         * @param targetKey
         *
         * @return The closest key and its value to the challenge or `null` if no nodes are available
         */
        async getClosestNode(targetKey) {
            const result = await this.nodeManager.readTransaction(() => {
                return this.getClosestNodeInternal(targetKey);
            });
            this.nodeManager.cleanup();
            return result;
        }
        async addNodeInternal(key, value) {
            const nodeManager = this.nodeManager;
            const nodeToInsert = await nodeManager.addNodeAsync(key, value);
            const root = await nodeManager.getRootAsync();
            if (!root) {
                nodeToInsert.setIsRed(false);
                nodeManager.setRoot(nodeToInsert);
            }
            else {
                let currentNode = root;
                const path = [];
                while (true) {
                    path.push(currentNode);
                    // Force reading both children, we may need them during tree fixing process and unless they are in cache, `getLeft()` and `getRight()` methods
                    // will fail for `INodeAsync`
                    const left = await currentNode.getLeftAsync();
                    const right = await currentNode.getRightAsync();
                    switch (nodeManager.compare(nodeToInsert.getKey(), currentNode.getKey())) {
                        case -1:
                            if (left) {
                                currentNode = left;
                                break;
                            }
                            else {
                                currentNode.setLeft(nodeToInsert);
                                path.push(nodeToInsert);
                                RedBlackTreeMechanics_1.fixTree(this.nodeManager, path);
                                return;
                            }
                        case 1:
                            if (right) {
                                currentNode = right;
                                break;
                            }
                            else {
                                currentNode.setRight(nodeToInsert);
                                path.push(nodeToInsert);
                                RedBlackTreeMechanics_1.fixTree(this.nodeManager, path);
                                return;
                            }
                        default:
                            // We do not insert the same key again
                            return;
                    }
                }
            }
        }
        async removeNodeInternal(key) {
            const nodeManager = this.nodeManager;
            const root = await nodeManager.getRootAsync();
            if (!root) {
                throw new Error("Tree is empty, nothing to delete");
            }
            if (!await root.getLeftAsync() && !await root.getRightAsync()) {
                nodeManager.setRoot(null);
                return;
            }
            let currentNode = root;
            const path = [];
            while (true) {
                path.push(currentNode);
                switch (nodeManager.compare(key, currentNode.getKey())) {
                    case -1:
                        const left = await currentNode.getLeftAsync();
                        if (left) {
                            currentNode = left;
                            break;
                        }
                        else {
                            throw new Error("Can't delete a key, it doesn't exist");
                        }
                    case 1:
                        const right = await currentNode.getRightAsync();
                        if (right) {
                            currentNode = right;
                            break;
                        }
                        else {
                            throw new Error("Can't delete a key, it doesn't exist");
                        }
                    default:
                        if (currentNode === root && !root.getLeft() && !root.getRight()) {
                            nodeManager.setRoot(null);
                            return;
                        }
                        await RedBlackTreeMechanics_1.removeNodeImplementationAsync(this.nodeManager, path);
                        await nodeManager.removeNodeAsync(currentNode);
                        return;
                }
            }
        }
        async getClosestNodeInternal(targetKey) {
            const nodeManager = this.nodeManager;
            let currentNode = await nodeManager.getRootAsync();
            if (!currentNode) {
                return null;
            }
            const path = [];
            while (true) {
                const key = currentNode.getKey();
                path.push(currentNode);
                switch (nodeManager.compare(targetKey, key)) {
                    case -1:
                        // TypeScript fails to infer type, so have to specify it explicitly
                        const left = await currentNode.getLeftAsync();
                        if (left) {
                            currentNode = left;
                            break;
                        }
                        else {
                            const closestNode = this.pickClosestNode(path, targetKey);
                            return [closestNode.getKey(), await closestNode.getValueAsync()];
                        }
                    case 1:
                        // TypeScript fails to infer type, so have to specify it explicitly
                        const right = await currentNode.getRightAsync();
                        if (right) {
                            currentNode = right;
                            break;
                        }
                        else {
                            const closestNode = this.pickClosestNode(path, targetKey);
                            return [closestNode.getKey(), await closestNode.getValueAsync()];
                        }
                    default:
                        return [key, await currentNode.getValueAsync()];
                }
            }
        }
        pickClosestNode(nodes, targetKey) {
            const nodeManager = this.nodeManager;
            const distances = new Map();
            for (const node of nodes) {
                distances.set(node, nodeManager.distance(node.getKey(), targetKey));
            }
            return nodes.sort((nodeA, nodeB) => {
                const distanceA = distances.get(nodeA);
                const distanceB = distances.get(nodeB);
                if (distanceA === distanceB) {
                    return 0;
                }
                return distanceA < distanceB ? -1 : 1;
            })[0];
        }
    }
    exports.TreeAsync = TreeAsync;
});

},{"./RedBlackTreeMechanics":22}],26:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Generic implementation that has useful `readTransaction()` and `writeTransaction()` methods
     */
    class NodeManagerAsyncGeneric {
        constructor() {
            this.lastTransactionPromise = Promise.resolve();
        }
        readTransaction(callback) {
            // TODO: Implement batching of read transactions for potentially better performance, potentially with higher priority than write transaction
            const transaction = this.lastTransactionPromise.then(callback);
            this.lastTransactionPromise = transaction.catch(() => {
                // Just to avoid unhandled promise exception
            });
            return transaction;
        }
        writeTransaction(callback) {
            const transaction = this.lastTransactionPromise.then(callback);
            this.lastTransactionPromise = transaction.catch(() => {
                // Just to avoid unhandled promise exception
            });
            return transaction;
        }
    }
    exports.NodeManagerAsyncGeneric = NodeManagerAsyncGeneric;
});

},{}],27:[function(require,module,exports){
(function (Buffer){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    class File {
        constructor(handle) {
            this.handle = handle;
            this.lastTransactionPromise = Promise.resolve();
        }
        static async open(pathToFile) {
            const handle = await fs.promises.open(pathToFile, 'r+');
            return new File(handle);
        }
        read(offset, bytes) {
            // TODO: Implement batching of read transactions for potentially better performance, potentially with higher priority than write transaction
            const transaction = this.lastTransactionPromise.then(async () => {
                const buffer = Buffer.allocUnsafe(bytes);
                await this.handle.read(buffer, 0, bytes, offset);
                return new Uint8Array(buffer);
            });
            this.lastTransactionPromise = transaction.catch(() => {
                // Just to avoid unhandled promise exception
            });
            return transaction;
        }
        write(offset, value) {
            const transaction = this.lastTransactionPromise.then(async () => {
                await this.handle.write(value, 0, value.length, offset);
            });
            this.lastTransactionPromise = transaction.catch(() => {
                // Just to avoid unhandled promise exception
            });
            return transaction;
        }
        async close() {
            await this.handle.close();
        }
    }
    exports.File = File;
});

}).call(this,require("buffer").Buffer)
},{"buffer":98,"fs":96}],28:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../../../RuntimeError", "../../../utils", "./utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const RuntimeError_1 = require("../../../RuntimeError");
    const utils_1 = require("../../../utils");
    const utils_2 = require("./utils");
    class NodeBinaryDisk {
        /**
         * @param offset
         * @param isRed
         * @param leftOffset
         * @param rightOffset
         * @param key
         * @param valueSize
         * @param source Binary data where contents of the node is located
         * @param sourceOffset Offset in binary data in bytes where node is located
         * @param nodeOffsetBytes
         * @param numberOfNodes
         * @param getNode
         */
        constructor(offset, isRed, leftOffset, rightOffset, key, valueSize, source, sourceOffset, nodeOffsetBytes, numberOfNodes, getNode) {
            this.offset = offset;
            this.isRed = isRed;
            this.leftOffset = leftOffset;
            this.rightOffset = rightOffset;
            this.key = key;
            this.valueSize = valueSize;
            this.source = source;
            this.sourceOffset = sourceOffset;
            this.nodeOffsetBytes = nodeOffsetBytes;
            this.numberOfNodes = numberOfNodes;
            this.getNode = getNode;
            this.leftCache = undefined;
            this.rightCache = undefined;
            this.valueCache = undefined;
        }
        /**
         * @param nodeOffsetBytes
         * @param numberOfNodes
         * @param source Binary data where contents of the node is located
         * @param sourceOffset Offset in binary data in bytes where node is located
         * @param offset
         * @param key
         * @param value
         * @param getNode
         */
        static async create(nodeOffsetBytes, numberOfNodes, source, sourceOffset, offset, key, value, getNode) {
            const keySize = key.length;
            const valueSize = value.length;
            const nodeData = new Uint8Array(1 + nodeOffsetBytes * 2 + keySize + valueSize);
            // Set `isRed` to `true`
            nodeData.set([1]);
            // Set left child to `null`
            utils_1.setNumberToBytes(nodeData, 1, nodeOffsetBytes, numberOfNodes);
            // Set right child to `null`
            utils_1.setNumberToBytes(nodeData, 1 + nodeOffsetBytes, nodeOffsetBytes, numberOfNodes);
            // Set key
            nodeData.set(key, 1 + nodeOffsetBytes * 2);
            // Set value
            nodeData.set(value, 1 + nodeOffsetBytes * 2 + keySize);
            await source.write(sourceOffset, nodeData);
            const instance = new NodeBinaryDisk(offset, true, numberOfNodes, numberOfNodes, key, valueSize, source, sourceOffset, nodeOffsetBytes, numberOfNodes, getNode);
            instance.leftCache = null;
            instance.rightCache = null;
            return instance;
        }
        /**
         * @param nodeOffsetBytes
         * @param numberOfNodes
         * @param source Binary data where contents of the node is located
         * @param sourceOffset Offset in binary data in bytes where node is located
         * @param offset
         * @param keySize
         * @param valueSize
         * @param getNode
         */
        static async read(nodeOffsetBytes, numberOfNodes, source, sourceOffset, offset, keySize, valueSize, getNode) {
            const header = await source.read(sourceOffset, 1 + 2 * nodeOffsetBytes + keySize);
            return new NodeBinaryDisk(offset, header[0] === 1, utils_1.getNumberFromBytes(header, 1, nodeOffsetBytes), utils_1.getNumberFromBytes(header, 1 + nodeOffsetBytes, nodeOffsetBytes), header.subarray(1 + 2 * nodeOffsetBytes, 1 + 2 * nodeOffsetBytes + keySize), valueSize, source, sourceOffset, nodeOffsetBytes, numberOfNodes, getNode);
        }
        getIsRed() {
            return this.isRed;
        }
        setIsRed(isRed) {
            if (isRed !== this.isRed) {
                this.isRed = isRed;
                this.source.write(this.sourceOffset, Uint8Array.of(isRed ? 1 : 0))
                    .catch(() => {
                    // Just to avoid unhandled promise exception
                });
            }
        }
        getKey() {
            return this.key;
        }
        async getLeftAsync() {
            if (this.leftCache === undefined) {
                const offset = this.leftOffset;
                this.leftCache = offset === this.numberOfNodes ? null : await this.getNode(offset);
            }
            return this.leftCache;
        }
        async getRightAsync() {
            if (this.rightCache === undefined) {
                const offset = this.rightOffset;
                this.rightCache = offset === this.numberOfNodes ? null : await this.getNode(offset);
            }
            return this.rightCache;
        }
        async getValueAsync() {
            if (this.valueCache === undefined) {
                const baseOffset = this.sourceOffset + 1 + this.nodeOffsetBytes * 2 + this.key.length;
                this.valueCache = await this.source.read(baseOffset, this.valueSize);
            }
            return this.valueCache;
        }
        getLeft() {
            if (this.leftCache === undefined) {
                throw new RuntimeError_1.RuntimeError('getLeftAsync() needs to be called first');
            }
            return this.leftCache;
        }
        setLeft(node) {
            this.leftCache = node;
            const offset = node ? node.offset : this.numberOfNodes;
            this.leftOffset = offset;
            utils_2.setNumberToFileBytes(this.source, this.sourceOffset + 1, this.nodeOffsetBytes, offset)
                .catch(() => {
                // Just to avoid unhandled promise exception
            });
        }
        getRight() {
            if (this.rightCache === undefined) {
                throw new RuntimeError_1.RuntimeError('getRightAsync() needs to be called first');
            }
            return this.rightCache;
        }
        setRight(node) {
            this.rightCache = node;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            const offset = node ? node.offset : this.numberOfNodes;
            this.rightOffset = offset;
            utils_2.setNumberToFileBytes(this.source, this.sourceOffset + 1 + nodeOffsetBytes, nodeOffsetBytes, offset)
                .catch(() => {
                // Just to avoid unhandled promise exception
            });
        }
        getValue() {
            if (this.valueCache === undefined) {
                throw new RuntimeError_1.RuntimeError('getValueAsync() needs to be called first');
            }
            return this.valueCache;
        }
    }
    exports.NodeBinaryDisk = NodeBinaryDisk;
});

},{"../../../RuntimeError":23,"../../../utils":39,"./utils":30}],29:[function(require,module,exports){
(function (Buffer){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs", "../../../RuntimeError", "../../../utils", "../../NodeManagerAsyncGeneric", "./File", "./NodeBinaryDisk", "./utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs = require("fs");
    const RuntimeError_1 = require("../../../RuntimeError");
    const utils_1 = require("../../../utils");
    const NodeManagerAsyncGeneric_1 = require("../../NodeManagerAsyncGeneric");
    const File_1 = require("./File");
    const NodeBinaryDisk_1 = require("./NodeBinaryDisk");
    const utils_2 = require("./utils");
    async function allocateEmptyFile(path, size, chunkSize) {
        const fileHandle = await fs.promises.open(path, 'w');
        let written = 0;
        const emptyPiece = Buffer.alloc(chunkSize);
        while (written < size) {
            await fileHandle.write(emptyPiece.slice(0, Math.min(chunkSize, size - written)));
            written += chunkSize;
        }
        await fileHandle.close();
    }
    /**
     * Node manager implementation that can work with any data type supported in Node.js as a value
     */
    class NodeManagerBinaryDisk extends NodeManagerAsyncGeneric_1.NodeManagerAsyncGeneric {
        constructor(storageData, numberOfNodes, nodeOffsetBytes, keySize, valueSize, singleNodeAllocationSize) {
            super();
            this.storageData = storageData;
            this.numberOfNodes = numberOfNodes;
            this.nodeOffsetBytes = nodeOffsetBytes;
            this.keySize = keySize;
            this.valueSize = valueSize;
            this.singleNodeAllocationSize = singleNodeAllocationSize;
            this.compare = utils_1.compareUint8Array;
            this.distance = utils_1.uint8ArraysDiff;
            this.rootCache = undefined;
        }
        /**
         * @param pathToFile Full path to the file where data will be stored
         * @param numberOfNodes Max number of nodes that are expected to be stored
         * @param keySize Size of the key in bytes
         * @param valueSize Size of the values associated with a key in bytes
         */
        static async create(pathToFile, numberOfNodes, keySize, valueSize) {
            // offset starts from 0, but addresses with index of last possible node + 1 will be treated as `null` node for everyone to reference
            const nodeOffsetBytes = utils_1.maxNumberToBytes(numberOfNodes);
            // 1 byte for red/black flag and 2 * nodeOffsetBytes for left and right children
            const nodeMetadataSize = 1 + nodeOffsetBytes * 2;
            const singleNodeAllocationSize = nodeMetadataSize + keySize + valueSize;
            /**
             * * one offset for the first free offset for the next node to be inserted
             * * one offset for last deleted node that can be used to add another node
             * * one offset for root node offset
             */
            const commonMetadataSize = nodeOffsetBytes * 3;
            const allocationSize = commonMetadataSize + numberOfNodes * singleNodeAllocationSize;
            // Allocate the whole file upfront for better performance, write in chunks of 2MiB
            await allocateEmptyFile(pathToFile, allocationSize, 1024 * 1024 * 2);
            const instance = await NodeManagerBinaryDisk.open(pathToFile, numberOfNodes, keySize, valueSize);
            await instance.setFreeNodeOffset(0);
            await instance.setDeletedNodeOffset(numberOfNodes);
            await instance.setRootNodeOffset(numberOfNodes);
            return instance;
        }
        /**
         * @param pathToFile Full path to the file where data is stored
         * @param numberOfNodes Max number of nodes that are expected to be stored
         * @param keySize Size of the key in bytes
         * @param valueSize Size of the values associated with a key in bytes
         */
        static async open(pathToFile, numberOfNodes, keySize, valueSize) {
            // offset starts from 0, but addresses with index of last possible node + 1 will be treated as `null` node for everyone to reference
            const nodeOffsetBytes = utils_1.maxNumberToBytes(numberOfNodes);
            // 1 byte for red/black flag and 2 * nodeOffsetBytes for left and right children
            const nodeMetadataSize = 1 + nodeOffsetBytes * 2;
            const singleNodeAllocationSize = nodeMetadataSize + keySize + valueSize;
            /**
             * * one offset for the first free offset for the next node to be inserted
             * * one offset for last deleted node that can be used to add another node
             * * one offset for root node offset
             */
            const commonMetadataSize = nodeOffsetBytes * 3;
            const allocationSize = commonMetadataSize + numberOfNodes * singleNodeAllocationSize;
            const storageSize = (await fs.promises.stat(pathToFile)).size;
            if (storageSize !== allocationSize) {
                throw new Error(`Actual storage size of ${storageSize} bytes doesn't match expected allocation size of ${allocationSize} bytes`);
            }
            const storageData = await File_1.File.open(pathToFile);
            const instance = new NodeManagerBinaryDisk(storageData, numberOfNodes, nodeOffsetBytes, keySize, valueSize, singleNodeAllocationSize);
            instance.freeNodeOffset = await utils_2.getNumberFromFileBytes(storageData, 0, nodeOffsetBytes);
            instance.deletedNodeOffset = await utils_2.getNumberFromFileBytes(storageData, nodeOffsetBytes, nodeOffsetBytes);
            instance.rootNodeOffset = await utils_2.getNumberFromFileBytes(storageData, nodeOffsetBytes * 2, nodeOffsetBytes);
            return instance;
        }
        async getRootAsync() {
            if (this.rootCache === undefined) {
                const offset = await this.getRootNodeOffset();
                this.rootCache = offset === this.numberOfNodes ? null : await this.getNode(offset);
            }
            return this.rootCache;
        }
        async addNodeAsync(key, value) {
            const offset = await this.allocateOffsetForAddition();
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            return NodeBinaryDisk_1.NodeBinaryDisk.create(nodeOffsetBytes, this.numberOfNodes, this.storageData, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, offset, key, value, this.getNode.bind(this));
        }
        async removeNodeAsync(node) {
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            const offset = node.offset;
            const lastDeletedOffset = await this.getDeletedNodeOffset();
            // Store previous last deleted node in currently deleting node data
            await utils_2.setNumberToFileBytes(this.storageData, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, nodeOffsetBytes, lastDeletedOffset);
            // Update last deleted node offset
            return this.setDeletedNodeOffset(offset);
        }
        getRoot() {
            if (this.rootCache === undefined) {
                throw new RuntimeError_1.RuntimeError('getRootAsync() needs to be called first');
            }
            return this.rootCache;
        }
        setRoot(node) {
            this.rootCache = node;
            this.setRootNodeOffset(node === null ? this.numberOfNodes : node.offset)
                .catch(() => {
                // Just to avoid unhandled promise exception
            });
        }
        cleanup() {
            this.rootCache = undefined;
        }
        close() {
            return this.storageData.close();
        }
        async allocateOffsetForAddition() {
            const numberOfNodes = this.numberOfNodes;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const offset = await this.getFreeNodeOffset();
            if (offset !== numberOfNodes) {
                await this.setFreeNodeOffset(offset + 1);
                return offset;
            }
            else {
                const offset = await this.getDeletedNodeOffset();
                if (offset === numberOfNodes) {
                    throw new RuntimeError_1.RuntimeError("No space left for new nodes");
                }
                // By convention deleted node stores offset of previous deleted node in its first bytes
                const previousOffset = await utils_2.getNumberFromFileBytes(this.storageData, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, nodeOffsetBytes);
                this.setDeletedNodeOffset(previousOffset);
                return offset;
            }
        }
        getNode(offset) {
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            return NodeBinaryDisk_1.NodeBinaryDisk.read(nodeOffsetBytes, this.numberOfNodes, this.storageData, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, offset, this.keySize, this.valueSize, this.getNode.bind(this));
        }
        async getFreeNodeOffset() {
            return this.freeNodeOffset;
        }
        setFreeNodeOffset(offset) {
            this.freeNodeOffset = offset;
            return utils_2.setNumberToFileBytes(this.storageData, 0, this.nodeOffsetBytes, offset);
        }
        async getDeletedNodeOffset() {
            return this.deletedNodeOffset;
        }
        setDeletedNodeOffset(offset) {
            this.deletedNodeOffset = offset;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            return utils_2.setNumberToFileBytes(this.storageData, nodeOffsetBytes, nodeOffsetBytes, offset);
        }
        async getRootNodeOffset() {
            return this.rootNodeOffset;
        }
        setRootNodeOffset(offset) {
            this.rootNodeOffset = offset;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            return utils_2.setNumberToFileBytes(this.storageData, nodeOffsetBytes * 2, nodeOffsetBytes, offset);
        }
    }
    exports.NodeManagerBinaryDisk = NodeManagerBinaryDisk;
});

}).call(this,require("buffer").Buffer)
},{"../../../RuntimeError":23,"../../../utils":39,"../../NodeManagerAsyncGeneric":26,"./File":27,"./NodeBinaryDisk":28,"./utils":30,"buffer":98,"fs":96}],30:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../../../RuntimeError"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /* tslint:disable:no-bitwise */
    const RuntimeError_1 = require("../../../RuntimeError");
    /**
     * @param source
     * @param offset At which offset in bytes to start reading a number
     * @param numberOfBytes How many bytes are used to store a number
     */
    async function getNumberFromFileBytes(source, offset, numberOfBytes) {
        const sourceBytes = await source.read(offset, numberOfBytes);
        switch (numberOfBytes) {
            case 4: {
                return (sourceBytes[0] << 24) + (sourceBytes[1] << 16) + (sourceBytes[2] << 8) + sourceBytes[3];
            }
            case 3: {
                return (sourceBytes[0] << 16) + (sourceBytes[1] << 8) + sourceBytes[2];
            }
            case 2: {
                return (sourceBytes[0] << 8) + sourceBytes[1];
            }
            case 1:
                return sourceBytes[0];
            default:
                throw new RuntimeError_1.RuntimeError("Unsupported number of nodes");
        }
    }
    exports.getNumberFromFileBytes = getNumberFromFileBytes;
    /**
     * @param source
     * @param offset At which offset in bytes to start writing a number
     * @param numberOfBytes How many bytes are used to store a number
     * @param newNumber Number that should be set
     */
    async function setNumberToFileBytes(source, offset, numberOfBytes, newNumber) {
        const uint8array = new Uint8Array(numberOfBytes);
        const view = new DataView(uint8array.buffer);
        switch (numberOfBytes) {
            case 4: {
                view.setUint32(0, newNumber, false);
                await source.write(offset, uint8array);
                return;
            }
            case 3: {
                view.setUint8(0, newNumber >> 16);
                view.setUint16(1, newNumber % (1 << 16), false);
                await source.write(offset, uint8array);
                return;
            }
            case 2: {
                view.setUint16(0, newNumber, false);
                await source.write(offset, uint8array);
                return;
            }
            case 1:
                uint8array.set([newNumber]);
                await source.write(offset, uint8array);
                return;
            default:
                throw new RuntimeError_1.RuntimeError("Unsupported number of nodes");
        }
    }
    exports.setNumberToFileBytes = setNumberToFileBytes;
});

},{"../../../RuntimeError":23}],31:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../../../utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const utils_1 = require("../../../utils");
    class NodeBinaryMemory {
        /**
         * @param offset
         * @param leftOffset
         * @param rightOffset
         * @param key
         * @param valueSize
         * @param source Binary data where contents of the node is located
         * @param sourceOffset Offset in binary data in bytes where node is located
         * @param nodeOffsetBytes
         * @param numberOfNodes
         * @param getNode
         */
        constructor(offset, leftOffset, rightOffset, key, valueSize, source, sourceOffset, nodeOffsetBytes, numberOfNodes, getNode) {
            this.offset = offset;
            this.leftOffset = leftOffset;
            this.rightOffset = rightOffset;
            this.key = key;
            this.valueSize = valueSize;
            this.source = source;
            this.sourceOffset = sourceOffset;
            this.nodeOffsetBytes = nodeOffsetBytes;
            this.numberOfNodes = numberOfNodes;
            this.getNode = getNode;
            this.leftCache = undefined;
            this.rightCache = undefined;
            this.isRed = source[sourceOffset] === 1;
        }
        /**
         * @param nodeOffsetBytes
         * @param numberOfNodes
         * @param source Binary data where contents of the node is located
         * @param sourceOffset Offset in binary data in bytes where node is located
         * @param offset
         * @param key
         * @param value
         * @param getNode
         */
        static create(nodeOffsetBytes, numberOfNodes, source, sourceOffset, offset, key, value, getNode) {
            const keySize = key.length;
            // Set `isRed` to `true`
            source.set([1], sourceOffset);
            // Set left child to `null`
            utils_1.setNumberToBytes(source, sourceOffset + 1, nodeOffsetBytes, numberOfNodes);
            // Set right child to `null`
            utils_1.setNumberToBytes(source, sourceOffset + 1 + nodeOffsetBytes, nodeOffsetBytes, numberOfNodes);
            // Set key
            source.set(key, sourceOffset + 1 + nodeOffsetBytes * 2);
            // Set value
            source.set(value, sourceOffset + 1 + nodeOffsetBytes * 2 + keySize);
            const instance = new NodeBinaryMemory(offset, numberOfNodes, numberOfNodes, key, value.length, source, sourceOffset, nodeOffsetBytes, numberOfNodes, getNode);
            instance.leftCache = null;
            instance.rightCache = null;
            return instance;
        }
        /**
         * @param nodeOffsetBytes
         * @param numberOfNodes
         * @param source Binary data where contents of the node is located
         * @param sourceOffset Offset in binary data in bytes where node is located
         * @param offset
         * @param keySize
         * @param valueSize
         * @param getNode
         */
        static read(nodeOffsetBytes, numberOfNodes, source, sourceOffset, offset, keySize, valueSize, getNode) {
            const baseOffset = sourceOffset + 1 + nodeOffsetBytes * 2;
            return new NodeBinaryMemory(offset, utils_1.getNumberFromBytes(source, sourceOffset + 1, nodeOffsetBytes), utils_1.getNumberFromBytes(source, sourceOffset + 1 + nodeOffsetBytes, nodeOffsetBytes), source.subarray(baseOffset, baseOffset + keySize), valueSize, source, sourceOffset, nodeOffsetBytes, numberOfNodes, getNode);
        }
        getIsRed() {
            return this.isRed;
        }
        setIsRed(isRed) {
            if (isRed !== this.isRed) {
                this.isRed = isRed;
                this.source.set([isRed ? 1 : 0], this.sourceOffset);
            }
        }
        getKey() {
            return this.key;
        }
        getLeft() {
            if (this.leftCache === undefined) {
                const offset = this.leftOffset;
                this.leftCache = offset === this.numberOfNodes ? null : this.getNode(offset);
            }
            return this.leftCache;
        }
        setLeft(node) {
            this.leftCache = node;
            const offset = node ? node.offset : this.numberOfNodes;
            this.leftOffset = offset;
            utils_1.setNumberToBytes(this.source, this.sourceOffset + 1, this.nodeOffsetBytes, offset);
        }
        getRight() {
            if (this.rightCache === undefined) {
                const offset = this.rightOffset;
                this.rightCache = offset === this.numberOfNodes ? null : this.getNode(offset);
            }
            return this.rightCache;
        }
        setRight(node) {
            this.rightCache = node;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            const offset = node ? node.offset : this.numberOfNodes;
            this.rightOffset = offset;
            utils_1.setNumberToBytes(this.source, this.sourceOffset + 1 + nodeOffsetBytes, nodeOffsetBytes, offset);
        }
        getValue() {
            const baseOffset = this.sourceOffset + 1 + this.nodeOffsetBytes * 2 + this.key.length;
            return this.source.subarray(baseOffset, baseOffset + this.valueSize);
        }
    }
    exports.NodeBinaryMemory = NodeBinaryMemory;
});

},{"../../../utils":39}],32:[function(require,module,exports){
(function (Buffer){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../../../RuntimeError", "../../../utils", "./NodeBinaryMemory"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const RuntimeError_1 = require("../../../RuntimeError");
    const utils_1 = require("../../../utils");
    const NodeBinaryMemory_1 = require("./NodeBinaryMemory");
    /**
     * Node manager implementation that can work with any data type supported in Node.js as a value
     */
    class NodeManagerBinaryMemory {
        constructor(uint8Array, numberOfNodes, nodeOffsetBytes, keySize, valueSize, singleNodeAllocationSize) {
            this.uint8Array = uint8Array;
            this.numberOfNodes = numberOfNodes;
            this.nodeOffsetBytes = nodeOffsetBytes;
            this.keySize = keySize;
            this.valueSize = valueSize;
            this.singleNodeAllocationSize = singleNodeAllocationSize;
            this.compare = utils_1.compareUint8Array;
            this.distance = utils_1.uint8ArraysDiff;
            this.rootCache = undefined;
            this.freeNodeOffset = utils_1.getNumberFromBytes(this.uint8Array, 0, this.nodeOffsetBytes);
            this.deletedNodeOffset = utils_1.getNumberFromBytes(this.uint8Array, nodeOffsetBytes, nodeOffsetBytes);
            this.rootNodeOffset = utils_1.getNumberFromBytes(this.uint8Array, nodeOffsetBytes * 2, nodeOffsetBytes);
        }
        /**
         * @param numberOfNodes Max number of nodes that are expected to be stored
         * @param keySize Size of the key in bytes
         * @param valueSize Size of the values associated with a key in bytes
         */
        static create(numberOfNodes, keySize, valueSize) {
            // offset starts from 0, but addresses with index of last possible node + 1 will be treated as `null` node for everyone to reference
            const nodeOffsetBytes = utils_1.maxNumberToBytes(numberOfNodes);
            // 1 byte for red/black flag and 2 * nodeOffsetBytes for left and right children
            const nodeMetadataSize = 1 + nodeOffsetBytes * 2;
            const singleNodeAllocationSize = nodeMetadataSize + keySize + valueSize;
            /**
             * * one offset for the first free offset for the next node to be inserted
             * * one offset for last deleted node that can be used to add another node
             * * one offset for root node offset
             */
            const commonMetadataSize = nodeOffsetBytes * 3;
            const allocationSize = commonMetadataSize + numberOfNodes * singleNodeAllocationSize;
            const buffer = Buffer.allocUnsafe(allocationSize);
            const uint8Array = new Uint8Array(buffer.buffer);
            const instance = new NodeManagerBinaryMemory(uint8Array, numberOfNodes, nodeOffsetBytes, keySize, valueSize, singleNodeAllocationSize);
            instance.setFreeNodeOffset(0);
            instance.setDeletedNodeOffset(numberOfNodes);
            instance.setRootNodeOffset(numberOfNodes);
            return instance;
        }
        getRoot() {
            if (this.rootCache === undefined) {
                const offset = this.getRootNodeOffset();
                this.rootCache = offset === this.numberOfNodes ? null : this.getNode(offset);
            }
            return this.rootCache;
        }
        setRoot(node) {
            this.rootCache = node;
            if (node === null) {
                this.setRootNodeOffset(this.numberOfNodes);
            }
            else {
                this.setRootNodeOffset(node.offset);
            }
        }
        addNode(key, value) {
            const offset = this.allocateOffsetForAddition();
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            return NodeBinaryMemory_1.NodeBinaryMemory.create(nodeOffsetBytes, this.numberOfNodes, this.uint8Array, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, offset, key, value, this.getNode.bind(this));
        }
        removeNode(node) {
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            const offset = node.offset;
            const lastDeletedOffset = this.getDeletedNodeOffset();
            // Store previous last deleted node in currently deleting node data
            utils_1.setNumberToBytes(this.uint8Array, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, nodeOffsetBytes, lastDeletedOffset);
            // Update last deleted node offset
            this.setDeletedNodeOffset(offset);
        }
        cleanup() {
            this.rootCache = undefined;
        }
        allocateOffsetForAddition() {
            const numberOfNodes = this.numberOfNodes;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const offset = this.getFreeNodeOffset();
            if (offset !== numberOfNodes) {
                this.setFreeNodeOffset(offset + 1);
                return offset;
            }
            else {
                const offset = this.getDeletedNodeOffset();
                if (offset === numberOfNodes) {
                    throw new RuntimeError_1.RuntimeError("No space left for new nodes");
                }
                // By convention deleted node stores offset of previous deleted node in its first bytes
                const previousOffset = utils_1.getNumberFromBytes(this.uint8Array, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, nodeOffsetBytes);
                this.setDeletedNodeOffset(previousOffset);
                return offset;
            }
        }
        getNode(offset) {
            const singleNodeAllocationSize = this.singleNodeAllocationSize;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            return NodeBinaryMemory_1.NodeBinaryMemory.read(nodeOffsetBytes, this.numberOfNodes, this.uint8Array, nodeOffsetBytes * 3 + singleNodeAllocationSize * offset, offset, this.keySize, this.valueSize, this.getNode.bind(this));
        }
        getFreeNodeOffset() {
            return this.freeNodeOffset;
        }
        setFreeNodeOffset(offset) {
            this.freeNodeOffset = offset;
            utils_1.setNumberToBytes(this.uint8Array, 0, this.nodeOffsetBytes, offset);
        }
        getDeletedNodeOffset() {
            return this.deletedNodeOffset;
        }
        setDeletedNodeOffset(offset) {
            this.deletedNodeOffset = offset;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            utils_1.setNumberToBytes(this.uint8Array, nodeOffsetBytes, nodeOffsetBytes, offset);
        }
        getRootNodeOffset() {
            return this.rootNodeOffset;
        }
        setRootNodeOffset(offset) {
            this.rootNodeOffset = offset;
            const nodeOffsetBytes = this.nodeOffsetBytes;
            utils_1.setNumberToBytes(this.uint8Array, nodeOffsetBytes * 2, nodeOffsetBytes, offset);
        }
    }
    exports.NodeManagerBinaryMemory = NodeManagerBinaryMemory;
});

}).call(this,require("buffer").Buffer)
},{"../../../RuntimeError":23,"../../../utils":39,"./NodeBinaryMemory":31,"buffer":98}],33:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class NodeJs {
        constructor(key, value) {
            this.key = key;
            this.value = value;
            this.isRed = true;
            this.left = null;
            this.right = null;
        }
        getIsRed() {
            return this.isRed;
        }
        setIsRed(isRed) {
            this.isRed = isRed;
        }
        getKey() {
            return this.key;
        }
        getLeft() {
            return this.left;
        }
        setLeft(node) {
            this.left = node;
        }
        getRight() {
            return this.right;
        }
        setRight(node) {
            this.right = node;
        }
        getValue() {
            return this.value;
        }
    }
    exports.NodeJs = NodeJs;
});

},{}],34:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./NodeJs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const NodeJs_1 = require("./NodeJs");
    /**
     * Node manager implementation that can work with any data type supported in Node.js as a value
     */
    class NodeManagerJs {
        constructor() {
            this.root = null;
        }
        getRoot() {
            return this.root;
        }
        setRoot(root) {
            this.root = root;
        }
        addNode(key, value) {
            return new NodeJs_1.NodeJs(key, value);
        }
        removeNode() {
            // Nothing is needed to remove a node
        }
        cleanup() {
            // No cleanup is needed
        }
    }
    exports.NodeManagerJs = NodeManagerJs;
});

},{"./NodeJs":33}],35:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./NodeManagerJs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const NodeManagerJs_1 = require("./NodeManagerJs");
    class NodeManagerJsNumber extends NodeManagerJs_1.NodeManagerJs {
        compare(aKey, bKey) {
            if (aKey === bKey) {
                return 0;
            }
            return aKey < bKey ? -1 : 1;
        }
        distance(aKey, bKey) {
            return Math.abs(aKey - bKey);
        }
    }
    exports.NodeManagerJsNumber = NodeManagerJsNumber;
});

},{"./NodeManagerJs":34}],36:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../../utils", "./NodeManagerJs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const utils_1 = require("../../utils");
    const NodeManagerJs_1 = require("./NodeManagerJs");
    const encoder = new TextEncoder();
    class NodeManagerJsString extends NodeManagerJs_1.NodeManagerJs {
        compare(aKey, bKey) {
            if (aKey === bKey) {
                return 0;
            }
            return aKey < bKey ? -1 : 1;
        }
        distance(aKey, bKey) {
            return utils_1.uint8ArraysDiff(encoder.encode(aKey), encoder.encode(bKey));
        }
    }
    exports.NodeManagerJsString = NodeManagerJsString;
});

},{"../../utils":39,"./NodeManagerJs":34}],37:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../../utils", "./NodeManagerJs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const utils_1 = require("../../utils");
    const NodeManagerJs_1 = require("./NodeManagerJs");
    class NodeManagerJsUint8Array extends NodeManagerJs_1.NodeManagerJs {
        constructor() {
            super(...arguments);
            this.compare = utils_1.compareUint8Array;
            this.distance = utils_1.uint8ArraysDiff;
        }
    }
    exports.NodeManagerJsUint8Array = NodeManagerJsUint8Array;
});

},{"../../utils":39,"./NodeManagerJs":34}],38:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./Tree", "./TreeAsync", "./implementations/js/NodeJs", "./implementations/js/NodeManagerJs", "./implementations/js/NodeManagerJsNumber", "./implementations/js/NodeManagerJsString", "./implementations/js/NodeManagerJsUint8Array", "./implementations/binary/disk/NodeBinaryDisk", "./implementations/binary/disk/NodeManagerBinaryDisk", "./implementations/binary/memory/NodeBinaryMemory", "./implementations/binary/memory/NodeManagerBinaryMemory"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Tree_1 = require("./Tree");
    exports.Tree = Tree_1.Tree;
    var TreeAsync_1 = require("./TreeAsync");
    exports.TreeAsync = TreeAsync_1.TreeAsync;
    var NodeJs_1 = require("./implementations/js/NodeJs");
    exports.NodeJs = NodeJs_1.NodeJs;
    var NodeManagerJs_1 = require("./implementations/js/NodeManagerJs");
    exports.NodeManagerJs = NodeManagerJs_1.NodeManagerJs;
    var NodeManagerJsNumber_1 = require("./implementations/js/NodeManagerJsNumber");
    exports.NodeManagerJsNumber = NodeManagerJsNumber_1.NodeManagerJsNumber;
    var NodeManagerJsString_1 = require("./implementations/js/NodeManagerJsString");
    exports.NodeManagerJsString = NodeManagerJsString_1.NodeManagerJsString;
    var NodeManagerJsUint8Array_1 = require("./implementations/js/NodeManagerJsUint8Array");
    exports.NodeManagerJsUint8Array = NodeManagerJsUint8Array_1.NodeManagerJsUint8Array;
    var NodeBinaryDisk_1 = require("./implementations/binary/disk/NodeBinaryDisk");
    exports.NodeBinaryDisk = NodeBinaryDisk_1.NodeBinaryDisk;
    var NodeManagerBinaryDisk_1 = require("./implementations/binary/disk/NodeManagerBinaryDisk");
    exports.NodeManagerBinaryDisk = NodeManagerBinaryDisk_1.NodeManagerBinaryDisk;
    var NodeBinaryMemory_1 = require("./implementations/binary/memory/NodeBinaryMemory");
    exports.NodeBinaryMemory = NodeBinaryMemory_1.NodeBinaryMemory;
    var NodeManagerBinaryMemory_1 = require("./implementations/binary/memory/NodeManagerBinaryMemory");
    exports.NodeManagerBinaryMemory = NodeManagerBinaryMemory_1.NodeManagerBinaryMemory;
});

},{"./Tree":24,"./TreeAsync":25,"./implementations/binary/disk/NodeBinaryDisk":28,"./implementations/binary/disk/NodeManagerBinaryDisk":29,"./implementations/binary/memory/NodeBinaryMemory":31,"./implementations/binary/memory/NodeManagerBinaryMemory":32,"./implementations/js/NodeJs":33,"./implementations/js/NodeManagerJs":34,"./implementations/js/NodeManagerJsNumber":35,"./implementations/js/NodeManagerJsString":36,"./implementations/js/NodeManagerJsUint8Array":37}],39:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./RuntimeError"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /* tslint:disable:no-bitwise */
    const RuntimeError_1 = require("./RuntimeError");
    function compareUint8Array(aKey, bKey) {
        const length = aKey.length;
        for (let i = 0; i < length; ++i) {
            const diff = aKey[i] - bKey[i];
            if (diff < 0) {
                return -1;
            }
            else if (diff > 0) {
                return 1;
            }
        }
        return 0;
    }
    exports.compareUint8Array = compareUint8Array;
    function uint8ArrayToBigInt(arr) {
        let result = 0n;
        const length = arr.length;
        for (let i = length - 1, multiplier = 2n ** (BigInt(i) * 8n); i >= 0n; --i, multiplier /= 256n) {
            result += BigInt(arr[i]) * multiplier;
        }
        return result;
    }
    /**
     * If one key is longer than other, extra length is not checked
     *
     * @param aKey
     * @param bKey
     */
    function uint8ArraysDiff(aKey, bKey) {
        const aBigInt = uint8ArrayToBigInt(aKey);
        const bBigInt = uint8ArrayToBigInt(bKey);
        const diff = aBigInt - bBigInt;
        // Math.abs() doesn't work with BigInt
        return diff > 0 ? diff : -diff;
    }
    exports.uint8ArraysDiff = uint8ArraysDiff;
    function maxNumberToBytes(maxNumber) {
        if (maxNumber < 2 ** 8) {
            return 1;
        }
        if (maxNumber < 2 ** 16) {
            return 2;
        }
        if (maxNumber < 2 ** 24) {
            return 3;
        }
        if (maxNumber < 2 ** 32) {
            return 4;
        }
        throw new RuntimeError_1.RuntimeError("Can't store that many nodes");
    }
    exports.maxNumberToBytes = maxNumberToBytes;
    /**
     * @param source
     * @param offset At which offset in bytes to start reading a number
     * @param numberOfBytes How many bytes are used to store a number
     */
    function getNumberFromBytes(source, offset, numberOfBytes) {
        switch (numberOfBytes) {
            case 4: {
                return (source[offset] << 24) + (source[offset + 1] << 16) + (source[offset + 2] << 8) + source[offset + 3];
            }
            case 3: {
                return (source[offset] << 16) + (source[offset + 1] << 8) + source[offset + 2];
            }
            case 2: {
                return (source[offset] << 8) + source[offset + 1];
            }
            case 1:
                return source[offset];
            default:
                throw new RuntimeError_1.RuntimeError("Unsupported number of nodes");
        }
    }
    exports.getNumberFromBytes = getNumberFromBytes;
    /**
     * @param source
     * @param offset At which offset in bytes to start writing a number
     * @param numberOfBytes How many bytes are used to store a number
     * @param newNumber Number that should be set
     */
    function setNumberToBytes(source, offset, numberOfBytes, newNumber) {
        switch (numberOfBytes) {
            case 4: {
                const view = new DataView(source.buffer, source.byteOffset + offset, numberOfBytes);
                view.setUint32(0, newNumber, false);
                return;
            }
            case 3: {
                const view = new DataView(source.buffer, source.byteOffset + offset, numberOfBytes);
                view.setUint8(0, newNumber >> 16);
                view.setUint16(1, newNumber % (1 << 16), false);
                return;
            }
            case 2: {
                const view = new DataView(source.buffer, source.byteOffset + offset, numberOfBytes);
                view.setUint16(0, newNumber, false);
                return;
            }
            case 1:
                source.set([newNumber], offset);
                return;
            default:
                throw new RuntimeError_1.RuntimeError("Unsupported number of nodes");
        }
    }
    exports.setNumberToBytes = setNumberToBytes;
});

},{"./RuntimeError":23}],40:[function(require,module,exports){
(function (__dirname){
    const currentScript = globalThis.document && globalThis.document.currentScript;
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "fs"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const fs_1 = require("fs");
    class ReedSolomonErasure {
        constructor(exports) {
            this.exports = exports;
            this.memoryCache = null;
        }
        /**
         * Automagical method that will try to detect environment (Node.js or browser) and load *.wasm file from current directory
         */
        static async fromCurrentDirectory() {
            if (currentScript) {
                const pathToCurrentScript = currentScript.src.split('/').slice(0, -1).join('/');
                return ReedSolomonErasure.fromResponse(await fetch(`${pathToCurrentScript}/reed_solomon_erasure_bg.wasm`));
            }
            else {
                return ReedSolomonErasure.fromBytes(fs_1.readFileSync(`${__dirname}/reed_solomon_erasure_bg.wasm`));
            }
        }
        /**
         * For asynchronous instantiation, primarily in Browser environment, expects you to load WASM file with `fetch()`
         */
        static async fromResponse(source) {
            // @ts-ignore WebAssembly.instantiateStreaming is not known by TypeScript yet
            const instance = await WebAssembly.instantiateStreaming(source);
            return new ReedSolomonErasure(instance.exports);
        }
        /**
         * For synchronous instantiation, primarily in Node.js environment
         */
        static fromBytes(bytes) {
            const module = new WebAssembly.Module(bytes);
            const instance = new WebAssembly.Instance(module);
            return new ReedSolomonErasure(instance.exports);
        }
        /**
         * Takes a contiguous array of bytes that contain space for `data_shards + parity_shards` shards with `data_shards` shards containing data and fills
         * additional `parity_shards` with parity information that can be later used to reconstruct data in case of corruption
         *
         * @param shards
         * @param dataShards
         * @param parityShards
         *
         * @returns One of `RESULT_*` constants; if `RESULT_OK` then parity shards were updated in `shards` in-place
         */
        encode(shards, dataShards, parityShards) {
            const exports = this.exports;
            const shardsLength = shards.length;
            const shardsPointer = exports.__wbindgen_malloc(shardsLength);
            this.getUint8Memory().set(shards, shardsPointer);
            const shardSize = shardsLength / (dataShards + parityShards);
            const result = exports.encode(shardsPointer, shardsLength, dataShards, parityShards);
            if (result === ReedSolomonErasure.RESULT_OK) {
                shards.set(this.getUint8Memory().subarray(shardsPointer + shardSize * dataShards, shardsPointer + shardsLength), shardSize * dataShards);
            }
            exports.__wbindgen_free(shardsPointer, shardsLength);
            return result;
        }
        /**
         * Takes a contiguous array of bytes that contain `data_shards + parity_shards` shards and tries to reconstruct data shards if they are broken and whenever
         * possible using information from `shards_available` (contains `data_shards + parity_shards` boolean values, each of which is either `true` if shard is not
         * corrupted or `false` if it is)
         *
         * @param shards
         * @param dataShards
         * @param parityShards
         * @param shardsAvailable
         *
         * @returns One of `RESULT_*` constants; if `RESULT_OK` then data shards were reconstructed in `shards` in-place
         */
        reconstruct(shards, dataShards, parityShards, shardsAvailable) {
            const exports = this.exports;
            const shardsLength = shards.length;
            const shardsPointer = exports.__wbindgen_malloc(shardsLength);
            this.getUint8Memory().set(shards, shardsPointer);
            const shardsAvailableLength = shardsAvailable.length;
            const shardsAvailablePointer = exports.__wbindgen_malloc(shardsAvailableLength);
            this.getUint8Memory().set(shardsAvailable.map((value) => value ? 1 : 0), shardsAvailablePointer);
            const shardSize = shardsLength / (dataShards + parityShards);
            const result = exports.reconstruct(shardsPointer, shardsLength, dataShards, parityShards, shardsAvailablePointer, shardsAvailableLength);
            if (result === ReedSolomonErasure.RESULT_OK) {
                shards.set(this.getUint8Memory().subarray(shardsPointer, shardsPointer + shardSize * dataShards));
            }
            exports.__wbindgen_free(shardsPointer, shardsLength);
            exports.__wbindgen_free(shardsAvailablePointer, shardsAvailableLength);
            return result;
        }
        getUint8Memory() {
            let cachegetUint8Memory = this.memoryCache;
            if (cachegetUint8Memory === null ||
                cachegetUint8Memory.buffer !== this.exports.memory.buffer) {
                cachegetUint8Memory = new Uint8Array(this.exports.memory.buffer);
                this.memoryCache = cachegetUint8Memory;
            }
            return cachegetUint8Memory;
        }
    }
    ReedSolomonErasure.RESULT_OK = 0;
    ReedSolomonErasure.RESULT_ERROR_TOO_FEW_SHARDS = 1;
    ReedSolomonErasure.RESULT_ERROR_TOO_MANY_SHARDS = 2;
    ReedSolomonErasure.RESULT_ERROR_TOO_FEW_DATA_SHARDS = 3;
    ReedSolomonErasure.RESULT_ERROR_TOO_MANY_DATA_SHARDS = 4;
    ReedSolomonErasure.RESULT_ERROR_TOO_FEW_PARITY_SHARDS = 5;
    ReedSolomonErasure.RESULT_ERROR_TOO_MANY_PARITY_SHARDS = 6;
    ReedSolomonErasure.RESULT_ERROR_TOO_FEW_BUFFER_SHARDS = 7;
    ReedSolomonErasure.RESULT_ERROR_TOO_MANY_BUFFER_SHARDS = 8;
    ReedSolomonErasure.RESULT_ERROR_INCORRECT_SHARD_SIZE = 9;
    ReedSolomonErasure.RESULT_ERROR_TOO_FEW_SHARDS_PRESENT = 10;
    ReedSolomonErasure.RESULT_ERROR_EMPTY_SHARD = 11;
    ReedSolomonErasure.RESULT_ERROR_INVALID_SHARD_FLAGS = 12;
    ReedSolomonErasure.RESULT_ERROR_INVALID_INDEX = 13;
    exports.ReedSolomonErasure = ReedSolomonErasure;
});


}).call(this,"/node_modules/@subspace/reed-solomon-erasure.wasm/dist")
},{"fs":96}],41:[function(require,module,exports){
function AbstractChainedBatch (db) {
  if (typeof db !== 'object' || db === null) {
    throw new TypeError('First argument must be an abstract-leveldown compliant store')
  }

  this.db = db
  this._operations = []
  this._written = false
}

AbstractChainedBatch.prototype._checkWritten = function () {
  if (this._written) {
    throw new Error('write() already called on this batch')
  }
}

AbstractChainedBatch.prototype.put = function (key, value) {
  this._checkWritten()

  var err = this.db._checkKey(key) || this.db._checkValue(value)
  if (err) throw err

  key = this.db._serializeKey(key)
  value = this.db._serializeValue(value)

  this._put(key, value)

  return this
}

AbstractChainedBatch.prototype._put = function (key, value) {
  this._operations.push({ type: 'put', key: key, value: value })
}

AbstractChainedBatch.prototype.del = function (key) {
  this._checkWritten()

  var err = this.db._checkKey(key)
  if (err) throw err

  key = this.db._serializeKey(key)
  this._del(key)

  return this
}

AbstractChainedBatch.prototype._del = function (key) {
  this._operations.push({ type: 'del', key: key })
}

AbstractChainedBatch.prototype.clear = function () {
  this._checkWritten()
  this._clear()

  return this
}

AbstractChainedBatch.prototype._clear = function () {
  this._operations = []
}

AbstractChainedBatch.prototype.write = function (options, callback) {
  this._checkWritten()

  if (typeof options === 'function') { callback = options }
  if (typeof callback !== 'function') {
    throw new Error('write() requires a callback argument')
  }
  if (typeof options !== 'object' || options === null) {
    options = {}
  }

  this._written = true
  this._write(options, callback)
}

AbstractChainedBatch.prototype._write = function (options, callback) {
  this.db._batch(this._operations, options, callback)
}

module.exports = AbstractChainedBatch

},{}],42:[function(require,module,exports){
(function (process){
function AbstractIterator (db) {
  if (typeof db !== 'object' || db === null) {
    throw new TypeError('First argument must be an abstract-leveldown compliant store')
  }

  this.db = db
  this._ended = false
  this._nexting = false
}

AbstractIterator.prototype.next = function (callback) {
  var self = this

  if (typeof callback !== 'function') {
    throw new Error('next() requires a callback argument')
  }

  if (self._ended) {
    process.nextTick(callback, new Error('cannot call next() after end()'))
    return self
  }

  if (self._nexting) {
    process.nextTick(callback, new Error('cannot call next() before previous next() has completed'))
    return self
  }

  self._nexting = true
  self._next(function () {
    self._nexting = false
    callback.apply(null, arguments)
  })

  return self
}

AbstractIterator.prototype._next = function (callback) {
  process.nextTick(callback)
}

AbstractIterator.prototype.seek = function (target) {
  if (this._ended) {
    throw new Error('cannot call seek() after end()')
  }
  if (this._nexting) {
    throw new Error('cannot call seek() before next() has completed')
  }

  target = this.db._serializeKey(target)
  this._seek(target)
}

AbstractIterator.prototype._seek = function (target) {}

AbstractIterator.prototype.end = function (callback) {
  if (typeof callback !== 'function') {
    throw new Error('end() requires a callback argument')
  }

  if (this._ended) {
    return process.nextTick(callback, new Error('end() already called on iterator'))
  }

  this._ended = true
  this._end(callback)
}

AbstractIterator.prototype._end = function (callback) {
  process.nextTick(callback)
}

module.exports = AbstractIterator

}).call(this,require('_process'))
},{"_process":565}],43:[function(require,module,exports){
(function (Buffer,process){
var xtend = require('xtend')
var AbstractIterator = require('./abstract-iterator')
var AbstractChainedBatch = require('./abstract-chained-batch')
var hasOwnProperty = Object.prototype.hasOwnProperty
var rangeOptions = 'start end gt gte lt lte'.split(' ')

function AbstractLevelDOWN () {
  this.status = 'new'
}

AbstractLevelDOWN.prototype.open = function (options, callback) {
  var self = this
  var oldStatus = this.status

  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('open() requires a callback argument')
  }

  if (typeof options !== 'object' || options === null) options = {}

  options.createIfMissing = options.createIfMissing !== false
  options.errorIfExists = !!options.errorIfExists

  this.status = 'opening'
  this._open(options, function (err) {
    if (err) {
      self.status = oldStatus
      return callback(err)
    }
    self.status = 'open'
    callback()
  })
}

AbstractLevelDOWN.prototype._open = function (options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.close = function (callback) {
  var self = this
  var oldStatus = this.status

  if (typeof callback !== 'function') {
    throw new Error('close() requires a callback argument')
  }

  this.status = 'closing'
  this._close(function (err) {
    if (err) {
      self.status = oldStatus
      return callback(err)
    }
    self.status = 'closed'
    callback()
  })
}

AbstractLevelDOWN.prototype._close = function (callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.get = function (key, options, callback) {
  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('get() requires a callback argument')
  }

  var err = this._checkKey(key)
  if (err) return process.nextTick(callback, err)

  key = this._serializeKey(key)

  if (typeof options !== 'object' || options === null) options = {}

  options.asBuffer = options.asBuffer !== false

  this._get(key, options, callback)
}

AbstractLevelDOWN.prototype._get = function (key, options, callback) {
  process.nextTick(function () { callback(new Error('NotFound')) })
}

AbstractLevelDOWN.prototype.put = function (key, value, options, callback) {
  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('put() requires a callback argument')
  }

  var err = this._checkKey(key) || this._checkValue(value)
  if (err) return process.nextTick(callback, err)

  key = this._serializeKey(key)
  value = this._serializeValue(value)

  if (typeof options !== 'object' || options === null) options = {}

  this._put(key, value, options, callback)
}

AbstractLevelDOWN.prototype._put = function (key, value, options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.del = function (key, options, callback) {
  if (typeof options === 'function') callback = options

  if (typeof callback !== 'function') {
    throw new Error('del() requires a callback argument')
  }

  var err = this._checkKey(key)
  if (err) return process.nextTick(callback, err)

  key = this._serializeKey(key)

  if (typeof options !== 'object' || options === null) options = {}

  this._del(key, options, callback)
}

AbstractLevelDOWN.prototype._del = function (key, options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype.batch = function (array, options, callback) {
  if (!arguments.length) return this._chainedBatch()

  if (typeof options === 'function') callback = options

  if (typeof array === 'function') callback = array

  if (typeof callback !== 'function') {
    throw new Error('batch(array) requires a callback argument')
  }

  if (!Array.isArray(array)) {
    return process.nextTick(callback, new Error('batch(array) requires an array argument'))
  }

  if (array.length === 0) {
    return process.nextTick(callback)
  }

  if (typeof options !== 'object' || options === null) options = {}

  var serialized = new Array(array.length)

  for (var i = 0; i < array.length; i++) {
    if (typeof array[i] !== 'object' || array[i] === null) {
      return process.nextTick(callback, new Error('batch(array) element must be an object and not `null`'))
    }

    var e = xtend(array[i])

    if (e.type !== 'put' && e.type !== 'del') {
      return process.nextTick(callback, new Error("`type` must be 'put' or 'del'"))
    }

    var err = this._checkKey(e.key)
    if (err) return process.nextTick(callback, err)

    e.key = this._serializeKey(e.key)

    if (e.type === 'put') {
      var valueErr = this._checkValue(e.value)
      if (valueErr) return process.nextTick(callback, valueErr)

      e.value = this._serializeValue(e.value)
    }

    serialized[i] = e
  }

  this._batch(serialized, options, callback)
}

AbstractLevelDOWN.prototype._batch = function (array, options, callback) {
  process.nextTick(callback)
}

AbstractLevelDOWN.prototype._setupIteratorOptions = function (options) {
  options = cleanRangeOptions(this, options)

  options.reverse = !!options.reverse
  options.keys = options.keys !== false
  options.values = options.values !== false
  options.limit = 'limit' in options ? options.limit : -1
  options.keyAsBuffer = options.keyAsBuffer !== false
  options.valueAsBuffer = options.valueAsBuffer !== false

  return options
}

function cleanRangeOptions (db, options) {
  var result = {}

  for (var k in options) {
    if (!hasOwnProperty.call(options, k)) continue

    var opt = options[k]

    if (isRangeOption(k)) {
      // Note that we don't reject nullish and empty options here. While
      // those types are invalid as keys, they are valid as range options.
      opt = db._serializeKey(opt)
    }

    result[k] = opt
  }

  return result
}

function isRangeOption (k) {
  return rangeOptions.indexOf(k) !== -1
}

AbstractLevelDOWN.prototype.iterator = function (options) {
  if (typeof options !== 'object' || options === null) options = {}
  options = this._setupIteratorOptions(options)
  return this._iterator(options)
}

AbstractLevelDOWN.prototype._iterator = function (options) {
  return new AbstractIterator(this)
}

AbstractLevelDOWN.prototype._chainedBatch = function () {
  return new AbstractChainedBatch(this)
}

AbstractLevelDOWN.prototype._serializeKey = function (key) {
  return key
}

AbstractLevelDOWN.prototype._serializeValue = function (value) {
  return value
}

AbstractLevelDOWN.prototype._checkKey = function (key) {
  if (key === null || key === undefined) {
    return new Error('key cannot be `null` or `undefined`')
  } else if (Buffer.isBuffer(key) && key.length === 0) {
    return new Error('key cannot be an empty Buffer')
  } else if (key === '') {
    return new Error('key cannot be an empty String')
  } else if (Array.isArray(key) && key.length === 0) {
    return new Error('key cannot be an empty Array')
  }
}

AbstractLevelDOWN.prototype._checkValue = function (value) {
  if (value === null || value === undefined) {
    return new Error('value cannot be `null` or `undefined`')
  }
}

module.exports = AbstractLevelDOWN

}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))
},{"../is-buffer/index.js":511,"./abstract-chained-batch":41,"./abstract-iterator":42,"_process":565,"xtend":609}],44:[function(require,module,exports){
exports.AbstractLevelDOWN = require('./abstract-leveldown')
exports.AbstractIterator = require('./abstract-iterator')
exports.AbstractChainedBatch = require('./abstract-chained-batch')

},{"./abstract-chained-batch":41,"./abstract-iterator":42,"./abstract-leveldown":43}],45:[function(require,module,exports){
// Generated by LiveScript 1.5.0
/**
 * @package ArrayMap and ArraySet
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var key_aliases, key_strings, key_usages;
  key_aliases = new WeakMap;
  key_strings = new Map;
  key_usages = new Map;
  /**
   * @param {!ArrayBufferView} key
   *
   * @return {!ArrayBufferView}
   */
  function get_unique_key(key){
    var real_key, key_string;
    real_key = key_aliases.get(key);
    /**
     * Real key is an array with unique contents that appeared first.
     * If all of the usages were eliminated, some WeakMap can still point to old real key, which is not a real key anymore, which leads to inconsistencies.
     * In order to resolve this we have an additional check that confirms if real key is still believed to be a real key.
     */
    if (real_key && key_usages.has(real_key)) {
      return real_key;
    } else {
      key_string = key.join(',');
      if (key_strings.has(key_string)) {
        real_key = key_strings.get(key_string);
        key_aliases.set(key, real_key);
        return real_key;
      } else {
        return key;
      }
    }
  }
  /**
   * @param {!ArrayBufferView} key
   */
  function increase_key_usage(key){
    var key_string, current_value;
    key_string = key.join(',');
    current_value = key_usages.get(key);
    if (!current_value) {
      key_aliases.set(key, key);
      key_strings.set(key_string, key);
      key_usages.set(key, 1);
    } else {
      ++current_value;
      key_usages.set(key, current_value);
    }
  }
  /**
   * @param {!ArrayBufferView} key
   */
  function decrease_key_usage(key){
    var key_string, current_value;
    key_string = key.join(',');
    current_value = key_usages.get(key);
    --current_value;
    if (!current_value) {
      key_strings['delete'](key_string);
      key_usages['delete'](key);
    } else {
      key_usages.set(key, current_value);
    }
  }
  /**
   * This is a Map with very interesting property: different ArrayBufferViews with the same contents will be treated as the same ArrayBufferView
   *
   * Implementation keeps weak references to make the whole thing fast and efficient
   */
  function ArrayMap(array){
    var x$, map, i$, len$, ref$, key, value;
    x$ = map = new Map;
    x$.get = function(key){
      key = get_unique_key(key);
      return Map.prototype.get.call(this, key);
    };
    x$.has = function(key){
      key = get_unique_key(key);
      return Map.prototype.has.call(this, key);
    };
    x$.set = function(key, value){
      key = get_unique_key(key);
      if (!Map.prototype.has.call(this, key)) {
        increase_key_usage(key);
      }
      return Map.prototype.set.call(this, key, value);
    };
    x$['delete'] = function(key){
      key = get_unique_key(key);
      if (Map.prototype.has.call(this, key)) {
        decrease_key_usage(key);
      }
      return Map.prototype['delete'].call(this, key);
    };
    x$.clear = function(){
      var this$ = this;
      this.forEach(function(arg$, key){
        this$['delete'](key);
      });
    };
    if (array) {
      for (i$ = 0, len$ = array.length; i$ < len$; ++i$) {
        ref$ = array[i$], key = ref$[0], value = ref$[1];
        map.set(key, value);
      }
    }
    return map;
  }
  /**
   * This is a Set with very interesting property: different ArrayBufferViews with the same contents will be treated as the same ArrayBufferView
   *
   * Implementation keeps weak references to make the whole thing fast and efficient
   */
  function ArraySet(array){
    var x$, set, i$, len$, item;
    x$ = set = new Set;
    x$.has = function(key){
      key = get_unique_key(key);
      return Set.prototype.has.call(this, key);
    };
    x$.add = function(key){
      key = get_unique_key(key);
      if (!Set.prototype.has.call(this, key)) {
        increase_key_usage(key);
      }
      return Set.prototype.add.call(this, key);
    };
    x$['delete'] = function(key){
      key = get_unique_key(key);
      if (Set.prototype.has.call(this, key)) {
        decrease_key_usage(key);
      }
      return Set.prototype['delete'].call(this, key);
    };
    x$.clear = function(){
      var this$ = this;
      this.forEach(function(arg$, key){
        this$['delete'](key);
      });
    };
    if (array) {
      for (i$ = 0, len$ = array.length; i$ < len$; ++i$) {
        item = array[i$];
        set.add(item);
      }
    }
    return set;
  }
  function Wrapper(){
    return {
      'ArrayMap': ArrayMap,
      'ArraySet': ArraySet
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper();
  } else {
    this['array_map_set'] = Wrapper();
  }
}).call(this);

},{}],46:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":47,"./asn1/base":49,"./asn1/constants":53,"./asn1/decoders":55,"./asn1/encoders":58,"bn.js":66}],47:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext(
      '(function ' + this.name + '(entity) {\n' +
      '  this._initNamed(entity);\n' +
      '})'
    );
  } catch (e) {
    named = function (entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":46,"inherits":510,"vm":608}],48:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":49,"buffer":98,"inherits":510}],49:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":48,"./node":50,"./reporter":51}],50:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var DecoderBuffer = require('../base').DecoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  var result = state['default'];
  var present = true;

  var prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input, options);
    else
      result = this._decodeChoice(input, options);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
          ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
        ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};

},{"../base":49,"minimalistic-assert":550}],51:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  var state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":510}],52:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":53}],53:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":52}],54:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
                                                    options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":46,"inherits":510}],55:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":54,"./pem":56}],56:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);

  var label = options.label.toUpperCase();

  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":54,"buffer":98,"inherits":510}],57:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":46,"buffer":98,"inherits":510}],58:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":57,"./pem":59}],59:[function(require,module,exports){
var inherits = require('inherits');

var DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
};
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);

  var p = buf.toString('base64');
  var out = [ '-----BEGIN ' + options.label + '-----' ];
  for (var i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":57,"inherits":510}],60:[function(require,module,exports){
(function (global){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":552,"util/":63}],61:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],62:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],63:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":62,"_process":565,"inherits":61}],64:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],65:[function(require,module,exports){
(function (process,Buffer,__dirname){

var Module = (
function(Module) {
  Module = Module || {};

var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}Module["arguments"]=[];Module["thisProgram"]="./this.program";Module["quit"]=(function(status,toThrow){throw toThrow});Module["preRun"]=[];Module["postRun"]=[];var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function"&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}else{return scriptDirectory+path}}if(ENVIRONMENT_IS_NODE){scriptDirectory=__dirname+"/";var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=require("fs");if(!nodePath)nodePath=require("path");filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}Module["arguments"]=process["argv"].slice(2);process["on"]("uncaughtException",(function(ex){if(!(ex instanceof ExitStatus)){throw ex}}));process["on"]("unhandledRejection",abort);Module["quit"]=(function(status){process["exit"](status)});Module["inspect"]=(function(){return"[Emscripten Module object]"})}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){Module["read"]=function shell_read(f){var data=tryParseAsDataURI(f);if(data){return intArrayToString(data)}return read(f)}}Module["readBinary"]=function readBinary(f){var data;data=tryParseAsDataURI(f);if(data){return data}if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){Module["arguments"]=scriptArgs}else if(typeof arguments!="undefined"){Module["arguments"]=arguments}if(typeof quit==="function"){Module["quit"]=(function(status){quit(status)})}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(document.currentScript){scriptDirectory=document.currentScript.src}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1)}else{scriptDirectory=""}Module["read"]=function shell_read(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText}catch(err){var data=tryParseAsDataURI(url);if(data){return intArrayToString(data)}throw err}};if(ENVIRONMENT_IS_WORKER){Module["readBinary"]=function readBinary(url){try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}}}Module["readAsync"]=function readAsync(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror()};xhr.onerror=onerror;xhr.send(null)};Module["setWindowTitle"]=(function(title){document.title=title})}else{}var out=Module["print"]||(typeof console!=="undefined"?console.log.bind(console):typeof print!=="undefined"?print:null);var err=Module["printErr"]||(typeof printErr!=="undefined"?printErr:typeof console!=="undefined"&&console.warn.bind(console)||out);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;var STACK_ALIGN=16;function dynamicAlloc(size){var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=ret+size+15&-16;if(end<=_emscripten_get_heap_size()){HEAP32[DYNAMICTOP_PTR>>2]=end}else{return 0}return ret}function getNativeTypeSize(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return 4}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0,"getNativeTypeSize invalid bits "+bits+", type "+type);return bits/8}else{return 0}}}}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}var asm2wasmImports={"f64-rem":(function(x,y){return x%y}),"debugger":(function(){debugger})};var jsCallStartIndex=1;var functionPointers=new Array(0);var funcWrappers={};function dynCall(sig,ptr,args){if(args&&args.length){return Module["dynCall_"+sig].apply(null,[ptr].concat(args))}else{return Module["dynCall_"+sig].call(null,ptr)}}var tempRet0=0;var setTempRet0=(function(value){tempRet0=value});var getTempRet0=(function(){return tempRet0});var GLOBAL_BASE=1024;var ABORT=false;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}var JSfuncs={"stackSave":(function(){stackSave()}),"stackRestore":(function(){stackRestore()}),"arrayToC":(function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}),"stringToC":(function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret})};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};function ccall(ident,returnType,argTypes,args,opts){function convertReturnValue(ret){if(returnType==="string")return Pointer_stringify(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble- +(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}var ALLOC_NONE=3;function Pointer_stringify(ptr,length){if(length===0||!ptr)return"";var hasUtf=0;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];hasUtf|=t;if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(hasUtf<128){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}return UTF8ToString(ptr)}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx){var endPtr=idx;while(u8Array[endPtr])++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str="";while(1){var u0=u8Array[idx++];if(!u0)return str;if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}}function UTF8ToString(ptr){return UTF8ArrayToString(HEAPU8,ptr)}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127){++len}else if(u<=2047){len+=2}else if(u<=65535){len+=3}else if(u<=2097151){len+=4}else if(u<=67108863){len+=5}else{len+=6}}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function demangle(func){return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,(function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"}))}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBuffer(buf){Module["buffer"]=buffer=buf}function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STATIC_BASE=1024,STACK_BASE=827408,DYNAMIC_BASE=6070288,DYNAMICTOP_PTR=827152;function abortOnCannotGrowMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+TOTAL_MEMORY+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}var TOTAL_STACK=5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(TOTAL_MEMORY<TOTAL_STACK)err("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");if(Module["buffer"]){buffer=Module["buffer"]}else{if(typeof WebAssembly==="object"&&typeof WebAssembly.Memory==="function"){Module["wasmMemory"]=new WebAssembly.Memory({"initial":TOTAL_MEMORY/WASM_PAGE_SIZE,"maximum":TOTAL_MEMORY/WASM_PAGE_SIZE});buffer=Module["wasmMemory"].buffer}else{buffer=new ArrayBuffer(TOTAL_MEMORY)}Module["buffer"]=buffer}updateGlobalBufferViews();HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function exitRuntime(){callRuntimeCallbacks(__ATEXIT__);runtimeExited=true}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABhgMsYAJ/fwBgA39/fwBgAX8Bf2ADf39/AX9gBH9/f38AYAV/f39/fwBgBH9/f38Bf2ACf38Bf2ABfwBgBX9/f39/AX9gCH9/f39/f39/AX9gBn9/f39/fwF/YAAAYAZ/f39/f38AYAV/f39/fAF/YAZ/f39/f3wBf2AHf39/f39/fwF/YAV/f39/fgF/YAV/f35/fwBgAAF/YA1/f39/f39/f39/f39/AGAHf39/f39/fwBgCH9/f39/f39/AGADf398AGADf39/AXxgBX9/f39/AXxgBH9/f34BfmAGf39/f39/AXxgAn9/AX5gAnx/AXxgAnx8AXxgA35/fwF/YAJ+fwF/YAZ/fH9/f38Bf2ADf39+AGAEf39/fwF+YAp/f39/f39/f39/AX9gDH9/f39/f39/f39/fwF/YAN/f38BfWALf39/f39/f39/f38Bf2AKf39/f39/f39/fwBgD39/f39/f39/f39/f39/fwBgB39/f39/f3wBf2AJf39/f39/f39/AX8Cmgw/A2VudgVhYm9ydAAIA2VudhdhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeQATA2VudhlfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uAAIDZW52DF9fX2N4YV90aHJvdwABA2VudhlfX19jeGFfdW5jYXVnaHRfZXhjZXB0aW9uABMDZW52B19fX2xvY2sACANlbnYLX19fbWFwX2ZpbGUABwNlbnYLX19fc2V0RXJyTm8ACANlbnYNX19fc3lzY2FsbDE0MAAHA2Vudg1fX19zeXNjYWxsMTQ1AAcDZW52DV9fX3N5c2NhbGwxNDYABwNlbnYNX19fc3lzY2FsbDIyMQAHA2VudgtfX19zeXNjYWxsMwAHA2VudgtfX19zeXNjYWxsNQAHA2VudgxfX19zeXNjYWxsNTQABwNlbnYLX19fc3lzY2FsbDYABwNlbnYMX19fc3lzY2FsbDkxAAcDZW52CV9fX3VubG9jawAIA2VudhZfX2VtYmluZF9yZWdpc3Rlcl9ib29sAAUDZW52F19fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzABQDZW52Jl9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX2Z1bmN0aW9uABUDZW52Jl9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX3Byb3BlcnR5ABYDZW52IF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uABYDZW52Gl9fZW1iaW5kX3JlZ2lzdGVyX2NvbnN0YW50ABcDZW52F19fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsAAADZW52F19fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0AAEDZW52Gl9fZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uAA0DZW52GV9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIABQNlbnYdX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcAAQNlbnYcX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZwAAA2Vudh1fX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwABA2VudhZfX2VtYmluZF9yZWdpc3Rlcl92b2lkAAADZW52Cl9fZW12YWxfYXMAGANlbnYTX19lbXZhbF9jYWxsX21ldGhvZAAZA2VudhhfX2VtdmFsX2NhbGxfdm9pZF9tZXRob2QABANlbnYOX19lbXZhbF9kZWNyZWYACANlbnYSX19lbXZhbF9nZXRfZ2xvYmFsAAIDZW52GV9fZW12YWxfZ2V0X21ldGhvZF9jYWxsZXIABwNlbnYUX19lbXZhbF9nZXRfcHJvcGVydHkABwNlbnYOX19lbXZhbF9pbmNyZWYACANlbnYLX19lbXZhbF9uZXcABgNlbnYTX19lbXZhbF9uZXdfY3N0cmluZwACA2VudhdfX2VtdmFsX3J1bl9kZXN0cnVjdG9ycwAIA2VudhJfX2VtdmFsX3Rha2VfdmFsdWUABwNlbnYGX2Fib3J0AAwDZW52GV9lbXNjcmlwdGVuX2dldF9oZWFwX3NpemUAEwNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwADA2VudhdfZW1zY3JpcHRlbl9yZXNpemVfaGVhcAACA2VudgdfZ2V0ZW52AAIDZW52El9sbHZtX3N0YWNrcmVzdG9yZQAIA2Vudg9fbGx2bV9zdGFja3NhdmUAEwNlbnYSX3B0aHJlYWRfY29uZF93YWl0AAcDZW52FF9wdGhyZWFkX2dldHNwZWNpZmljAAIDZW52E19wdGhyZWFkX2tleV9jcmVhdGUABwNlbnYNX3B0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ZHluQ2FsbF9paWlpAIcJDWR5bkNhbGxfaWlpaWkAiAkOZHluQ2FsbF9paWlpaWQAiQkOZHluQ2FsbF9paWlpaWkAigkPZHluQ2FsbF9paWlpaWlkAIsJD2R5bkNhbGxfaWlpaWlpaQCMCRBkeW5DYWxsX2lpaWlpaWlpAI0JEWR5bkNhbGxfaWlpaWlpaWlpAI4JDmR5bkNhbGxfaWlpaWlqAKkJCWR5bkNhbGxfdgCPCQpkeW5DYWxsX3ZpAJAJC2R5bkNhbGxfdmlpAJEJDGR5bkNhbGxfdmlpaQCSCQ1keW5DYWxsX3ZpaWlpAJMJDmR5bkNhbGxfdmlpaWlpAJQJD2R5bkNhbGxfdmlpaWlpaQCVCQ5keW5DYWxsX3ZpaWppaQCqCRNlc3RhYmxpc2hTdGFja1NwYWNlADwIc2V0VGhyZXcAPQpzdGFja0FsbG9jADkMc3RhY2tSZXN0b3JlADsJc3RhY2tTYXZlADoJgQsBACMAC+QFlgmIBdwF3AXwBfEF3AXcBfAF+QWUBpQGmwacBqAGoQaOB5UHlgeXB5gHmQeaB5sHjge2B7cHuAe5B7oHuwe8B9gH2AfcBdgH2AfcBdwH3AfcBdwH3AfcBdwF3AX5B4MI3AWFCJ0IngiHAYgB/gf+B/4H3AXcBfkH8wg/QUm8AVJWpwFYXEGGAYcBiAFkQYYBhwGIAWZolgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZYJlgmWCZcJ8gXyBfIF8gWWBpkGnQaiBpMIlQiXCKsIrQivCEJFSEtNRU9QVEVXT0VFXk9PYWJIY0VlT09hSEVnRZcJlwmXCZcJlwmXCZcJlwmXCZcJlwmXCZcJlwmXCZcJlwmXCZcJmAmJBYoFjQWOBbcF7AXvBfMF7AX4BfoFlQaYBqkGrgbyB/IHlAiWCJkIpwisCK4IsQjkCPUI9ghDREZHTE5GrwFHWl9gYG3JBZgJmAmYCZgJmAmYCZgJmAmYCZgJmAmYCZgJmAmYCZgJmAmYCZgJmAmYCZkJmAioCKkIqgiwCFVba8QBmQmZCZkJmQmZCZkJmgn5BvoGiAeJB5oJmgmaCZsJpwasBvQG9Qb3BvsGgweEB4YH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ASgCADYCACABQQA2AgAgAyIBIAZGBEAgBSECBSABIQJBACEDIAUhAQNAIAFBfGogAkF8aiICKAIAIgE2AgAgARAnIANBf2oiA0ECdCAFaiEBIAIgBkcNAAsgASECIAAoAgAiAyEBCyAAIAI2AgAgBygCACEAIAcgBUEEajYCACAKIARBAnQgCGo2AgAgACABRwRAA0AgAEF8aiIAKAIAECMgACABRw0ACwsgA0UEQA8LIAMQ4gULfAEFfyMJIQIjCUEQaiQJIABBl44BECQiA0EAQbTwASACECgiBTYCACABKAIEIAEoAgAiBGsiAEUEQCADECMgAiQJDwsgAEECdSEGQQAhAANAIAUgAEECdCAEahB6IABBAWoiACAGSQRAIAEoAgAhBAwBCwsgAxAjIAIkCQtdAQJ/IwkhAiMJQRBqJAlBgOsBLAAARQRAQYDrARD9CARAQbTwAUECQajZABAlNgIACwtBtPABKAIAIQMgASgCABAnIAIgASgCADYCACADIABBnY4BIAIQIiACJAkL5wEBCX8jCSEDIwlBIGokCSADQQxqIgUgARDUAiADIgFBADYCACABQQRqIgZBADYCACABQQhqIghBADYCACAFQQRqIgkoAgAgBSgCACIKayICQQJ1IQcgAgRAIAdB/////wNLBEAQLAsgBiACEMYIIgQ2AgAgASAENgIAIAggB0ECdCAEajYCACACQQBKBEAgBCAKIAIQgQkaIAYgAkECdkECdCAEajYCAAsLIAAgARDQASABKAIAIgAEQCAGIAA2AgAgABDiBQsgBSgCACIARQRAIAMkCQ8LIAkgADYCACAAEOIFIAMkCQu+AwELfyMJIQIjCUFAayQJIAJBDGohByACQShqIgggARDTAiACQRxqIgkgARDUAiACQRBqIgVBADYCACAFQQRqIgZBADYCACAFQQhqIgpBADYCACAIQQRqIgsoAgAgCCgCACIEayIDQZQBbSEMIAMEQAJAQQAhAwNAIAFBACAJKAIAIANBAnRqKAIAIANBlAFsIARqENECIAcQygEgBigCACIEIAooAgBGBEAgBSAHEH0FIAQgBygCACIENgIAIAQQJyAGIAYoAgBBBGo2AgALIAcoAgAQIyADQQFqIgMgDE8NASAIKAIAIQQMAAsACwsgAiIDIAUQdyAAIAIQeSACKAIAIgEEQCAB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NgIAIABBIBDGCCIANgIAIAIgAEEgaiICNgIAIABCADcAACAAQgA3AAggAEIANwAQIABCADcAGCADIAI2AgAgAEEgIAEQjgML3gEBA38jCSEEIwlB8ABqJAkgABCFBCAEIgNBAWoiAiABKQAANwAAIAIgASkACDcACCACIAEpABA3ABAgAiABKQAYNwAYIAIgASkAIDcAICACIAEpACg3ACggAiABKQAwNwAwIAIgASkAODcAOCACQUBrIAFBQGspAAA3AAAgAiABKQBINwBIIAIgASkAUDcAUCACIAEpAFg3AFggASwAAEEASARAIANBAzoAACACIAIsAABB/wBxOgAAIAAgAxCIBBCwAiAEJAkFIANBAjoAACAAIAMQiAQQsAIgBCQJCwsOACAAEIUEIAAgARCGBAsJACAAIAEQhgQL/wMBBn8jCSEHIwlBoAJqJAkgByEDIAFBBGoiCCgCACIFIAEoAgAiBGtBAnUiBiACKAIEIAIoAgBrQZQBbUYEQCAEIAVHBEBBfyAGQQFqIgVBlAFsIAVBkZ/rDUsbEMYIIQRBfyAFQaQCbCAFQbjggQdLGxDGCCIGIAAQhgQgBBDeAkGosC9qEOoDIANBwgAQ7AIgAxDaAyADIANBARDoAiAEIAQgAxDeAyABKAIAIgAgCCgCAEYEQCAEIAZBARDlASEAIAQQ4gUgBhDiBSAHJAkgAA8LQQAhAwNAIANBAWoiBUGkAmwgBmogA0ECdCAAaigCABD9AyAFQZQBbCAEaiACKAIAIANBlAFsahDqAyAFIAgoAgAgASgCACIAa0ECdSIDSQRAIAUhAwwBCwsgBCAGIANBAWoQ5QEhACAEEOIFIAYQ4gUgByQJIAAPCwtBDBACIgFCADcCACABQQA2AgggAUHAABDGCCIANgIAIAFBwICAgHg2AgggAUE9NgIEIABBho8BKQAANwAAIABBjo8BKQAANwAIIABBlo8BKQAANwAQIABBno8BKQAANwAYIABBpo8BKQAANwAgIABBro8BKQAANwAoIABBto8BKQAANwAwIABBvo8BKAAANgA4IABBwo8BLAAAOgA8IABBADoAPSABQYjIAEHrABADQQALWgECfyMJIQMjCUGACWokCSADQcAEaiIEEMwDIARBARCoAyADIAAgASACEI8EIAQgAxC1A0UEQBDeAigCAEUEQBCwAiADJAlBAQ8LCxDeAkEANgIAIAMkCUEAC9wBAQR/IAEoAgAiBSABQQRqIgQoAgBGBEBBDBACIgNCADcCACADQQA2AgggA0EgEMYIIgI2AgAgA0GggICAeDYCCCADQRY2AgQgAkHEjwEpAAA3AAAgAkHMjwEpAAA3AAggAkHUjwEoAAA2ABAgAkHYjwEuAAA7ABQgAkEAOgAWIANBiMgAQesAEAMLIAAgBRCGBCAEKAIAIAEoAgAiA2tBpAJtQQFNBEAPC0EBIQIDQCAAIAAgAkGkAmwgA2oQ8AMgAkEBaiICIAQoAgAgASgCACIDa0GkAm1JDQALC1gBA38jCSEDIwlB0ARqJAkgA0GkAmohBSADIQQgAigCACACKAIERgRAIAAgARCGBCADJAkFIAUgAhDmASAEIAEQhgQgBCAEIAUQ8QMgACAEEIYEIAMkCQsL0AIBA38jCSECIwlB8ABqJAkgAEEANgIAIABBBGoiBEEANgIAIABBCGoiA0EANgIAIABB4AAQxggiADYCACADIABB4ABqIgM2AgAgAEIANwAAIABCADcACCAAQgA3ABAgAEIANwAYIABCADcAICAAQgA3ACggAEIANwAwIABCADcAOCAAQUBrQgA3AAAgAEIANwBIIABCADcAUCAAQgA3AFggBCADNgIAIAIgARCJBCACQQFqIQEgAiwAAEEDRgRAIAEgASwAAEGAf3I6AAALIAAgASkAADcAACAAIAEpAAg3AAggACABKQAQNwAQIAAgASkAGDcAGCAAIAEpACA3ACAgACABKQAoNwAoIAAgASkAMDcAMCAAIAEpADg3ADggAEFAayABQUBrKQAANwAAIAAgASkASDcASCAAIAEpAFA3AFAgACABKQBYNwBYIAIkCQuAAgEEfyMJIQMjCUGQA2okCSAAEIUEIABBpAJqENcCIANB5ABqIgQQhQQgAyIFQQFqIgIgASkAADcAACACIAEpAAg3AAggAiABKQAQNwAQIAIgASkAGDcAGCACIAEpACA3ACAgAiABKQAoNwAoIAIgASkAMDcAMCACIAEpADg3ADggAkFAayABQUBrKQAANwAAIAIgASkASDcASCACIAEpAFA3AFAgAiABKQBYNwBYIAEsAABBAEgEQCAFQQM6AAAgAiACLAAAQf8AcToAACAEIAUQiAQQsAIgACAEEIYEIAMk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IiABNgIAIAEQ4gULIBkoAgAiAQRAICMgATYCACABEOIFCyAGJAkgAAvfBAEFfyABIAAgAUYiAjoADCACBEAPCyABIQICQAJAA0ACQCACQQhqIgYoAgAiBUEMaiIDLAAADQMgBSgCCCIBKAIAIgQgBUYEfyABKAIEIgRFDQEgBEEMaiIELAAADQEgBAUgBEUNAyAEQQxqIgQsAAANAyAECyECIANBAToAACABIAAgAUY6AAwgAkEBOgAAIAAgAUYNAyABIQIMAQsLIAVBCGohBCAFKAIAIAJHBEAgBUEEaiIDKAIAIgAoAgAhAiADIAI2AgAgAgRAIAIgBTYCCCAEKAIAIQELIAAgATYCCCAEKAIAIgEgAUEEaiABKAIAIAVGGyAANgIAIAAgBTYCACAEIAA2AgAgAEEMaiEDIAAoAgghAQsgA0EBOgAAIAFBADoADCABIAEoAgAiAEEEaiIEKAIAIgI2AgAgAgRAIAIgATYCCAsgACABQQhqIgIoAgA2AgggAigCACIDIANBBGogASADKAIARhsgADYCACAEIAE2AgAgAiAANgIADwsgBUEIaiEAIAIgBSgCAEYEQCAFIAJBBGoiBCgCACIDNgIAIAMEQCADIAU2AgggACgCACEBCyAGIAE2AgAgACgCACIBIAFBBGogBSABKAIARhsgAjYCACAEIAU2AgAgACACNgIAIAJBDGohAyACKAIIIQELIANBAToAACABQQA6AAwgAUEEaiIDKAIAIgAoAgAhAiADIAI2AgAgAgRAIAIgATYCCAsgACABQQhqIgIoAgA2AgggAigCACIDIANBBGogASADKAIARhsgADYCACAAIAE2AgAgAiAANgIACwsgACABBEAgACABKAIAEPABIAAgASgCBBDwASABEOIFCws6AQF/IAFFBEAPCyAAIAEoAgAQ8QEgACABKAIEEPEBIAEoAhQiAgRAIAEgAjYCGCACEOIFCyABEOIFC/oQAR5/IwkhCSMJQUBrJAkgCUEcaiEGIAlBEGohEyAJQQRqIQogCSENIAlBNGoiDkEANgIAIA5BBGoiEUEANgIAIA5BCGoiGkEANgIAIAlBKGoiC0EANgIAIAtBBGoiD0EANgIAIAtBCGoiG0EANgIAIAEoAgAiBCABQQRqIhwoAgAiB0YEQCAEIRYgByEXBQJAIAZBBGohFCATQQRqIRUgCkEEaiEQIApBCGohGAJAAkACQAJAAkADQCAEQaQCaiICENUCDQEgBiACENMCIBMgAhDUAiAUKAIAIAYoAgBGDQIgFSgCACATKAIARg0CIBEoAgAiAiAaKAIARgRAIA4gBhDzAQUgAkEANgIAIAJBBGoiDEEANgIAIAJBCGoiCEEANgIAIBQoAgAgBigCAGsiA0GUAW0hBSARIAMEfyAFQZGf6w1LDQUgDCADEMYIIgM2AgAgAiADNgIAIAggBUGUAWwgA2o2AgAgBigCACIFIBQoAgAiCEcEfyAFIQIDQCADIAIQjAIgDCAMKAIAQZQBaiIDNgIAIAJBlAFqIgIgCEcNAAsgESgCAAUgAgsFIAILQQxqNgIACyAKQQA2AgAgEEEANgIAIBhBADYCACATKAIAIgIgFSgCACIMRwRAA0AgAigCACEFIA1BIBDGCCIDNgIAIAMgBSkAADcAACADIAUpAAg3AAggAyAFKQAQNwAQIAMgBSkAGDcAGCAQKAIAIgUgGCgCAEYEQCAKIA0QcgUgBSADNgIAIBAgECgCAEEEajYCAAsgDCACQQRqIgJHDQALCyAPKAIAIgMgGygCAEYEQCALIAoQ9AEgCigCACECBSADQQA2AgAgA0EEaiIMQQA2AgAgA0EIaiIdQQA2AgAgECgCACAKKAIAIgJrIgVBAnUhCCAPIAUEfyAIQf////8DSw0GIAwgBRDGCCIFNgIAIAMgBTYCACAdIAhBAnQgBWo2AgAgECgCACAKKAIAIgJrIghBAEoEfyAFIAIgCBCBCRogDCAIQQJ2QQJ0IAVqNgIAIA8oAgAFIAMLBSADC0EMajYCAAsgAgRAIBAgAjYCACACEOIFCyATKAIAIgIEQCAVIAI2AgAgAhDiBQsgBigCACICBEAgFCACNgIAIAIQ4gULIAcgBEHIAmoiBEcNAAsgDigCACIeIRkgASgCACEWIBwoAgAhFyARKAIAIR8MBQtBDBACIgRCADcCACAEQQA2AgggBEEwEMYIIgI2AgAgBEGwgICAeDYCCCAEQSg2AgQgAkHbjwEpAAA3AAAgAkHjjwEpAAA3AAggAkHrjwEpAAA3ABAgAkHzjwEpAAA3ABggAkH7jwEpAAA3ACAgAkEAOgAoIARBiMgAQesAEAMMAwtBDBACIgRCADcCACAEQQA2AgggBEEgEMYIIgI2AgAgBEGggICAeDYCCCAEQR82AgQgAkGEkAEpAAA3AAAgAkGMkAEpAAA3AAggAkGUkAEpAAA3ABAgAkGckAEoAAA2ABggAkGgkAEuAAA7ABwgAkGikAEsAAA6AB4gAkEAOgAfIARBiMgAQesAEAMMAgsQLAwBCxAsCwsLIBcgFmtByAJtIg0gHyAea0EMbUcEQEEMEAIiA0IANwIAIANBADYCCCADQSAQxggiAjYCACADQaCAgIB4NgIIIANBHjYCBCACQaSQASkAADcAACACQayQASkAADcACCACQbSQASkAADcAECACQbyQASgAADYAGCACQcCQAS4AADsAHCACQQA6AB4gA0GIyABB6wAQAwsgDSAPKAIAIAsoAgAiBGsiB0EMbUcEQEEMEAIiA0IANwIAIANBADYCCCADQSAQxggiAjYCACADQaCAgIB4NgIIIANBHjYCBCACQaSQASkAADcAACACQayQASkAADcACCACQbSQASkAADcAECACQbyQASgAADYAGCACQcCQAS4AADsAHCACQQA6AB4gA0GIyABB6wAQAwsgBwRAAkBBACECA0AgAkEMbCAZaigCBCACQQxsIBlqKAIAa0GUAW0gAkEMbCAEaigCBCACQQxsIARqKAIAa0ECdUYEQCACQQFqIgIgDU8NAgwBCwtBDBACIgRCADcCACAEQQA2AgggBEEgEMYIIgI2AgAgBEGggICAeDYCCCAEQR42AgQgAkGkkAEpAAA3AAAgAkGskAEpAAA3AAggAkG0kAEpAAA3ABAgAkG8kAEoAAA2ABggAkHAkAEuAAA7ABwgAkEAOgAeIARBiMgAQesAEAMLCyAAIAEgDiALEPUBIAsoAgAiAiAPKAIAIg1GBEAgAiESBQJAIAZBBGohBCAGQQhqIQMCQANAIAZBADYCACAEQQA2AgAgA0EANgIAIAJBBGoiBygCACACKAIAayIAQQJ1IQEgAARAAkAgAUH/////A0sNAyAEIAAQxggiADYCACAGIAA2AgAgAyABQQJ0IABqNgIAIAQgBygCACACKAIAIgdrIgFBAEoEfyAAIAcgARCBCRogBCABQQJ2QQJ0IABqIgE2AgAgACABRgR/IAAFA0AgACgCACIHBEAgBxDiBQsgAEEEaiIAIAFHDQALIAYoAgAiAEUNAiAACwUgAAs2AgAgABDiBQsLIAJB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IAAgARDqAwsJACAAIAEQ6gML6AEBBH8gASgCACIFIAFBBGoiBCgCAEYEQEEMEAIiAkIANwIAIAJBADYCCCACQTAQxggiAzYCACACQbCAgIB4NgIIIAJBKDYCBCADQeuRASkAADcAACADQfORASkAADcACCADQfuRASkAADcAECADQYOSASkAADcAGCADQYuSASkAADcAICADQQA6ACggAkGIyABB6wAQAwsgACAFEOoDIAQoAgAgASgCACIDa0GUAW1BAU0EQA8LQQEhAgNAIAAgACACQZQBbCADahDQAyACQQFqIgIgBCgCACABKAIAIgNrQZQBbUkNAAsLhQkBDn8jCSEKIwlB4AFqJAkgAUEEaiIEKAIAIAEoAgBrIgNBlAFtIQYgA0UEQEEMEAIiAkIANwIAIAJBADYCCCACQTAQxggiAzYCACACQbCAgIB4NgIIIAJBKDYCBCADQeuRASkAADcAACADQfORASkAADcACCADQfuRASkAADcAECADQYOSASkAADcAGCADQYuSASkAADcAICADQQA6ACggAkGIyABB6wAQAwsgCkHUAWoiCEEANgIAIAhBBGoiC0EANgIAIAhBCGoiAkEANgIAIAZB/////wNLBEAQLAsgCiEHIAsgBkECdBDGCCIDNgIAIAggAzYCACACIAZBAnQgA2o2AgADQCADQQA2AgAgCyALKAIAQQRqIgM2AgAgBkF/aiIGDQALIAQoAgAgASgCAEYEQEEAIQIFIAdBAWohA0EAIQYDQEEwEMYIIQIgCCgCACAGQQJ0aiACNgIAIAgoAgAgBkECdGooAgAhAiAHIAEoAgAgBkGUAWxqEO8DIAcsAABBA0YEQCADIAMsAABBgH9yOgAACyACIAMpAAA3AAAgAiADKQAINwAIIAIgAykAEDcAECACIAMpABg3ABggAiADKQAgNwAgIAIgAykAKDcAKCAGQQFqIgYgBCgCACABKAIAayICQZQBbSIFSQ0ACwsgCkHIAWoiBkEANgIAIAZBBGoiA0EANgIAIAZBCGoiBEEANgIAIAIEfyAFQf////8DSwRAECwLIAYgBUECdCIJEMYIIgI2AgAgBCAFQQJ0IAJqIgU2AgAgAkEAIAkQgwkaIAMgBTYCACACIAVGBH8gAiEEIAYFIAJBADYCACAFIAJrQQJ1IglBAUsEf0EBIQQDfyAE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IwkhAiMJQUBrJAkgAiAAEO8DIAJBAWohACACLAAAQQNGBEAgACAALAAAQYB/cjoAAAsgASAAKQAANwAAIAEgACkACDcACCABIAApABA3ABAgASAAKQAYNwAYIAEgACkAIDcAICABIAApACg3ACggAiQJCxAAIAAQ6QMgACABIAIQ3gML3gEBA38jCSECIwlBQGskCSAAQQA2AgAgAEEEaiIEQQA2AgAgAEEIaiIDQQA2AgAgAEEwEMYIIgA2AgAgAyAAQTBqIgM2AgAgAEIANwAAIABCADcACCAAQgA3ABAgAEIANwAYIABCADcAICAAQgA3ACggBCADNgIAIAIgARDvAyACQQFqIQEgAiwAAEEDRgRAIAEgASwAAEGAf3I6AAALIAAgASkAADcAACAAIAEpAAg3AAggACABKQAQNwAQIAAgASkAGDcAGCAAIAEpACA3ACAgACABKQAoNwAoIAIkCQuvAQECfyMJIQIjCUGQAWokCSACQdAAaiIBIAAQ7wMgAUEBaiEAIAEsAABBA0YEQCAAIAAsAABBgH9yOgAACyACQSBqIgEgACkAADcAACABIAApAAg3AAggASAAKQAQNwAQIAEgACkAGDcAGCABIAApACA3ACAgASAAKQAoNwAoIAIgAUEwEJEEIAItAAMgAi0AAEEYdCACLQABQRB0ciACLQACQQh0cnIhACACJAkgAAuGAQECfyMJIQMjCUGgAmokCUEgEOEFIgQgASACQZAJQRQQkAQgA0HCABDsAiADENoDQZQCEOEFIgFBwgAQ7AIgASAEQSAQjQMgASABIAMQ7wIgAEEANgIAIABBlAIQ4QUiADYCACAAQcIAEOwCIAAQgwMgACABEP8CIAEQ4gUgBBDiBSADJAkLhQIBAn8jCSEEIwlBoAJqJAkgAEEANgIAIABBlAIQ4QUiAzYCACADQcIAEOwCIAMQgwMgAyABQSAQjQMgBCIAQcIAEOwCIAAQ2gMgAgRAIAMgAyAAEO8CIAQkCQ8LIAMgABDrAkEASgRAQQwQAiIBQgA3AgAgAUEANgIIIAFBwAAQxggiADYCACABQcCAgIB4NgIIIAFBNDYCBCAAQZSSASkAADcAACAAQZySASkAADcACCAAQaSSASkAADcAECAAQaySASkAADcAGCAAQbSSASkAADcAICAAQbySASkAADcAKCAAQcSS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NwAAIARB55QBKQAANwAIIARB75QBKQAANwAQIARB95QBKQAANwAYIARB/5QBKQAANwAgIARBh5UBKQAANwAoIARBj5UBKQAANwAwIARBl5UBKQAANwA4IARBQGtBn5UBKQAANwAAIARBp5UBKQAANwBIIARBr5UBKAAANgBQIARBs5UBLAAAOgBUIARBADoAVSAFQYjIAEHrABADCyADKAIEIAMoAgBrQQJ1IAtHBEBBDBACIgVCADcCACAFQQA2AgggBUHgABDGCCIENgIAIAVB4ICAgHg2AgggBUHVADYCBCAEQd+UASkAADcAACAEQeeUASkAADcACCAEQe+UASkAADcAECAEQfeUASkAADcAGCAEQf+UASkAADcAICAEQYeVASkAADcAKCAEQY+VASkAADcAMCAEQZeVASkAADcAOCAEQUBrQZ+VASkAADcAACAEQaeVASkAADcASCAEQa+VASgAADYAUCAEQbOVASwAADoAVCAEQQA6AFUgBUGIyABB6wAQAwsgCkEwaiIJQQRqIgxBADYCACAJQQhqIg1BADYCACAJIAlBBGoiCzYCACAGIAhHBEBBACEIA0BB0AAQxggiByACKAIAIAhBAnRqKAIAIgQpAAA3AAAgByAEKQAINwAIIAcgBCkAEDcAECAHIAQpABg3ABggCEGUAWwgBmogB0EgahCWAkGUAhDGCCIOQcIAEOwCIA4gAygCACAIQQJ0aigCABD/AiALKAIAIgYEQAJAIAwhBQJAAkADQAJAIAYoAhAhD0EAIQQCfwJAA0AgBCAHai0AACIRIAQgD2otAAAiEkgNASAEQQFqIgRB0ABJIBEgEkxxDQALQQAhBANAIAQgD2otAAAiESAEIAdqLQAAIhJOBEAgBEEBaiIEQdAASSARIBJMcUUNBwwBCwsgBkEEaiIFKAIAIgRFDQQgBAwBCyAGKAIAIgRFDQEgBiEFIAQLIQYMAQsLIAYhBAwCCyAGIQQgBSEGDAELIAYhBCAFIQYLBSALIgQhBgsgBigCAEUEQEEYEMYIIgUgBzYCECAFIA42AhQgBUEANgIAIAVBADYCBCAFIAQ2AgggBiAFNgIAIAkoAgAoAgAiBARAIAkgBDYCACAGKAIAIQULIAwoAgAgBRDvASANIA0oAgBBAWo2AgALIAhBAWoiCCAQKAIAIAEoAgAiBmtBlAFt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BQsgAUEAOgAMIAAgASgCCCIBRg0BIAEsAAxFBEAgASEADAILCyABKAIIIgJBBGogAiABIAIoAgBGGygCACECDAELCyAAQQE6AAwPCyABKAIEIgIEQCABIQAMBQUgASEADAcLAAsgASEADAMLIAFBAToADA8LIAFBBGohACACBH8gACECIAMFIARBDGoiACwAAEUNAyABQQRqIgAhAiAAKAIACyIEQQxqIgNBAToAACABQQxqIgBBADoAACACIAQoAgAiAjYCACACBEAgAiABNgIICyAEQQhqIgIgAUEIaiIFKAIANgIAIAUoAgAiBiAGQQRqIAEgBigCAEYbIAQ2AgAgBCABNgIAIAUgBDYCAAwECyAEQQxqIQAMAQsgAkEMaiICLAAADQEgAiEAIAFBDGohBCABQQhqIQIMAwsgAUEIaiECIAFBDGohAwwBCyAHQQxqIgRBAToAACABQQxqIgNBADoAACAAIAdBBGoiACgCACICNgIAIAIEQCACIAE2AggLIAdBCGoiAiABQQhqIgUoAgA2AgAgBSgCACIGIAZBBGogASAGKAIARhsgBzYCACAAIAE2AgAgBSAHNgIAIAMhAAwBCyADIAIoAgAiBEEMaiIBLAAAOgAAIAFBAToAACAAQQE6AAAgBCAEKAIAIgNBBGoiACgCACIBNgIAIAEEQCABIAQ2AggLIAMgBEEIaiICKAIANgIIIAIoAgAiASABQQRqIAQgASgCAEYbIAM2AgAgACAENgIAIAIgAzYCAA8LIAQgAigCACIDQQxqIgEsAAA6AAAgAUEBOgAAIABBAToAACADQQRqIgAoAgAiAigCACEBIAAgATYCACABBEAgASADNgIICyACIANBCGoiASgCADYCCCABKAIAIgAgAEEEaiADIAAoAgBGGyACNgIAIAIgAzYCACABIAI2AgALYgEBfyMJIQQjCUHgAGokCSAEIAIpAAA3AAAgBCACKQAINwAIIAQgAikAEDcAECAEIAIpABg3ABggAyAEQSBqEJYCIARB0ABqIgIgBDYCACABIAAgAhDSAigCABD/AiAEJAkL3wEBBX8gACgCBCIABEACQCABKAIAIQUgACECA0ACQCAAKAIQIQZBACEBAkACQANAIAEgBWotAAAiAyABIAZqLQAAIgRIDQEgAUEBaiIBQdAASSADIARMcQ0AC0EAIQED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BEAgAyEGDAELCyAAQSBqIQAgAUFgaiEBIAdBAWohBCAHIAlIBEAgBCEHDAELCwsgAkGEtDBqIglBAzoAACAIIgMgCUE4EJEEIAJBvLQwaiEGQTchBEEAIQADQCAEQX9qIgEgBmotAAAgACAEIAJBhLQwamoiAC0AAGpqIQcgACAHOgAAIAdBCHUhACAEQQFLBEAgASEEDAELCyACQbu0MGoiAC0AACADLQAfaiEBIAAgAToAACADLQAeIAJBurQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAdIAJBubQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAcIAJBuLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAbIAJBt7QwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAaIAJBtrQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAZIAJBtbQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAYIAJBtLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAXIAJBs7QwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAWIAJBsrQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAVIAJBsbQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAUIAJBsLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQATIAJBr7QwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQASIAJBrrQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQARIAJBrbQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAQIAJBrLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAPIAJBq7QwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAOIAJBqrQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQANIAJBqbQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAMIAJBqLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQALIAJBp7QwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAKIAJBprQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAJIAJBpbQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAIIAJBpLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAHIAJBo7QwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAGIAJBorQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAFIAJBobQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAEIAJBoLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQADIAJBn7QwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQACIAJBnrQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQABIAJBnbQwaiIALQAAIAFBCHZqaiEBIAAgAToAACADLQAAIAJBnLQwaiIALQAAIAFBCHZqaiEBIAAgAToAACACQZu0MGoiAC0AACABQQh2aiEBIAAgAToAACACQZq0MGoiAC0AACABQRB0QRh1aiEBIAAgAToAACACQZm0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZi0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZe0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZa0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZW0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZS0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZO0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZK0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZG0MGoiAC0AACABQQh1aiEBIAAgAToAACACQZC0MGoiAC0AACABQQh1aiEBIAAgAToAACACQY+0MGoiAC0AACABQQh1aiEBIAAgAToAACACQY60MGoiAC0AACABQQh1aiEBIAAgAToAACACQY20MGoiAC0AACABQQh1aiEBIAAgAToAACACQYy0MGoiAC0AACABQQh1aiEBIAAgAToAACACQYu0MGoiAC0AACABQQh1aiEBIAAgAToAACACQYq0MGoiAC0AACABQQh1aiEBIAAgAToAACACQYm0MGoiAC0AACABQQh1aiEBIAAgAToAACACQYi0MGoiAC0AACABQQh1aiEBIAAgAToAACACQYe0MGoiAC0AACABQQh1aiEBIAAgAToAACACQYa0MGoiAC0AACABQQh1aiEBIAAgAToA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f0GAAiECIAEFIAAoAhwiAQR/QeABIQIgAQUgACgCGCIBBH9BwAEhAiABBSAAKAIUIgEEf0GgASECIAEFIAAoAhAiAQR/QYABIQIgAQUgACgCDCIBBH9B4AAhAiABBSAAKAIIIgEEf0HAACECIAEFIAAoAgQiAQR/QSAhAiABBSAAKAIABH8gACgCAAVBAAsQ0gQPCwsLCwsLCwsLCwshACAAENIEIAJqCwkAIAAgARCeAwtLAQF/IABBMBDhAiAAQSxqIgEgASgCAEH/////AXE2AgAgABCXAxC1BEF/RgRADwsDQCAAIAAQlwMQqwQaIAAQlwMQtQRBf0cNAAsLgQEBAn8jCSEEIwlBoAJqJAkgBCIDQcIAEOwCIAMgASACQRAQiwMgAxCCAwRAIABCADcCACAAQgA3AgggAEIANwIQIABCADcCGCAAQgA3AiAgAEIANwIoIAQkCQ8LIAMoAgRBAUYEQCAAIAMoAgwQngMgBCQJBSAAIAMQnQMgBCQJCwt/AQJ/IwkhAiMJQaACaiQJIAIiA0HCABDsAiACIAFBMBCNAyACEIIDBEAgAEIANwIAIABCADcCCCAAQgA3AhAgAEIANwIYIABCADcCICAAQgA3AiggAiQJDwsgAygCBEEBRgRAIAAgAygCDBCeAyACJAkFIAAgAxCdAyACJAkLCywBAX8jCSECIwlBoAJqJAkgAkHCABDsAiACIAEQnwMgAEEwIAIQjgMgAiQJC20BAX8Q3gIhBAJAAkACQCACQQFrDgIBAAILIAAgASADQTBsIARqQaSkMGoiAhCVAyAAQTBqIAFBMGogAhCVAw8LIAAgASADQeAAbCAEakGUoDBqEMkEDwsgACABIANB4ABsIARqQbSlMGoQyQQLCwAgACABIAIQyQQLCQAgACABEMQECy4BAX8jCSECIwlBMGokCSACIAEQogMgACABQTBqEN8EIABBMGogAhCiAyACJAkLCQAgACABEM8ECwsAIAAgASACEMsECyIBAX8jCSECIwlBoAZqJAkgAiABENAEIAAgAhDNBCACJAkLdwAgACABEOMEBEBBAg8LIABBMGogAUEwahDjBARAQQIPCyAAQeAAaiABQeAAahDjBARAQQIPCyAAQZABaiABQZABahDjBARAQQIPCyAAQcABaiABQcABahDjBEUEQCAAQfABaiABQfABahDjBEUEQEEADwsLQQILIwAgACABELQDBEBBAg8LQQJBACAAQaACaiABQaACahC0AxsLkwEBBH8jCSEFIwlB4ABqJAkgAhCCAwRAIAAQyAMgBSQJDwsgBSIDIAEQwwMgAhCFAyIEQQFKBEAgBEF+aiEEA0AgAyADELEDIAIgBBCGAwRAIAMgAyABEK4DCyAEQX9qIQYgBEEASgRAIAYhBAwBCwsLIAIoAghBAUYEQCAAIAMQvQMgBSQJBSAAIAMQwwMgBSQJCwumAQEEfyMJIQUjCUGQAWokCSACEIIDBEAgAEEBEKgDIABBMGoQowMgAEHgAGoQowMgBSQJDwsgBSIDIAEQyQMgAhCFAyIEQQFKBEAgBEF+aiEEA0AgAyADELMDIAIgBBCGAwRAIAMgAyABELIDCyAEQX9qIQYgBEEASgRAIAYhBAwBCwsLIAIoAghBAUYEQCAAIAMQvwMgBSQJBSAAIAMQyQMgBSQJCwuwBAELfyMJIQojCSEMIwkgAkHgAGxBD2pBcHFqJAkjCSEIIwkgAkHgAGxBD2pBcHFqJAkjCSENIwkgAkHgAGxBD2pBcHFqJAkgAkUEQCAKJAkPCyACQQBKIgtFBEAgCCAIIAIQvgMgCiQJDwsDQCADQeAAbCAMaiIHIANBwARsIAFqQeAAahCxAyADQeAAbCAIaiIEIAcgA0HABGwgAWpBwAFqEPUEIAQgBBD2BCAEIAQgBxD0BCADQeAAbCANaiIJIANBwARsIAFqQeADahCxAyAHIAkQrwMgByAHIAQQ9AQgBCADQcAEbCABakGgAmoQ9gQgBCAEEPYEIANBAWoiAyACRw0ACyAIIAggAhC+AyALRQRAIAokCQ8LQQAhAwNAIANBwARsIABqQYADaiIJIANB4ABsIAxqIANB4ABsIAhqIgYQrgMgBiADQcAEbCABakHAAWoiBCADQcAEbCABakHgAGoiBxCuAyADQeAAbCANaiIFIAkQsQMgBSAFIAYQ9QQgBSAFEPYEIAUgBSAGEPUEIAYgA0HABGwgAWpBoAJqIgsgA0HABGwgAWpB4ANqIgkQrgMgBSAFIAYQ9AQgA0HABGwgAGoiBiAFEK8DIAYgBkEBENwEIANBwARsIABqQeAAaiAHEMMDIANBwARsIABqQcABaiAEEMMDIANBwARsIABqQaACaiALEMMDIANBwARsIABqQeADaiAJEMMDIANBAWoiAyACRw0ACyAKJAkLhgQBCn8jCSEKIwlBwARqJAkQMiELIwkhByMJIANBwARsQQ9qQXBxaiQJIANFBEAgABDNAyALEDEgCiQJDwsgCiIIIAEQywMgAigCACIERQRAIANBAUoiDARAQQAhBEEBIQUDQCAEQQAgBUECdCACaiINKAIAIgZrIAYgBkEASBsiCUgEQANAIAggCBDuBCAEQQFqIgQgCUcNAAsgCSEEIA0oAgAhBgsgBUF/akHABGwgB2ohCSAGQQBIBEAgCSAIEMIDBSAJIAgQywMLIAVBAWoiBSADRw0ACwsgByAHIANBf2oiAhC4AyAAIAEQywMgDEUEQCALEDEgCiQJDwtBACEBA0AgACAAIAFBwARsIAdqEOkEIAFBAWoiASACRw0ACyALEDEgCiQJDwsgA0EASgRAAkBBACEBA0AgBUECdCACaiEJIAFBACAEayAEIARBAEgbIgZIBEADQCAIIAgQ7gQgAUEBaiIBIAZHDQALIAYhASAJKAIAIQQLIAVBwARsIAdqIQYgBEEASARAIAYgCBDCAwUgBiAIEMsDCyADIAVBAWoiBUYNASAFQQJ0IAJqKAIAIQQMAAsACwsgByAHIAMQuAMgACAHEMsDIANBAUwEQCALEDEgCiQJDwtBASEBA0AgACAAIAFBwARsIAdqEOkEIAFBAWoiASADRw0ACyALEDEgCiQJC0YBAX8jCSECIwlBwARqJAkgAiABEMEDIAAgARDCAyAAIAAgAhDpBCACIABBARC8AyACIAJBARC8AyAAIAAgAhDpBCACJAkLFgAgACABEKIDIABBMGogAUEwahDfBAuCBQEEfwJAAkACQAJAAkAgAg4EAAECAwQLIAAgARDLAw8LIAAgARCiAyAAQTBqIAFBMGoQ3wQgAEGgAmoiAiABQaACahCiAyAAQdACaiABQdACahDfBCAAQeAAaiIDIAFB4ABqEKIDIABBkAFqIAFBkAFqEN8EIABBgANqIgQgAUGAA2oQogMgAEGwA2ogAUGwA2oQ3wQgAEHAAWoiBSABQcABahCiAyAAQfABaiABQfABahDfBCAAQeADaiIGIAFB4ANqEKIDIABBkARqIAFBkARqEN8EIAIgAkEBQQEQrQMgAyADQQFBAhCtAyAEIARBAUEDEK0DIAUgBUEBQQQQrQMgBiAGQQFBBRCtAw8LIAAgARDDAyAAQcABaiICIAFBwAFqQQJBARCtAyAAQeAAaiABQeAAakECQQIQrQMgAiACEPcEIABBoAJqIAFBoAJqQQJBARCtAyAAQeADaiICIAFB4ANqQQJBAhCtAyAAQYADaiABQYADakECQQMQrQMgAiACEPcEDwsgACABEKIDIABBMGogAUEwahDfBCAAQaACaiIEIAFBoAJqEKIDIABB0AJqIAFB0AJqEN8EIABB4ABqIgUgAUHgAGoQogMgAEGQAWogAUGQAWoQ3wQgAEGAA2oiBiABQYADahCiAyAAQbADaiABQbADahDfBCAAQcABaiICIAFBwAFqEKIDIABB8AFqIAFB8AFqEN8EIABB4ANqIgMgAUHgA2oQogMgAEGQBGogAUGQBGoQ3wQgBSAFQQNBAhCtAyACIAJBA0EEEK0DIAIgAhD3BCAEIARBA0EBEK0DIAYgBkEDQQMQrQMgAyADQQNBBRCtAyADIAMQ9wQLC1oBA38jCSECIwlB4ABqJAkgAkEwaiIDIAEQoQMgAiABQTBqIgQQoQMgAyADIAIQ2wQgAiADEJEDIAAgASACEJUDIABBMGoiACAEIAIQlQMgACAAEN8EIAIkCQvLAgEHfyMJIQUjCUHAAWokCRAyIQgjCSEHIwkgAkHgAGxBD2pBcHFqJAkgACABEMMDIAcgARDDAyACQQFKIgkEQEEBIQMDQCADQeAAbCAHaiIEIANB4ABsIAFqEMMDIANB4ABsIABqIANBf2pB4ABsIABqIAQQrgMgA0EBaiIDIAJHDQALCyAFQZABaiIDIAJBf2oiAUHgAGwgAGoiBBChAyAFQeAAaiIGIAFB4ABsIABqQTBqIgIQoQMgAyADIAYQ2wQgBiADEJEDIAUiAyAEIAYQlQMgA0EwaiIEIAIgBhCVAyAEIAQQ3wQgCUUEQCAAIAMQwwMgCBAxIAUkCQ8LA0AgAUHgAGwgAGogAUF/aiICQeAAbCAAaiADEK4DIAMgAyABQeAAbCAHahCuAyABQQFKBEAgAiEBDAELCyAAIAMQwwMgCBAxIAUkCQvEAwEIfyMJIQgjCUHAAWokCSAIIgIgARChAyACQZABaiIGIAFBMGoiBSABQeAAaiIJEJUDIAJBMGoiBCAGEN8EEJoDQX9IBEBBfyEDA0AgBCAEIAYQ3QQgA0F/aiIDEJoDSg0ACwsgBiACIAQQ3QQgAiAJEKEDIAQgAhDfBBCaA0F/SARAQX8hAwNAIAQgBCACEN0EIANBf2oiAxCaA0oNAAsLIAhB4ABqIgcgASAFEJUDIAcgBCAHEN0EIAIgBRChAyAEIAEgCRCVAyAEIAIgBBDdBCACIAUgBBCVAyAAQTBqIgUgAhDfBBCaA0F/SARAQX8hAwNAIAUgBSACEN0EIANBf2oiAxCaA0oNAAsLIAAgASAGEJUDIAIgCSAHEJUDIABB4ABqIgMgAhDfBBCaA0F/TgRAIAIgACAFENsEIAIgAiADENsEIAIgAhCRAyAAIAYgAhCVAyAFIAcgAhCVAyADIAQgAhCVAyAIJAkPC0F/IQEDQCADIAMgAhDdBCABQX9qIgEQmgNKDQALIAIgACAFENsEIAIgAiADENsEIAIgAhCRAyAAIAYgAhCVAyAFIAcgAhCVAyADIAQgAhCVAyAIJAkLtQIBCH8jCSECIwlB4ANqJAkgAiABELEDIAJBoAJqIgYgAUHgAGoiBSABQcABaiIEEK4DIAJB4ABqIgMgBhCvAyAGIAIgAxD1BCACIAQQsQMgAyACEK8DIAJBwAFqIgcgASAFEK4DIAcgAyAHEPUEIAIgBRCxAyADIAEgBBCuAyADIAIgAxD1BCACIAUgAxCuAyAAQeAAaiIFIAIQrwMgACABIAYQrgMgAiAEIAcQrgMgAEHAAWoiASACEK8DIAIgACAFEPQEIAIgAiABEPQEIAJBsANqIgQgAhChAyACQYADaiIIIAJBMGoiCRChAyAEIAQgCBDbBCAIIAQQkQMgAiACIAgQlQMgCSAJIAgQlQMgCSAJEN8EIAAgBiACEK4DIAUgByACEK4DIAEgAyACEK4DIAIkCQtkAQN/IwkhAiMJQcAEaiQJIAJBoAJqIgMgARDzBCACIAFBoAJqIgQQ8wQgAiACEPEEIAMgAyACEPkEIAMgAxDAAyAAIAEgAxDwBCAAQaACaiIAIAQQ+gQgACAAIAMQ8AQgAiQJCxgAIAAgARDKAyAAQaACaiABQaACahD6BAsWACAAIAEQogMgAEEwaiABQTBqEKIDCw8AIAAQowMgAEEwahCjAwsZACAAEKQDRQRAQQAPCyAAQTBqEKQDQQBHCycBAX8jCSECIwlBEGokCSAAIAEQqwMgAEEwaiABQTBqEKsDIAIkCQsoAQF/IwkhAiMJQfAAaiQJIAAgARCsAyAAQTBqIAFBMGoQrAMgAiQJCxEAIABBARCoAyAAQTBqEKMDCyUAIAAgARCiAyAAQTBqIAFBMGoQogMgAEHgAGogAUHgAGoQogMLUgAgACABEKIDIABBMGogAUEwahCiAyAAQeAAaiABQeAAahCiAyAAQZABaiABQZABahCiAyAAQcABaiABQcABahCiAyAAQfABaiABQfABahCiAwusAQAgACABEKIDIABBMGogAUEwahCiAyAAQeAAaiABQeAAahCiAyAAQZABaiABQZABahCiAyAAQcABaiABQcABahCiAyAAQfABaiABQfABahCiAyAAQaACaiABQaACahCiAyAAQdACaiABQdACahCiAyAAQYADaiABQYADahCiAyAAQbADaiABQbADahCiAyAAQeADaiABQeADahCiAyAAQZAEaiABQZAEahCiAwtpACAAEKMDIABBMGoQowMgAEHgAGoQowMgAEGQAWoQowMgAEHAAWoQowMgAEHwAWoQowMgAEGgAmoQowMgAEHQAmoQowMgAEGAA2oQowMgAEGwA2oQowMgAEHgA2oQowMgAEGQBGoQowMLawAgAEEBEKgDIABBMGoQowMgAEHgAGoQowMgAEGQAWoQowMgAEHAAWoQowMgAEHwAWoQowMgAEGgAmoQowMgAEHQAmoQowMgAEGAA2oQowMgAEGwA2oQowMgAEHgA2oQowMgAEGQBGoQowMLPAEBfxDeAiIAQQhqEM8DIABBADYCNCAAQQA2AjAgAEEANgIsIABBQGtBfzYCACAAQX82AjwgAEF/NgI4CyUAIABCADcCACAAQgA3AgggAEIANwIQIABCADcCGCAAQQA2AiALgwYBCn8jCSEHIwlB0AJqJAkgARDoAwRAIAAgAhDqAyAHJAkPCyACEOgDBEAgACABEOoDIAckCQ8LIAdBoAJqIQUgB0HwAWohAyAHQcABaiEIIAdBkAFqIQYgB0HgAGohBCAHQTBqIQkgByEKIAIoApABRQRAIAUgAUHgAGoiCxChAyADIAJB4ABqIgwQoQMgCCABIAMQlQMgBiACIAUQlQMgCiAFIAMQ2wQgBSAFIAsQlQMgBSAFIAJBMGoQlQMgAyADIAwQlQMgAyADIAFBMGoQlQMgBiAGIAgQ3QQgBSAF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ASkAADcAACAAQbKeASkAADcACCAAQbqeASkAADcAECAAQcKeASkAADcAGCAAQcqeASkAADcAICAAQdKeASkAADcAKCAAQdqeASkAADcAMCAAQeKeASkAADcAOCAAQUBrQeqeASkAADcAACAAQfKeASkAADcASCAAQfqeASkAADcAUCAAQYKfASkAADcAWCAAQYqfASwAADoAYCACQTBqIAAgABC5BRCqAyAAQbAJKQAANwAAIABBuAkpAAA3AAggAEHACSkAADcAECAAQcgJKQAANwAYIABB0AkpAAA3ACAgAEHYCSkAADcAKCAAQeAJKQAANwAwIABB6AkpAAA3ADggAEFAa0HwCSwAADoAACADIAAgABC5BUEQEIsDIABBi58BKQAANwAAIABBk58BKQAANwAIIABBm58BKQAANwAQIABBo58BKQAANwAYIABBq58BLAAAOgAgIAQgACAAELkFQRAQiwMgAEHNpAEpAAA3AAAgAEHVpAEpAAA3AAggAEHdpAEpAAA3ABAgAEHlpAEpAAA3ABggAEHtpAEpAAA3ACAgAEH1pAEpAAA3ACggAEH9pAEpAAA3ADAgAEGFpQEpAAA3ADggAEFAa0GNpQEpAAA3AAAgAEGVpQEpAAA3AEggAEGdpQEsAAA6AFAgAUGACGoiBiAAIAAQuQUQqgMgAEGsnwEpAAA3AAAgAEG0nwEpAAA3AAggAEG8nwEpAAA3ABAgAEHEnwEpAAA3ABggAEHMnwEpAAA3ACAgAEHUnwEpAAA3ACggAEHcnwEpAAA3ADAgAEHknwEpAAA3ADggAEFAa0HsnwEsAAA6AAAgASAAIAAQuQVBEBCLAyACQeAAaiIAEKMDIABBARCoAyACQQE2ApABIAUgAiADIAQgBiABENsDEN4CQcSvL2pBFjYCACABJAkLDgAgAEHgAGoQpANBAUYLIAAgABCjAyAAQTBqEKMDIABB4ABqEKMDIABBATYCkAELMQAgACABEKIDIABBMGogAUEwahCiAyAAQeAAaiABQeAAahCiAyAAIAEoApABNgKQAQvTAgEHfyMJIQcjCUHAAmokCSAHQaABaiECIAchAwJAAkAgAEGQAWoiBCgCAARAIAIgABCiAyACQTBqIABBMGoQogMgAkHgAGogAEHgAGoQogMgAiAEKAIANgKQASABQZABaiEEDAEFIAFBkAFqIgQoAgAEQCACIAAQ5AMMAgUgAkHgAGoiBSAAQeAAaiIIEKEDIANB4ABqIgYgAUHgAGoiBBChAyACIAAgBhCVAyADIAEgBRCVAyAFIAUgCBCVAyAGIAYgBBCVAyACQTBqIABBMGogBhCVAyADQTBqIgAgAUEwaiAFEJUDCwsMAQsgBCgCAARAIAMgARCiAyADQTBqIgAgAUEwahCiAyADQeAAaiABQeAAahCiAyADIAQoAgA2ApABBSADIAEQ5AMgA0EwaiEACwtBAkEAIAIgAxDjBCACQTBqIAAQ4wRyGyEAIAckCSAAC4wBAQN/IwkhAyMJQeAAaiQJIANBMGoiBCABEKEDIAMiAiAEIAEQlQMCQAJAAkAQ1wMOAgIAAQsgAiACIAEQ2wQMAQsgBCABENMDEJUDIAIgAiAEENsECwJAAkACQBDYAw4CAgABCyACIAJBARDcBAwBCyACIAIQ3gJB+K8vahDbBAsgACACEKIDIAMkCQuGAQECfyAAIAEQ3QMgACAAEOQDIABBlAFqIgMgACABENADQQIhAgNAIAJBlAFsIABqIAJBf2pBlAFsIABqIAAQ0AMgAkEBaiICQQRHDQALIAMgA0EDEOUDIAAgARCiAyAAQTBqIAFBMGoQogMgAEHgAGogAUHgAGoQogMgACABKAKQATYCkAELvwEBA38jCSECIwlBMGokCSACQRhqIQMgAkEQaiEEIABBATYCkAEgAEHgAGpBARCoAyAAIAFBAWoQqwMCQAJAAkACQCABLAAAQQJrDgIAAQILIABBMGoQowMMAgsgAEEwaiIBEKMDIAFBARCmAwwBCxDeAkEBNgIAIARB6KABNgIAIARBpgI2AgQgBBDTBAsgACAAEP0EBEAgAiQJDwsQ3gJBATYCACADQeigATYCACADQaoCNgIEIAMQ0wQgAiQJC3MBAn8jCSEDIwlBsAFqJAkgA0GYAWohAiABQeAAahCkA0EBRgRAEN4CQQE2AgAgAkHooAE2AgAgAkG+AjYCBCACENMECyADIgIgARDkAyACIAIQ/AQgACACQTBqEKUDQQJyOgAAIABBAWogAhCsAyACJAkLnQYBD38jCSEDIwlBwApqJAkgARCEBARAIAAgAhCGBCADJAkPCyACEIQEBEAgACABEIYEIAMkCQ8LIAEgAkYEQCAAIAEQ+QMgAyQJDwsgA0HgCWohDSADQYAJaiEFIANBoAhqIQ4gA0HAB2ohByADQeAGaiEJIANBgAZqIQ8gA0GgBWohESADQcAEaiEEIANB4ANqIQYgA0GAA2ohCyADQaACaiEKIANBwAFqIQggA0HgAGohECADIQwgAigCoAIEQCABQaACaiIMKAIABEAgByACIAEQ9QQgBSACQeAAaiABQeAAahD1BAUgDSABQcABaiIEELEDIAcgAiANEK4DIAUgDSAEEK4DIAUgBSACQeAAahCuAyAHIAcgARD1BCAFIAUgAUHgAGoQ9QQLIA4gBxCxAyAHEMUDBEAgBRDFAwRAIAAgARD5AwUgABCFBAsFIA8gByAOEK4DIAkgASAOEK4DIAAgBRCxAyAAIAAgDxD1BCARIAkQ9gQgACAAIBEQ9QQgCSAJIAAQ9QQgCSAJIAUQrgMgBSABQeAAaiAPEK4DIABB4ABqIAkgBRD1BCAAQcABaiECIAwoAgAEQCACIAcQwwMFIAIgAUHAAWogBxCuAwsLIABBADYCoAIFAkAgBCABQcABaiIHELEDIAYgAkHAAWoiBRCxAyALIAEgBhCuAyAKIAIgBBCuAyAMIAQgBhD0BCAEIAQgBxCuAyAEIAQgAkHgAGoQrgMgBiAGIAUQrgMgBiAGIAFB4ABqEK4DIAogCiALEPUEIAQgBCAGEPUEIAQgBBD2BCAKEMUDRQRAIAggChD2BCAIIAgQsQMgECAKIAgQrgMgCCALIAgQrgMgACAEELEDIAAgACAQEPUEIAsgCBD2BCAAIAAgCxD1BCAIIAggABD1BCAIIAggBBCuAyAGIAYgEBCuAyAGIAYQ9gQgAEHgAGogCCAGEPUEIABBwAFqIgEgByAFEPQEIAEgARCxAyABIAEgDBD1BCABIAEgChCuAwwBCyAEEMUDBEAgACABEPkDBSAAEIUECwsLIABBADYCoAIgAyQJCzoBAn8jCSEDIwlBsAJqJAkgAyEEIAEgAkYEQCAAEIUEIAMkCQUgBCACEIIEIAAgASAEEPADIAMkCQsL0QIBAX8Q3gIiAEGUhzBqIABB1OIvajYCACAAQZiHMGogAEH45C9qNgIAIABBnIcwaiAAQZznL2o2AgAgAEGghzBqIABBwOkvajYCACAAQaSHMGogAEHk6y9qNgIAIABBqIcwaiAAQYjuL2o2AgAgAEGshzBqIABBrPAvajYCACAAQbCHMGogAEHQ8i9qNgIAIABBtIcwaiAAQfT0L2o2AgAgAEG4hzBqIABBmPcvajYCACAAQbyHMGogAEG8+S9qNgIAIABBwIcwaiAAQeD7L2o2AgAgAEHEhzBqIABBhP4vajYCACAAQciHMGogAEGogDBqNgIAIABBzIcwaiAAQcyCMGo2AgAgAEHQhzBqIABB8IQwajYCACAAQZzWL2oQhQQgAEGA2i9qQQwQ7AIgAEGU3C9qQQwQ7AIgAEGo3i9qQQwQ7AIgAEG84C9qQQwQ7AILDQAQ3gJB0OIvaigCAAsiAQF/IAAQ3gIiAUHA2C9qEKIDIABBMGogAUHw2C9qEKIDCyIBAX8gABDeAiIBQaDZL2oQogMgAEEwaiABQdDZL2oQogML4wEBBX8jCSEBIwlBwARqJAkgAUGgAmoiAkHCABDsAiABQcIAEOwCIAIQ5QQgAEGUAmoiAyACEP8CIABBqARqIgQgAhD/AiAAQbwGaiIFIAIQ/wIgASACEP4CIAEgARD6AiAAIAJBAxD0AiAAIABBARDmAiAAIAAgARDkAiAFIAUgARDkAiAFIAUQgQMgASABEPoCIAQgBCABEOQCIAEgARD6AiADIAMgARDkAiABIAFBAhD9AiABIAEgAhD1AiABIAFBAxD0AiAEIAQgARDkAiABIAEQ+gIgAyADIAEQ5AIgASQJCyYBAX8Q3gIiAUHQ4i9qKAIABEAgABDaAwUgACABQYDaL2oQ/wILC4oMAQt/IwkhASMJQeANaiQJEN4CIgJB0OIvaiIHQQA2AgAgAUHYDWohBCABQfAMaiEAIAFBwApqIQMgAUHgCWohCCABQYAJaiEFIAdBAjYCACABQeAGaiIJQcIAEOwCIAFBwARqQcIAEOwCIAFBoAJqIgpBwgAQ7AIgASIHQcIAEOwCEOYDQRZGBH8gAEEwOwEAIAggACAAELkFEKoDIABBMDsBACAIQTBqIgQgACAAELkFEKoDIABBNDsBACAFIAAgABC5BRCqAyAAQTQ7AQAgBUEwaiIGIAAgABC5BRCqAyAAQfigASkAADcAACAAQYChASkAADcACCAAQYihASkAADcAECAAQZChASkAADcAGCAAQZihASkAADcAICAAQaChASkAADcAKCAAQaihASkAADcAMCAAQbChASkAADcAOCAAQUBrQbihASkAADcAACAAQcChASkAADcASCAAQcihASkAADcAUCAAQdChASkAADcAWCAAQdihASwAADoAYCADIAAgABC5BRCqAyAAQdmhASkAADcAACAAQeGhASkAADcACCAAQemhASkAADcAECAAQfGhASkAADcAGCAAQfmhASkAADcAICAAQYGiASkAADcAKCAAQYmiASkAADcAMCAAQZGiASkAADcAOCAAQUBrQZmiASkAADcAACAAQaGiASkAADcASCAAQamiASkAADcAUCAAQbGiASkAADcAWCAAQbmiASwAADoAYCADQTBqIAAgABC5BRCqAyAAQbqiASkAADcAACAAQcKiASkAADcACCAAQcqiASkAADcAECAAQdKiASkAADcAGCAAQdqiASkAADcAICAAQeKiASkAADcAKCAAQeqiASkAADcAMCAAQfKiASkAADcAOCAAQUBrQfqiASkAADcAACAAQYKjASkAADcASCAAQYqjASkAADcAUCAAQZKjASkAADcAWCAAQZqjASwAADoAYCADQeAAaiAAIAAQuQUQqgMgAEGbowEpAAA3AAAgAEGjowEpAAA3AAggAEGrowEpAAA3ABAgAEGzowEpAAA3ABggAEG7owEpAAA3ACAgAEHDowEpAAA3ACggAEHLowEpAAA3ADAgAEHTowEpAAA3ADggAEFAa0HbowEpAAA3AAAgAEHjowEpAAA3AEggAEHrowEpAAA3AFAgAEHzowEpAAA3AFggAEH7owEsAAA6AGAgA0GQAWogACAAELkFEKoDIABBsAkpAAA3AAAgAEG4CSkAADcACCAAQcAJKQAANwAQIABByAkpAAA3ABggAEHQCSkAADcAICAAQdgJKQAANwAoIABB4AkpAAA3ADAgAEHoCSkAADcAOCAAQUBrQfAJLAAAOgAAIAkgACAAELkFQRAQiwMgAEH8owEpAAA3AAAgAEGEpAEpAAA3AAggAEGMpAEpAAA3ABAgAEGUpAEpAAA3ABggAEGcpAEpAAA3ACAgAEGkpAEpAAA3ACggAEGspAEpAAA3ADAgAEG0pAEpAAA3ADggAEFAa0G8pAEpAAA3AAAgAEHEpAEpAAA3AEggAEHMpAEsAAA6AFAgCiAAIAAQuQVBEBCLAyAAQc2kASkAADcAACAAQdWkASkAADcACCAAQd2kASkAADcAECAAQeWkASkA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IiqnIgRqIgMgBElqIgsgKkIgiKciDGoiBCADIAEoAgitIAIoAgitfiIqpyIDaiIHIANJaiINICpCIIinIg5qIgMgByABKAIMrSACKAIErX4iKqciB2oiBiAHSWoiDyAqQiCIpyIQaiIHIAYgASgCEK0gAigCAK1+IiqnIgZqIhEgBklqIQYgACARNgIQIAkgBUkgCCAKSWogCyAISWogBCAMSWogDSAESWogAyAOSWogDyADSWogByAQSWogBiAHSWogBiAqQiCIpyIIaiIEIAhJaiIJIAQgASgCAK0gAigCFK1+IiqnIghqIgQgCElqIgogKkIgiKciC2oiCCAEIAEoAgStIAIoAhCtfiIqpyIEaiIDIARJaiIMICpCIIinIg1qIgQgAyABKAIIrSACKAIMrX4iKqciA2oiByADSWoiDiAqQiCIpyIPaiIDIAcgASgCDK0gAigCCK1+IiqnIgdqIgYgB0lqIhAgKkIgiKciEWoiByAGIAEoAhCtIAIoAgStfiIqpyIGaiIFIAZJaiISICpCIIinIhNqIgYgBSABKAIUrSACKAIArX4iKqciBWoiFCAFSWohBSAAIBQ2AhQgCiAJSSAIIAtJaiAMIAhJaiAEIA1JaiAOIARJaiADIA9JaiAQIANJaiAHIBFJaiASIAdJaiAGIBNJaiAFIAZJaiAFICpCIIinIghqIgQgCElqIgogBCABKAIArSACKAIYrX4iKqciCGoiBCAISWoiCyAqQiCIpyIMaiIIIAQgASgCBK0gAigCFK1+IiqnIgRqIgMgBElqIg0gKkIgiKciDmoiBCADIAEoAgitIAIoAhCtfiIqpyIDaiIHIANJaiIPICpCIIinIhBqIgMgByABKAIMrSACKAIMrX4iKqciB2oiBiAHSWoiESAqQiCIpyISaiIHIAYgASgCEK0gAigCCK1+IiqnIgZqIgUgBklqIhMgKkIgiKciFGoiBiAFIAEoAhStIAIoAgStfiIqpyIFaiIJIAVJaiIVICpCIIinIhZqIgUgCSABKAIYrSACKAIArX4iKqciCWoiFyAJSWohCSAAIBc2AhggCyAKSSAIIAxJaiANIAhJaiAEIA5JaiAPIARJaiADIBBJaiARIANJaiAHIBJJaiATIAdJaiAGIBRJaiAVIAZJaiAFIBZJaiAJIAVJaiAJICpCIIinIghqIgQgCElqIgsgBCABKAIArSACKAIcrX4iKqciCGoiBCAISWoiDCAqQiCIpyINaiIIIAQgASgCBK0gAigCGK1+IiqnIgRqIgMgBElqIg4gKkIgiKciD2oiBCADIAEoAgitIAIoAhStfiIqpyIDaiIHIANJaiIQICpCIIinIhFqIgMgByABKAIMrSACKAIQrX4iKqciB2oiBiAHSWoiEiAqQiCIpyITaiIHIAYgASgCEK0gAigCDK1+IiqnIgZqIgUgBklqIhQgKkIgiKciFWoiBiAFIAEoAhStIAIoAgitfiIqpyIFaiIJIAVJaiIWICpCIIinIhdqIgUgCSABKAIYrSACKAIErX4iKqciCWoiCiAJSWoiGCAqQiCIpyIZaiIJIAogASgCHK0gAigCAK1+IiqnIgpqIhogCklqIQogACAaNgIcIAwgC0kgCCANSWogDiAISWogBCAPSWogECAESWogAyARSWogEiADSWogByATSWogFCAHSWogBiAVSWogFiAGSWogBSAXSWogGCAFSWogCSAZSWogCiAJSWogCiAqQiCIpyIIaiIEIAhJaiIMIAQgASgCAK0gAigCIK1+IiqnIghqIgQgCElqIg0gKkIgiKciDmoiCCAEIAEoAgStIAIoAhytfiIqpyIEaiIDIARJaiIPICpCIIinIhBqIgQgAyABKAIIrSACKAIYrX4iKqciA2oiByADSWoiESAqQiCIpyISaiIDIAcgASgCDK0gAigCFK1+IiqnIgdqIgYgB0lqIhMgKkIgiKciFGoiByAGIAEoAhCtIAIoAhCtfiIqpyIGaiIFIAZJaiIVICpCIIinIhZqIgYgBSABKAIUrSACKAIMrX4iKqciBWoiCSAFSWoiFyAqQiCIpyIYaiIFIAkgASgCGK0gAigCCK1+IiqnIglqIgogCUlqIhkgKkIgiKciGmoiCSAKIAEoAhytIAIoAgStfiIqpyIKaiILIApJaiIbICpCIIinIhxqIgogCyABKAIgrSACKAIArX4iKqciC2oiHSALSWohCyAAIB02AiAgDSAMSSAIIA5JaiAPIAhJaiAEIBBJaiARIARJaiADIBJJaiATIANJaiAHIBRJaiAVIAdJaiAGIBZJaiAXIAZJaiAFIBhJaiAZIAVJaiAJIBpJaiAbIAlJaiAKIBxJaiALIApJaiALICpCIIinIghqIgQgCElqIg4gBCABKAIArSACKAIkrX4iKqciCGoiBCAISWoiDyAqQiCIpyIQaiIIIAQgASgCBK0gAigCIK1+IiqnIgRqIgMgBElqIhEgKkIgiKciEmoiBCADIAEoAgitIAIoAhytfiIqpyIDaiIHIANJaiITICpCIIinIhRqIgMgByABKAIMrSACKAIYrX4iKqciB2oiBiAHSWohByAGIAEoAhCtIAIoAhStfiIrpyIGaiIJIAZJIAcgKkIgiKciFWoiBmoiFiArQiCIpyIXaiIFIAkgASgCFK0gAigCEK1+IiqnIglqIgogCUlqIhggKkIgiKciGWoiCSAKIAEoAhitIAIoAgytfiIqpyIKaiILIApJaiIaICpCIIinIhtqIgogCyABKAIcrSACKAIIrX4iKqciC2oiDCALSWoiHCAqQiCIpyIdaiILIAwgASgCIK0gAigCBK1+IiqnIgxqIg0gDElqIh4gKkIgiKciH2oiDCANIAEoAiStIAIoAgCtfiIqpyINaiIgIA1JaiENIAAgIDYCJCAPIA5JIAggEElqIBEgCElqIAQgEklqIBMgBElqIAMgFElqIAcgA0lqIAYgFUlqIBYgBklqIAUgF0lqIBggBUlqIAkgGUlqIBogCUlqIAogG0lqIBwgCklqIAsgHUlqIB4gC0lqIAwgH0lqIA0gDElqIA0gKkIgiKciCGoiBCAISWoiDiAEIAEoAgCtIAIoAiitfiIqpyIIaiIEIAhJaiIPICpCIIinIhBqIgggBCABKAIErSACKAIkrX4iKqciBGoiAyAESWoiESAqQiCIpyISaiIEIAMgASgCCK0gAigCIK1+IiqnIgNqIgcgA0lqIhMgKkIgiKciFGoiAyAHIAEoAgytIAIoAhytfiIqpyIHaiIGIAdJaiIVICpCIIinIhZqIgcgBiABKAIQrSACKAIYrX4iKqciBmoiBSAGSWoiFyAqQiCIpyIYaiIGIAUgASgCFK0gAigCFK1+IiqnIgVqIgkgBUlqIhkgKkIgiKciGmoiBSAJIAEoAhitIAIoAhCtfiIqpyIJaiIKIAlJaiIbICpCIIinIhxqIgkgCiABKAIcrSACKAIMrX4iKqciCmoiCyAKSWoiHSAqQiCIpyIeaiIKIAsgASgCIK0gAigCCK1+IiqnIgtqIgwgC0lqIh8gKkIgiKciIGoiCyAMIAEoAiStIAIoAgStfiIqpyIMaiINIAxJaiIhICpCIIinIiJqIgwgDSABKAIorSACKAIArX4iKqciDWoiIyANSWohDSAAICM2AiggDyAOSSAIIBBJaiARIAhJaiAEIBJJaiATIARJaiADIBRJaiAVIANJaiAHIBZJaiAXIAdJaiAGIBhJaiAZIAZJaiAFIBpJaiAbIAVJaiAJIBxJaiAdIAlJaiAKIB5JaiAfIApJaiALICBJaiAhIAtJaiAMICJJaiANIAxJaiANICpCIIinIghqIgQgCElqIhIgBCABKAIArSACQSxqIggoAgCtfiIqpyIEaiIDIARJaiITICpCIIinIhRqIgQgAyABKAIErSACKAIorX4iKqciA2oiByADSWoiFSAqQiCIpyIWaiIDIAcgASgCCK0gAigCJK1+IiqnIgdqIgYgB0lqIhcgKkIgiKciGGoiByAGIAEoAgytIAIoAiCtfiIqpyIGaiIFIAZJaiIZICpCIIinIhpqIgkgBSABKAIQrSACKAIcrX4iKqciBmoiBSAGSWoiGyAqQiCIpyIcaiIKIAUgASgCFK0gAigCGK1+IiqnIgZqIgUgBklqIh0gKkIgiKciHmoiCyAFIAEoAhitIAIoAhStfiIqpyIGaiIFIAZJaiIfICpCIIinIiBqIgwgBSABKAIcrSACKAIQrX4iKqciBmoiBSAGSWoiISAqQiCIpyIiaiINIAUgASgCIK0gAigCDK1+IiqnIgZqIgUgBklqIiMgKkIgiKciJGoiDiAFIAEoAiStIAIoAgitfiIqpyIGaiIFIAZJaiIlICpCIIinIiZqIg8gBSABKAIorSACKAIErX4iKqciBmoiBSAGSWoiJyAqQiCIpyIoaiIQIAUgASgCLK0gAigCAK1+IiqnIgJqIgYgAklqIREgACAGNgIsIABBMGohKUEAIQYgCCECQQAhBSATIBJJIAQgFElqIBUgBElqIAMgFklqIBcgA0lqIAcgGElqIBkgB0lqIAkgGklqIBsgCUlqIAogHElqIB0gCklqIAsgHklqIB8gC0lqIAwgIElqICEgDElqIA0gIklqICMgDUlqIA4gJElqICUgDklqIA8gJklqICcgD0lqIBAgKElqIBEgEElqIBEgKkIgiKciA2oiBCADSWohByABIQMDQCAFIAcgBCADQQRqIgooAgCtIAIoAgCt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AkH/AXEgCxtqIQIgCiAOKAIANgIAIAggDygCADYCACABIAAgCiAIIAMgBCAFIAkgAhChBzYCAAwVCyAQIAIoAgA2AgAgCCAQKAIANgIAIAVBDGogASAIIAQgCRCiBwwUCyARIAEoAgA2AgAgEiACKAIANgIAIAogESgCADYCACAIIBIoAgA2AgAgASAAIAogCCADIAQgBUGovgFBsL4BEKEHNgIADBMLIBMgASgCADYCACAUIAIoAgA2AgAgCiATKAIANgIAIAggFCgCADYCACABIAAgCiAIIAMgBCAFQbC+AUG4vgEQoQc2AgAMEgsgFSACKAIANgIAIAggFSgCADYCACAFQQhqIAEgCCAEIAkQowcMEQsgFiACKAIANgIAIAggFigCADYCACAFQQhqIAEgCCAEIAkQpAcMEAsgFyACKAIANgIAIAggFygCADYCACAFQRxqIAEgCCAEIAkQpQcMDwsgGCACKAIANgIAIAggGCgCADYCACAFQRBqIAEgCCAEIAkQpgcMDgsgGSACKAIANgIAIAggGSgCADYCACAFQQRqIAEgCCAEIAkQpwcMDQsgGiACKAIANgIAIAggGigCADYCACABIAggBCAJEKgHDAwLIBsgAigCADYCACAIIBsoAgA2AgAgACAFQQhqIAEgCCAEIAkQqQcMCwsgHCABKAIANgIAIB0gAigCADYCACAKIBwoAgA2AgAgCCAdKAIANgIAIAEgACAKIAggAyAEIAVBuL4BQcO+ARChBzYCAAwKCyAeIAEoAgA2AgAgHyACKAIANgIAIAogHigCADYCACAIIB8oAgA2AgAgASAAIAogCCADIAQgBUHDvgFByL4BEKEHNgIADAkLICAgAigCADYCACAIICAoAgA2AgAgBSABIAggBCAJEKoHDAgLICEgASgCADYCACAiIAIoAgA2AgAgCiAhKAIANgIAIAggIigCADYCACABIAAgCiAIIAMgBCAFQci+AUHQvgEQoQc2AgAMBwsgIyACKAIANgIAIAggIygCADYCACAFQRhqIAEgCCAEIAkQqwcMBgsgACgCACgCFCEGICQgASgCADYCACAlIAIoAgA2AgAgCiAkKAIANgIAIAggJSgCADYCACAAIAogCCADIAQgBSAGQT9xQbwCahELAAwGCyAAQQhqIgYoAgAoAhghCyAGIAtB/wBxEQIA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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAGQRh0QRh1QSVrDlUWFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXAAEXBBcFFwYHFxcXChcXFxcODxAXFxcTFRcXFxcXFxcAAQIDAxcXARcIFxcJCxcMFw0XCxcXERIUFwsgDCACKAIANgIAIAggDCgCADYCACAAIAVBGGogASAIIAQgCRDABwwXCyANIAIoAgA2AgAgCCANKAIANgIAIAAgBUEQaiABIAggBCAJEMEHDBYLIABBCGoiBigCACgCDCELIAYgC0H/AHERAgAhBiAOIAEoAgA2AgAgDyACKAIANgIAIAYoAgAgBiAGLAALIgtBAEgiCRshAiAGKAIEIAtB/wFxIAkbQQJ0IAJqIQYgCiAOKAIANgIAIAggDygCADYCACABIAAgCiAIIAMgBCAFIAIgBhDCBzYCAAwVCyAQIAIoAgA2AgAgCCAQKAIANgIAIAVBDGogASAIIAQgCRDDBwwUCyARIAEoAgA2AgAgEiACKAIANgIAIAogESgCADYCACAIIBIoAgA2AgAgASAAIAogCCADIAQgBUHAwgBB4MIAEMIHNgIADBMLIBMgASgCADYCACAUIAIoAgA2AgAgCiATKAIANgIAIAggFCgCADYCACABIAAgCiAIIAMgBCAFQeDCAEGAwwAQwgc2AgAMEgsgFSACKAIANgIAIAggFSgCADYCACAFQQhqIAEgCCAEIAkQxAcMEQsgFiACKAIANgIAIAggFigCADYCACAFQQhqIAEgCCAEIAkQxQcMEAsgFyACKAIANgIAIAggFygCADYCACAFQRxqIAEgCCAEIAkQxgcMDwsgGCACKAIANgIAIAggGCgCADYCACAFQRBqIAEgCCAEIAkQxwcMDgsgGSACKAIANgIAIAggGSgCADYCACAFQQRqIAEgCCAEIAkQyAcMDQsgGiACKAIANgIAIAggGigCADYCACABIAggBCAJEMkHDAwLIBsgAigCADYCACAIIBsoAgA2AgAgACAFQQhqIAEgCCAEIAkQygcMCwsgHCABKAIANgIAIB0gAigCADYCACAKIBwoAgA2AgAgCCAdKAIANgIAIAEgACAKIAggAyAEIAVBgMMAQazDABDCBzYCAAwKCyAeIAEoAgA2AgAgHyACKAIANgIAIAogHigCADYCACAIIB8oAgA2AgAgASAAIAogCCADIAQgBUGwwwBBxMMAEMIHNgIADAkLICAgAigCADYCACAIICAoAgA2AgAgBSABIAggBCAJEMsHDAgLICEgASgCADYCACAiIAIoAgA2AgAgCiAhKAIANgIAIAggIigCADYCACABIAAgCiAIIAMgBCAFQdDDAEHwwwAQwgc2AgAMBwsgIyACKAIANgIAIAggIygCADYCACAFQRhqIAEgCCAEIAkQzAcMBgsgACgCACgCFCEGICQgASgCADYCACAlIAIoAgA2AgAgCiAkKAIANgIAIAggJSgCADYCACAAIAogCCADIAQgBSAGQT9xQbwCahELAAwGCyAAQQhqIgYoAgAoAhghCyAGIAtB/wBxEQIAIQYgJiABKAIANgIAICcgAigCADYCACAGKAIAIAYgBiwACyILQQBIIgkbIQIgBigCBCALQf8BcSAJG0ECdCACaiEGIAogJigCADYCACAIICcoAgA2AgAgASAAIAogCCADIAQgBSACIAYQwgc2AgAMBAsgKCACKAIANgIAIAggKCgCADYCACAFQRRqIAEgCCAEIAkQzQcMAwsgKSACKAIANgIAIAggKSgCADYCACAFQRRqIAEgCCAEIAkQzgcMAgsgCyACKAIANgIAIAggCygCADYCACABIAggBCAJEM8HDAELIAQgBCgCAEEEcjYCAAsgASgCAAshACAHJAkgAAssAEGw7AEsAABFBEBBsOwBEP0IBEAQvwdBkLQyQdDpATYCAAsLQZC0MigCAAssAEGg7AEsAABFBEBBoOwBEP0IBEAQvgdBjLQyQbDnATYCAAsLQYy0MigCAAssAEGQ7AEsAABFBEBBkOwBEP0IBEAQvQdBiLQyQZDlATYCAAsLQYi0MigCAAs/AEGI7AEsAABFBEBBiOwBEP0IBEBB/LMyQgA3AgBBhLQyQQA2AgBB/LMyQbTpAEG06QAQoAUQ1wgLC0H8szILPwBBgOwBLAAARQRAQYDsARD9CARAQfCzMkIANwIAQfizMkEANgIAQfCzMkGE6QBBhOkAEKAFENcICwtB8LMyCz8AQfjrASwAAEUEQEH46wEQ/QgEQEHkszJCADcCAEHsszJBADYCAEHkszJB4OgAQeDoABCgBRDXCAsLQeSzMgs/AEHw6wEsAABFBEBB8OsBEP0IBEBB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IAQgBBDUCAsgAiAEIAhraiEFIAQgCSwAAEEASAR/IAAoAgAFIAALIgdqIQgDQCABIAJHBEAgCCABEKsGIAhBAWohCCABQQFqIQEMAQsLIANBADoAACAFIAdqIAMQqwYgBCAKaiEBIAksAABBAEgEQCAAIAE2AgQFIAkgAToAAAsLCyALJAkgAAvHDAEDfyMJIQwjCUEQaiQJIAxBDGohCyAMIQogCSAABH8gAUG0tDIQuwYiASgCACgCLCEAIAsgASAAQf8AcUGgBGoRAAAgAiALKAIANgAAIAEoAgAoAiAhACAKIAEgAEH/AHFBoARqEQAAIAhBC2oiACwAAEEASAR/IAgoAgAhACALQQA6AAAgACALEKsGIAhBADYCBCAIBSALQQA6AAAgCCALEKsGIABBADoAACAICyEAIAgQ0AggACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgAEECdCAKakEANgIAIABBAWohAAwBCwsgChDNCCABKAIAKAIcIQAgCiABIABB/wBxQaAEahEAACAHQQtqIgAsAABBAEgEfyAHKAIAIQAgC0EAOgAAIAAgCxCrBiAHQQA2AgQgBwUgC0EAOgAAIAcgCxCrBiAAQQA6AAAgBwshACAHENAIIAAgCikCADcCACAAIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCDCEAIAMgASAAQf8AcRECADoAACABKAIAKAIQIQAgBCABIABB/wBxEQIAOgAAIAEoAgAoAhQhACAKIAEgAEH/AHFBoARqEQAAIAVBC2oiACwAAEEASAR/IAUoAgAhACALQQA6AAAgACALEKsGIAVBADYCBCAFBSALQQA6AAAgBSALEKsGIABBADoAACAFCyEAIAUQ0AggACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgAEECdCAKakEANgIAIABBAWohAAwBCwsgChDNCCABKAIAKAIYIQAgCiABIABB/wBxQaAEahEAACAGQQtqIgAsAABBAEgEfyAGKAIAIQAgC0EAOgAAIAAgCxCrBiAGQQA2AgQgBgUgC0EAOgAAIAYgCxCrBiAAQQA6AAAgBgshACAGENAIIAAgCikCADcCACAAIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCJCEAIAEgAEH/AHERAgAFIAFBrLQyELsGIgEoAgAoAiwhACALIAEgAEH/AHFBoARqEQAAIAIgCygCADYAACABKAIAKAIgIQAgCiABIABB/wBxQaAEahEAACAIQQtqIgAsAABBAEgEfyAIKAIAIQAgC0EAOgAAIAAgCxCrBiAIQQA2AgQgCAUgC0EAOgAAIAggCxCrBiAAQQA6AAAgCAshACAIENAIIAAgCikCADcCACAAIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCHCEAIAogASAAQf8AcUGgBGoRAAAgB0ELaiIALAAAQQBIBH8gBygCACEAIAtBADoAACAAIAsQqwYgB0EANgIEIAcFIAtBADoAACAHIAsQqwYgAEEAOgAAIAcLIQAgBxDQCCAAIAopAgA3AgAgACAKKAIINgIIQQAhAANAIABBA0cEQCAAQQJ0IApqQQA2AgAgAEEBaiEADAELCyAKEM0IIAEoAgAoAgwhACADIAEgAEH/AHERAgA6AAAgASgCACgCECEAIAQgASAAQf8AcRECADoAACABKAIAKAIUIQAgCiABIABB/wBxQaAEahEAACAFQQtqIgAsAABBAEgEfyAFKAIAIQAgC0EAOgAAIAAgCxCrBiAFQQA2AgQgBQUgC0EAOgAAIAUgCxCrBiAAQQA6AAAgBQshACAFENAIIAAgCikCADcCACAAIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCGCEAIAogASAAQf8AcUGgBGoRAAAgBkELaiIALAAAQQBIBH8gBigCACEAIAtBADoAACAAIAsQqwYgBkEANgIEIAYFIAtBADoAACAGIAsQqwYgAEEAOgAAIAYLIQAgBhDQCCAAIAopAgA3AgAgACAKKAIINgIIQQAhAANAIABBA0cEQCAAQQJ0IApqQQA2AgAgAEEBaiEADAELCyAKEM0IIAEoAgAoAiQhACABIABB/wBxEQIACzYCACAMJAkLsQEBBn8gAigCACAAKAIAIgUiB2siBEEBdCIDQQEgAxtBfyAEQf////8HSRshBiABKAIAIQgg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cQRAIANCADcCACADQQA2AgggAyABIAIQrwYgACADKAIAIAMgAywACyIBQQBIIgIbIAMoAgQgAUH/AXEgAhsQ3ggaIAMQzQgMAQsgByAFayAKSQRAIAAgByAFIApqIAdrIAUgBRDdCAsgCSwAAEEASAR/IAAoAgAFIAALIAVBAnRqIQQDQCABIAJHBEAgBCABELAGIARBBGohBCABQQRqIQEMAQsLIANBADYCACAEIAMQsAYgBSAKaiEBIAksAABBAEgEQCAAIAE2AgQFIAkgAToAAAsLCyALJAkgAAujDAEDfyMJIQwjCUEQaiQJIAxBDGohCyAMIQogCSAABH8gAUHEtDIQuwYiASgCACgCLCEAIAsgASAAQf8AcUGgBGoRAAAgAiALKAIANgAAIAEoAgAoAiAhACAKIAEgAEH/AHFBoARqEQAAIAhBC2oiACwAAEEASARAIAgoAgAhACALQQA2AgAgACALELAGIAhBADYCBAUgC0EANgIAIAggCxCwBiAAQQA6AAALIAgQ2wggCCAKKQIANwIAIAggCigCCDYCCEEAIQADQCAAQQNHBEAgAEECdCAKakEANgIAIABBAWohAAwBCwsgChDNCCABKAIAKAIcIQAgCiABIABB/wBxQaAEahEAACAHQQtqIgAsAABBAEgEQCAHKAIAIQAgC0EANgIAIAAgCxCwBiAHQQA2AgQFIAtBADYCACAHIAsQsAYgAEEAOgAACyAHENsIIAcgCikCADcCACAHIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCDCEAIAMgASAAQf8AcRECADYCACABKAIAKAIQIQAgBCABIABB/wBxEQIANgIAIAEoAgAoAhQhACAKIAEgAEH/AHFBoARqEQAAIAVBC2oiACwAAEEASAR/IAUoAgAhACALQQA6AAAgACALEKsGIAVBADYCBCAFBSALQQA6AAAgBSALEKsGIABBADoAACAFCyEAIAUQ0AggACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgAEECdCAKakEANgIAIABBAWohAAwBCwsgChDNCCABKAIAKAIYIQAgCiABIABB/wBxQaAEahEAACAGQQtqIgAsAABBAEgEQCAGKAIAIQAgC0EANgIAIAAgCxCwBiAGQQA2AgQFIAtBADYCACAGIAsQsAYgAEEAOgAACyAGENsIIAYgCikCADcCACAGIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCJCEAIAEgAEH/AHERAgAFIAFBvLQyELsGIgEoAgAoAiwhACALIAEgAEH/AHFBoARqEQAAIAIgCygCADYAACABKAIAKAIgIQAgCiABIABB/wBxQaAEahEAACAIQQtqIgAsAABBAEgEQCAIKAIAIQAgC0EANgIAIAAgCxCwBiAIQQA2AgQFIAtBADYCACAIIAsQsAYgAEEAOgAACyAIENsIIAggCikCADcCACAIIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCHCEAIAogASAAQf8AcUGgBGoRAAAgB0ELaiIALAAAQQBIBEAgBygCACEAIAtBADYCACAAIAsQsAYgB0EANgIEBSALQQA2AgAgByALELAGIABBADoAAAsgBxDbCCAHIAopAgA3AgAgByAKKAIINgIIQQAhAANAIABBA0cEQCAAQQJ0IApqQQA2AgAgAEEBaiEADAELCyAKEM0IIAEoAgAoAgwhACADIAEgAEH/AHERAgA2AgAgASgCACgCECEAIAQgASAAQf8AcRECADYCACABKAIAKAIUIQAgCiABIABB/wBxQaAEahEAACAFQQtqIgAsAABBAEgEfyAFKAIAIQAgC0EAOgAAIAAgCxCrBiAFQQA2AgQgBQUgC0EAOgAAIAUgCxCrBiAAQQA6AAAgBQshACAFENAIIAAgCikCADcCACAAIAooAgg2AghBACEAA0AgAEEDRwRAIABBAnQgCmpBADYCACAAQQFqIQAMAQsLIAoQzQggASgCACgCGCEAIAogASAAQf8AcUGgBGoRAAAgBkELaiIALAAAQQBIBEAgBigCACEAIAtBADYCACAAIAsQsAYgBkEANgIEBSALQQA2AgAgBiALELAGIABBADoAAAsgBhDbCCAGIAopAgA3AgAgBiAKKAIINgIIQQAhAANAIABBA0cEQCAAQQJ0IApqQQA2AgAgAEEBaiEADAELCyAKEM0IIAEoAgAoAiQhACABIABB/wBxEQIACzYCACAMJAkLugYBFH8j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EM0IIAAFIAAoAgAoAighASAKIAAgAUH/AHFBoARqEQAAIAMgCigCADYAACAAKAIAKAIcIQEgCyAAIAFB/wBxQaAEahEAACAIQQtqIgEsAABBAEgEfyAIKAIAIQEgCkEAOgAAIAEgChCrBiAIQQA2AgQgCAUgCkEAOgAAIAggChCrBiABQQA6AAAgCAshASAIENAIIAEgCykCADcCACABIAsoAgg2AghBACEBA0AgAUEDRwRAIAFBAnQgC2pBADYCACABQQFqIQEMAQsLIAsQzQggAAshASAAKAIAKAIMIQIgBCAAIAJB/wBxEQIAOgAAIAAoAgAoAhAhAiAFIAAgAkH/AHERAgA6AAAgASgCACgCFCECIAsgACACQf8AcUGgBGoRAAAgBkELaiICLAAAQQBIBH8gBigCACECIApBADoAACACIAoQqwYgBkEANgIEIAYFIApBADoAACAGIAoQqwYgAkEAOgAAIAYLIQIgBhDQCCACIAspAgA3AgAgAiALKAIINgIIQQAhAgNAIAJBA0cEQCACQQJ0IAtqQQA2AgAgAkEBaiECDAELCyALEM0IIAEoAgAoAhghASALIAAgAUH/AHFBoARqEQAAIAdBC2oiASwAAEEASAR/IAcoAgAhASAKQQA6AAAgASAKEKsGIAdBADYCBCAHBSAKQQA6AAAgByAKEKsGIAFBADoAACAHCyEBIAcQ0AggASALKQIANwIAIAEgCygCCDYCCEEAIQEDQCABQQNHBEAgAUECdCALakEANgIAIAFBAWohAQwBCwsgCxDNCCAAKAIAKAIkIQEgACABQf8AcRECAAUgAkGstDIQuwYhACABBH8gACgCACgCLCEBIAogACABQf8AcUGgBGoRAAAgAyAKKAIANgAAIAAoAgAoAiAhASALIAAgAUH/AHFBoARqEQAAIAhBC2oiASwAAEEASAR/IAgoAgAhASAKQQA6AAAgASAKEKsGIAhBADYCBCAIBSAKQQA6AAAgCCAKEKsGIAFBADoAACAICyEBIAgQ0AggASALKQIANwIAIAEgCygCCDYCCEEAIQEDQCABQQNHBEAgAUECdCALakEANgIAIAFBAWohAQwBCwsgCxDNCCAABSAAKAIAKAIoIQEgCiAAIAFB/wBxQaAEahEAACADIAooAgA2AAAgACgCACgCHCEBIAsgACABQf8AcUGg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CCgCACEAIApBADYCACAAIAoQsAYgCEEANgIEBSAKQQA2AgAgCCAKELAGIABBADoAAAsgCBDbCCAIIAspAgA3AgAgCCALKAIINgIIQQAhAANAIABBA0cEQCAAQQJ0IAtqQQA2AgAgAEEBaiEADAELCyALEM0ICyACKAIAKAIMIQAgBCACIABB/wBxEQIANgIAIAIoAgAoAhAhACAFIAIgAEH/AHERAgA2AgAgAigCACgCFCEAIAsgAiAAQf8AcUGgBGoRAAAgBkELaiIALAAAQQBIBH8gBigCACEAIApBADoAACAAIAoQqwYgBkEANgIEIAYFIApBADoAACAGIAoQqwYgAEEAOgAAIAYLIQAgBhDQCCAAIAspAgA3AgAgACALKAIINgIIQQAhAANAIABBA0cEQCAAQQJ0IAtqQQA2AgAgAEEBaiEADAELCyALEM0IIAIoAgAoAhghACALIAIgAEH/AHFBoARqEQAAIAdBC2oiACwAAEEASARAIAcoAgAhACAKQQA2AgAgACAKELAGIAdBADYCBAUgCkEANgIAIAcgChCwBiAAQQA6AAALIAcQ2wggByALKQIANwIAIAcgCygCCDYCCEEAIQADQCAAQQNHBEAgAEECdCALakEANgIAIABBAWohAAwBCwsgCxDNCCACKAIAKAIkIQAgAiAAQf8AcRECAAUgAkG8tDIQuwYhAiABBEAgAigCACgCLCEAIAogAiAAQf8AcUGgBGoRAAAgAyAKKAIANgAAIAIoAgAoAiAhACALIAIgAEH/AHFBoARqEQAAIAhBC2oiACwAAEEASARAIAgoAgAhACAKQQA2AgAgACAKELAGIAhBADYCBAUgCkEANgIAIAggChCwBiAAQQA6AAALIAgQ2wggCCALKQIANwIAIAggCygCCDYCCEEAIQADQCAAQQNHBEAgAEECdCALakEANgIAIABBAWohAAwBCwsgCxDNCAUgAigCACgCKCEAIAogAiAAQf8AcUGgBGoRAAAgAyAKKAIANgAAIAIoAgAoAhwhACALIAIgAEH/AHFBoARqEQAAIAhBC2oiACwAAEEASARAIAgoAgAhACAKQQA2AgAgACAKELAGIAhBADYCBAUgCkEANgIAIAggChCwBiAAQQA6AAALIAgQ2wggCCALKQIANwIAIAggCygCCDYCCEEAIQADQCAAQQNHBEAg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BwAgACwACQsMACAAIAFBDGoQyQgLIAAgAEIANwIAIABBADYCCCAAQfbIAUH2yAEQuQUQyggLIAAgAEIANwIAIABBADYCCCAAQfDIAUHwyAEQuQUQyggLEwAgAEHE9gA2AgAgAEEQahDNCAsMACAAEKIIIAAQ4gULDAAgACABQRBqEMkICyAAIABCADcCACAAQQA2AgggAEH89gBB/PYAEKAFENcICyAAIABCADcCACAAQQA2AgggAEHk9gBB5PYAEKAFENcICykAIAJBgAFJBH8gAUGQ4AAoAgAgAkEBdGouAQBxQf//A3FBAEcFQQALC0YAA0AgASACRwRAIAMgASgCAEGAAUkEf0GQ4AAoAgAgASgCAEEBdGovAQAFQQALOwEAIANBAmohAyABQQRqIQEMAQsLIAILSgADQAJAIAIgA0YEQCADIQIMAQsgAigCAEGAAUkEQCABQZDgACgCACACKAIAQQF0ai4BAHFB//8DcQ0BCyACQQRqIQIMAQsLIAILSgADQAJAIAIgA0YEQCADIQIMAQsgAigCAEGAAU8NACABQZDgACgCACACKAIAQQF0ai4BAHFB//8DcQRAIAJBBGohAgwCCwsLIAILHgAgAUGAAUkEf0GU4AAoAgAgAUECdGooAgAFIAELC0EAA0AgASACRwRAIAEgASgCACIAQYABSQR/QZTgACgCACABKAIAQQJ0aigCAAUgAAs2AgAgAUEEaiEBDAELCyACCx4AIAFBgAFJBH9BmOAAKAIAIAFBAnRqKAIABSABCwtBAANAIAEgAkcEQCABIAEoAgAiAEGAAUkEf0GY4AAoAgAgASgCAEECdGooAgAFIAALNgIAIAFBBGohAQwBCwsgAgsKACABQRh0QRh1CykAA0AgASACRwRAIAMgASwAADYCACADQQRqIQMgAUEBaiEBDAELCyACCxEAIAFB/wFxIAIgAUGAAUkbC04BAn8gAiABa0ECdiEFIAEhAANAIAAgAkcEQCAEIAAoAgAiBkH/AXEgAyAGQYABSRs6AAAgBEEBaiEEIABBBGohAAwBCwsgBUECdCABags2AEHU7AFBADYCAEHQ7AFB6PUANgIAQdjsAUEANgIAQdzsAUEAOgAAQdjsAUGQ4AAoAgA2AgALugkAQYTvAUEANgIAQYDvAUHU9QA2AgBBiO8BELUIQZDwAUIANwIA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ayEAIAFBQGshAQwBCwsDQCAAIAJIBEAgACABKAIANgIAIABBBGohACABQQRqIQEMAQsLBSADQQRrIQIDQCAAIAJIBEAgACABLAAAOgAAIAAgASwAAToAASAAIAEsAAI6AAIgACABLAADOgADIABBBGohACABQQRqIQEMAQsLCwNAIAAgA0gEQCAAIAEsAAA6AAAgAEEBaiEAIAFBAWohAQwBCwsgBAtgAQF/IAEgAEggACABIAJqSHEEQCAAIQMgASACaiEBIAAgAmohAANAIAJBAEoEQCACQQFrIQIgAEEBayIAIAFBAWsiASwAADoAAAwBCwsgAyEABSAAIAEgAhCBCRoLIAALmAIBBH8gACACaiEEIAFB/wFxIQEgAkHDAE4EQANAIABBA3EEQCAAIAE6AAAgAEEBaiEADAELCyAEQXxxIgVBQGohBiABQQh0IAFyIAFBEHRyIAFBGHRyIQMDQCAAIAZMBEAgACADNgIAIAAgAzYCBCAAIAM2AgggACADNgIMIAAgAzYCECAAIAM2AhQgACADNgIYIAAgAzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBQGshAAwBCwsDQCAAIAVIBEAgACADNgIAIABBBGohAAwBCwsLA0AgACAESARAIAAgAToAACAAQQFqIQAMAQsLIAQgAmsLTQECfyAAIwQoAgAiAmoiASACSCAAQQBKcSABQQBIcgRAEAEaQQwQB0F/DwsgARAtTARAIwQgATYCAAUgARAvRQRAQQwQB0F/DwsLIAILDQAgASAAQf8AcRECAAsSACABIAIgAEE/cUGAAWoRBwALFAAgASACIAMgAEE/cUHAAWoRAwALFgAgASACIAMgBCAAQQ9xQYACahEGAAsYACABIAIgAyAEIAUgAEEHcUGQAmoRDgALGAAgASACIAMgBCAFIABBH3FBmAJqEQkACxoAIAEgAiADIAQgBSAGIABBA3FBuAJqEQ8ACxoAIAEgAiADIAQgBSAGIABBP3FBvAJqEQsACxwAIAEgAiADIAQgBSAGIAcgAEEHcUH8AmoREAALHgAgASACIAMgBCAFIAYgByAIIABBD3FBhANqEQoACw4AIABBA3FBnANqEQwACxEAIAEgAEH/AHFBoANqEQgACxMAIAEgAiAAQf8AcUGgBGoRAAALFAAgASACIAMgAEEfcUGgBWoRAQALFgAgASACIAMgBCAAQQ9xQcAFahEEAAsYACABIAIgAyAEIAUgAEEHcUHQBWoRBQALGgAgASACIAMgBCAFIAYgAEEHcUHYBWoRDQALCABBABAAQQALCABBARAAQQALCABBAhAAQQALCABBAxAAQQALCABBBBAAQQALCABBBRAAQQALCABBBhAAQQALCABBBxAAQQALCABBCBAAQQALCABBCRAAQQALCABBChAAQQALBgBBCxAACwYAQQwQAAsGAEENEAALBgBBDhAACwYAQQ8QAAsGAEEQEAALBgBBERAACwYAQRIQAAsgACABIAIgAyAEIAWtIAatQiCGhCAAQQdxQZQDahERAAsgACABIAIgA60gBK1CIIaEIAUgBiAAQQNxQeAFahESAAsL1KwBOABBgAgLMqAqAADgIgAASCIAAEgiAADAIgAASCIAAEgiAABIIgAAGCIAAEgiAABIIgAA6CoAAOgqAEHACAsScCIAABgiAABIIgAA6CoAAEgiAEHgCAsicCIAAEgiAABIIgAASCIAAKAqAADoKgAAGCIAAEgiAADoKgBBkAkLFEJMUyBwcml2YXRlIGtleSBzZWVkAEGwCQtANzNFREE3NTMyOTlEN0Q0ODMzMzlEODA4MDlBMUQ4MDU1M0JEQTQwMkZGRkU1QkZFRkZGRkZGRkYwMDAwMDAwMQBBgAoLwAKYL4pCkUQ3cc/7wLWl27XpW8JWOfER8Vmkgj+S1V4cq5iqB9gBW4MSvoUxJMN9DFV0Xb5y/rHegKcG3Jt08ZvBwWmb5IZHvu/GncEPzKEMJG8s6S2qhHRK3KmwXNqI+XZSUT6YbcYxqMgnA7DHf1m/8wvgxkeRp9VRY8oGZykpFIUKtyc4IRsu/G0sTRMNOFNUcwpluwpqdi7JwoGFLHKSoei/oktmGqhwi0vCo1FsxxnoktEkBpnWhTUO9HCgahAWwaQZCGw3Hkx3SCe1vLA0swwcOUqq2E5Pypxb828uaO6Cj3RvY6V4FHjIhAgCx4z6/76Q62xQpPej+b7yeHHGMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXorLwBB0AwLFN4SBJUAAAAA////////////////AEHwDAvRAwIAAMADAADABAAAwAUAAMAGAADABwAAwAgAAMAJAADACgAAwAsAAMAMAADADQAAwA4AAMAPAADAEAAAwBEAAMASAADAEwAAwBQAAMAVAADAFgAAwBcAAMAYAADAGQAAwBoAAMAbAADAHAAAwB0AAMAeAADAHwAAwAAAALMBAADDAgAAwwMAAMMEAADDBQAAwwYAAMMHAADDCAAAwwkAAMMKAADDCwAAwwwAAMMNAADTDgAAww8AAMMAAAy7AQAMwwIADMMDAAzDBAAM0wAAAAD/////////////////////////////////////////////////////////////////AAECAwQFBgcICf////////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wBB0BALOAoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFEQAKABEREQAAAAAFAAAAAAAACQAAAAALAEGQEQshEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERERAEHBEQsBCwBByhELGBEACgoREREACgAAAgAJCwAAAAkACwAACwBB+xELAQwAQYcSCxUMAAAAAAwAAAAACQwAAAAAAAwAAAwAQbUSCwEOAEHBEgsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEHvEgsBEABB+xILHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBBshMLDhIAAAASEhIAAAAAAAAJAEHjEwsBCwBB7xMLFQoAAAAACgAAAAAJCwAAAAAACwAACwBBnRQLAQwAQakUC34MAAAAAAwAAAAACQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUZUISIZDQECAxFLHAwQBAsdEh4naG5vcHFiIAUGDxMUFRoIFgcoJBcYCQoOGx8lI4OCfSYqKzw9Pj9DR0pNWFlaW1xdXl9gYWNkZWZnaWprbHJzdHl6e3wAQbAVC4oOSWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3Jvbmcg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AAAABABBoNsACwEBAEGv2wALBQr/////AEHg2wALCWQtAADoLQAACQBB9NsACwEBAEGI3AALEgQAAAAAAAAAAgAAAJhrAAAABABBtNwACwT/////AEHk3AALD1AGAAAUAAAAQy5VVEYtOABBgN0ACwJkLgBBmN0ACwhfcIkA/wkvDwBBxN0ACwEFAEHr3QALBf//////AEHY3wALAwyTDABBkOAAC80BwBIAAMAWAADAHAAAAAAAAMAkAAABAAAAAgAAAAAAAADYJAAAAwAAAAQAAAABAAAABgAAAAEAAAABAAAAAgAAAAMAAAAHAAAABAAAAAUAAAABAAAACAAAAAIAAAAAAAAA4CQAAAUAAAAGAAAAAgAAAAkAAAACAAAAAgAAAAYAAAAHAAAACgAAAAgAAAAJAAAAAwAAAAsAAAAEAAAACAAAAAAAAADoJAAABwAAAAgAAAD4////+P///+gkAAAJAAAACgAAALgwAADMMAAACABB5eEAC5APJQAACwAAAAwAAAD4////+P///wAlAAANAAAADgAAAOgwAAD8MAAABAAAAAAAAAAYJQAADwAAABAAAAD8/////P///xglAAARAAAAEgAAABgxAAAsMQAABAAAAAAAAAAwJQAAEwAAABQAAAD8/////P///zAlAAAVAAAAFgAAAEgxAABcMQAAAAAAAEglAAAFAAAAFwAAAAMAAAAJAAAAAgAAAAIAAAAKAAAABwAAAAoAAAAIAAAACQAAAAMAAAAMAAAABQAAAAAAAABYJQAAAwAAABgAAAAEAAAABgAAAAEAAAABAAAACwAAAAMAAAAHAAAABAAAAAUAAAABAAAADQAAAAYAAAAAAAAAaCUAAAUAAAAZAAAABQAAAAkAAAACAAAAAgAAAAYAAAAHAAAACgAAAAwAAAANAAAABwAAAAsAAAAEAAAAAAAAAHglAAADAAAAGgAAAAYAAAAGAAAAAQAAAAEAAAACAAAAAwAAAAcAAAAOAAAADwAAAAgAAAAIAAAAAgAAAAAAAACIJQAAGwAAABwAAAAdAAAAAQAAAAMAAAAOAAAAAAAAAKglAAAeAAAAHwAAAB0AAAACAAAABAAAAA8AAAAAAAAAuCUAACAAAAAhAAAAHQAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAA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AABZAAAAGwBBjfsAC+RTKwAAVgAAAGEAAABYAAAAWQAAABkAAAAFAAAAAwAAAAcAAABQcml2YXRlS2V5AFBSSVZBVEVfS0VZX1NJWkUAZnJvbVNlZWQAZnJvbUJ5dGVzAGFnZ3JlZ2F0ZQBhZ2dyZWdhdGVJbnNlY3VyZQBzZXJpYWxpemUAc2lnbgBzaWduSW5zZWN1cmUAc2lnblByZWhhc2hlZABnZXRQdWJsaWNLZXkAU2lnbmF0dXJlAFNJR05BVFVSRV9TSVpFAGZyb21CeXRlc0FuZEFnZ3JlZ2F0aW9uSW5mbwBhZ2dyZWdhdGVTaWdzAGZyb21JbnNlY3VyZVNpZ25hdHVyZQBGcm9tSW5zZWN1cmVTaWduYXR1cmVBbmRJbmZvAHZlcmlmeQBnZXRBZ2dyZWdhdGlvbkluZm8Ac2V0QWdncmVnYXRpb25JbmZvAGRpdmlkZUJ5AEluc2VjdXJlU2lnbmF0dXJlAFB1YmxpY0tleQBQVUJMSUNfS0VZX1NJWkUAZ2V0RmluZ2VycHJpbnQAQWdncmVnYXRpb25JbmZvAGZyb21Nc2dIYXNoAGZyb21Nc2cAZnJvbUJ1ZmZlcnMAZ2V0UHVibGljS2V5cwBnZXRNZXNzYWdlSGFzaGVzAGdldEV4cG9uZW50cwBFeHRlbmRlZFByaXZhdGVLZXkARVhURU5ERURfUFJJVkFURV9LRVlfU0laRQBwcml2YXRlQ2hpbGQAcHVibGljQ2hpbGQAZ2V0VmVyc2lvbgBnZXREZXB0aABnZXRQYXJlbnRGaW5nZXJwcmludABnZXRDaGlsZE51bWJlcgBnZXRDaGFpbkNvZGUAZ2V0UHJpdmF0ZUtleQBnZXRFeHRlbmRlZFB1YmxpY0tleQBFeHRlbmRlZFB1YmxpY0tleQBWRVJTSU9OAEVYVEVOREVEX1BVQkxJQ19LRVlfU0laRQBDaGFpbkNvZGUAQ0hBSU5fQ09ERV9TSVpFAFRocmVzaG9sZABjcmVhdGUAc2lnbldpdGhDb2VmZmljaWVudABhZ2dyZWdhdGVVbml0U2lncwB2ZXJpZnlTZWNyZXRGcmFnbWVudABHUk9VUF9PUkRFUgBESEtleUV4Y2hhbmdlAE4xMWpzX3dyYXBwZXJzMTdQcml2YXRlS2V5V3JhcHBlckUATjExanNfd3JhcHBlcnM5SlNXcmFwcGVySU4zYmxzMTBQcml2YXRlS2V5RUVFAFBOMTFqc193cmFwcGVyczE3UHJpdmF0ZUtleVdyYXBwZXJFAFBLTjExanNfd3JhcHBlcnMxN1ByaXZhdGVLZXlXcmFwcGVyRQBpaQB2AHZpAE4xMGVtc2NyaXB0ZW4zdmFsRQBpaWkAaWlpaQBOMTFqc193cmFwcGVyczE2U2lnbmF0dXJlV3JhcHBlckUATjExanNfd3JhcHBlcnM5SlNXcmFwcGVySU4zYmxzOVNpZ25hdHVyZUVFRQBOMTFqc193cmFwcGVyczI0SW5zZWN1cmVTaWduYXR1cmVXcmFwcGVyRQBOMTFqc193cmFwcGVyczlKU1dyYXBwZXJJTjNibHMxN0luc2VjdXJlU2lnbmF0dXJlRUVFAE4xMWpzX3dyYXBwZXJzMTZQdWJsaWNLZXlXcmFwcGVyRQBOMTFqc193cmFwcGVyczlKU1dyYXBwZXJJTjNibHM5UHVibGljS2V5RUVFAFBOMTFqc193cmFwcGVyczE2U2lnbmF0dXJlV3JhcHBlckUAUEtOMTFqc193cmFwcGVyczE2U2lnbmF0dXJlV3JhcHBlckUATjExanNfd3JhcHBlcnMyMkFnZ3JlZ2F0aW9uSW5mb1dyYXBwZXJFAE4xMWpzX3dyYXBwZXJzOUpTV3JhcHBlcklOM2JsczE1QWdncmVnYXRpb25JbmZvRUVFAHZpaWkAUE4xMWpzX3dyYXBwZXJzMjRJbnNlY3VyZVNpZ25hdHVyZVdyYXBwZXJFAFBLTjExanNfd3JhcHBlcnMyNEluc2VjdXJlU2lnbmF0dXJlV3JhcHBlckUAaWlpaWkAUE4xMWpzX3dyYXBwZXJzMTZQdWJsaWNLZXlXcmFwcGVyRQBQS04xMWpzX3dyYXBwZXJzMTZQdWJsaWNLZXlXcmFwcGVyRQBQTjExanNfd3JhcHBlcnMyMkFnZ3JlZ2F0aW9uSW5mb1dyYXBwZXJFAFBLTjExanNfd3JhcHBlcnMyMkFnZ3JlZ2F0aW9uSW5mb1dyYXBwZXJFAE4xMWpzX3dyYXBwZXJzMjVFeHRlbmRlZFByaXZhdGVLZXlXcmFwcGVyRQBOMTFqc193cmFwcGVyczlKU1dyYXBwZXJJTjNibHMxOEV4dGVuZGVkUHJpdmF0ZUtleUVFRQBQTjExanNfd3JhcHBlcnMyNUV4dGVuZGVkUHJpdmF0ZUtleVdyYXBwZXJFAFBLTjExanNfd3JhcHBlcnMyNUV4dGVuZGVkUHJpdmF0ZUtleVdyYXBwZXJFAE4xMWpzX3dyYXBwZXJzMjRFeHRlbmRlZFB1YmxpY0tleVdyYXBwZXJFAE4xMWpzX3dyYXBwZXJzOUpTV3JhcHBlcklOM2JsczE3RXh0ZW5kZWRQdWJsaWNLZXlFRUUATjExanNfd3JhcHBlcnMxNkNoYWluQ29kZVdyYXBwZXJFAE4xMWpzX3dyYXBwZXJzOUpTV3JhcHBlcklOM2JsczlDaGFpbkNvZGVFRUUAUE4xMWpzX3dyYXBwZXJzMjRFeHRlbmRlZFB1YmxpY0tleVdyYXBwZXJFAFBLTjExanNfd3JhcHBlcnMyNEV4dGVuZGVkUHVibGljS2V5V3JhcHBlckUAUE4xMWpzX3dyYXBwZXJzMTZDaGFpbkNvZGVXcmFwcGVyRQBQS04xMWpzX3dyYXBwZXJzMTZDaGFpbkNvZGVXcmFwcGVyRQBOMTFqc193cmFwcGVyczE2VGhyZXNob2xkV3JhcHBlckUAUE4xMWpzX3dyYXBwZXJzMTZUaHJlc2hvbGRXcmFwcGVyRQBQS04xMWpzX3dyYXBwZXJzMTZUaHJlc2hvbGRXcmFwcGVyRQBpaWlpaWkATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQBVaW50OEFycmF5AGZyb20AQXJyYXkAcHVzaABsZW5ndGgAQ2Fubm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZHJlbiBmcm9tIHB1YmxpYyBrZXkAQkxTIEhEIHNlZWRDYW5ub3QgZ28gZnVydGhlciB0aGFuIDI1NSBsZXZlbHMAaGFzaGVzIGFuZCBwdWJLZXlzIHZlY3RvcnMgbXVzdCBiZSBvZiBzYW1lIHNpemUgYW5kIG5vbi1lbXB0eQBzaWdzIG11c3Qgbm90IGJlIGVtcHR5AFNpZ25hdHVyZSBtdXN0IGluY2x1ZGUgYWdncmVnYXRpb24gaW5mby4AQWdncmVnYXRpb25JbmZvIG11c3QgaGF2ZSBpdGVtcwBMZW5ndGhzIG9mIHZlY3RvcnMgbXVzdCBtYXRjaC4ATGVuZ3RocyBvZiBzdGQ6OnZlY3RvcnMgbXVzdCBtYXRjaC4ATXVzdCBoYXZlIGF0bGVhc3Qgb25lIHNpZ25hdHVyZXMgYW5kIGtleQBJbnZhbGlkIGFnZ3JlZ2F0aW9uIGluZm8uAENhbm5vdCBkaXZpZGUgYnkgYWdncmVnYXRlIHNpZ25hdHVyZSxtc2cvcGsgcGFpcnMgYXJlIG5vdCB1bmlxdWUATnVtYmVyIG9mIHB1YmxpYyBrZXlzIG11c3QgYmUgYXQgbGVhc3QgMQBLZXkgZGF0YSB0b28gbGFyZ2UsIG11c3QgYmUgc21hbGxlciB0aGFuIGdyb3VwIG9yZGVyAE51bWJlciBvZiBwcml2YXRlIGtleXMgbXVzdCBiZSBhdCBsZWFzdCAxAE51bWJlciBvZiBwdWJsaWMga2V5cyBtdXN0IGVxdWFsIG51bWJlciBvZiBwcml2YXRlIGtleXMATnVtYmVyIG9mIGtleXMgbXVzdCBiZSBhdCBsZWFzdCAxAGNvcmVfaW5pdCgpIGZhaWxlZABlcF9wYXJhbV9zZXRfYW55X3BhaXJmKCkgZmFpbGVkAExpYnJhcnkgbm90IGluaXRpYWxpemVkIHByb3Blcmx5LiBDYWxsIEJMUzo6SW5pdCgpAFJlbGljIGxpYnJhcnkgZXJyb3IAa2V5ZGF0YSBub3QgaW5pdGlhbGl6ZWQASW52YWxpZCBpbnB1dCwgYWxsIHN0ZDo6dmVjdG9ycyBtdXN0IGhhdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBzYW1lIGxlbmd0aABhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAEludmFsaWQgZW50cmllcwBtYXA6OmF0OiAga2V5IG5vdCBmb3VuZABUaHJlc2hvbGQgcGFyYW1ldGVyIFQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIE4AcGxheWVyIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyAFQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAUGxheWVyIGluZGV4IG11c3QgYmUgcG9zaXRpdmUATXVzdCBub3QgaGF2ZSBkdXBsaWNhdGUgcGxheWVyIGluZGljZXMAUGxheWVyIGluZGljZXMgY2FuJ3QgYmUgZXF1aXYuIG1vZCBncm91cCBvcmRlcgAvZGV2L3VyYW5kb20AL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9yYW5kL3JlbGljX3JhbmRfY29yZS5jAC9ob21lL2FudG9uL2Rhc2gvYmxzLXNpZ25hdHVyZXMvY29udHJpYi9yZWxpYy9zcmMvcmFuZC9yZWxpY19yYW5kX2hhc2guYwAvaG9tZS9hbnRvbi9kYXNoL2Jscy1zaWduYXR1cmVzL2NvbnRyaWIvcmVsaWMvc3JjL2JuL3JlbGljX2JuX21lbS5jAC9ob21lL2FudG9uL2Rhc2gvYmxzLXNpZ25hdHVyZXMvY29udHJpYi9yZWxpYy9zcmMvYm4vcmVsaWNfYm5fbW9kLmMAL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9ibi9yZWxpY19ibl9yZWMuYwAvaG9tZS9hbnRvbi9kYXNoL2Jscy1zaWduYXR1cmVzL2NvbnRyaWIvcmVsaWMvc3JjL2JuL3JlbGljX2JuX3V0aWwuYwAvaG9tZS9hbnRvbi9kYXNoL2Jscy1zaWduYXR1cmVzL2NvbnRyaWIvcmVsaWMvc3JjL2R2L3JlbGljX2R2X3V0aWwuYwAvaG9tZS9hbnRvbi9kYXNoL2Jscy1zaWduYXR1cmVzL2NvbnRyaWIvcmVsaWMvc3JjL2ZwL3JlbGljX2ZwX3ByaW1lLmMAL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9mcC9yZWxpY19mcF91dGlsLmMAL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9mcHgvcmVsaWNfZnB4X3V0aWwuYwAxN0YxRDNBNzMxOTdENzk0MjY5NTYzOEM0RkE5QUMwRkMzNjg4QzRGOTc3NEI5MDVBMTRFM0EzRjE3MUJBQzU4NkM1NUU4M0ZGOTdBMUFFRkZCM0FGMDBBREIyMkM2QkIAMDhCM0Y0ODFFM0FBQTBGMUEwOUUzMEVENzQxRDhBRTRGQ0Y1RTA5NUQ1RDAwQUY2MDBEQjE4Q0IyQzA0QjNFREQwM0NDNzQ0QTI4ODhBRTQwQ0FBMjMyOTQ2QzVFN0UxADM5NkM4QzAwNTU1NUUxNTY4QzAwQUFBQjAwMDBBQUFCADczRURBNzUzMjk5RDdENDgzMzM5RDgwODA5QTFEODA0QTc3ODAwMDFGRkZDQjdGQ0ZGRkZGRkZFMDAwMDAwMDEAL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9lcC9yZWxpY19lcF9wYXJhbS5jAC9ob21lL2FudG9uL2Rhc2gvYmxzLXNpZ25hdHVyZXMvY29udHJpYi9yZWxpYy9zcmMvZXAvcmVsaWNfZXBfdXRpbC5jADAyNEFBMkIyRjA4RjBBOTEyNjA4MDUyNzJEQzUxMDUxQzZFNDdBRDRGQTQwM0IwMkI0NTEwQjY0N0FFM0QxNzcwQkFDMDMyNkE4MDVCQkVGRDQ4MDU2QzhDMTIxQkRCOAAxM0UwMkI2MDUyNzE5RjYwN0RBQ0QzQTA4ODI3NEY2NTU5NkJEMEQwOTkyMEI2MUFCNURBNjFCQkRDN0Y1MDQ5MzM0Q0YxMTIxMzk0NUQ1N0U1QUM3RDA1NUQwNDJCN0UAMENFNUQ1Mjc3MjdENkUxMThDQzlDREM2REEyRTM1MUFBREZEOUJBQThDQkREM0E3NkQ0MjlBNjk1MTYwRDEyQzkyM0FDOUNDM0JBQ0EyODlFMTkzNTQ4NjA4QjgyODAxADA2MDZDNEEwMkVBNzM0Q0MzMkFDRDJCMDJCQzI4Qjk5Q0IzRTI4N0U4NUE3NjNBRjI2NzQ5MkFCNTcyRTk5QUIzRjM3MEQyNzVDRUMxREExQUFBOTA3NUZGMDVGNzlCRQBCRTMyQ0U1RkJFRUQ5Q0EzNzREMzhDMEVENDFFRUZENUJCNjc1Mjc3Q0RGMTJEMTFCQzJGQjAyNkM0MTQwMDA0NUMwM0ZGRkZGRkZERkZGRAA1RjE5NjcyRkRGNzZDRTUxQkE2OUM2MDc2QTBGNzdFQUREQjNBOTNCRTZGODk2ODhERTE3RDgxMzYyMEEwMDAyMkUwMUZGRkZGRkZFRkZGRQAvaG9tZS9hbnRvbi9kYXNoL2Jscy1zaWduYXR1cmVzL2NvbnRyaWIvcmVsaWMvc3JjL2VweC9yZWxpY19lcDJfY3VydmUuYwAvaG9tZS9hbnRvbi9kYXNoL2Jscy1zaWduYXR1cmVzL2NvbnRyaWIvcmVsaWMvc3JjL2VweC9yZWxpY19lcDJfbWFwLmMAL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9lcHgvcmVsaWNfZXAyX3V0aWwuYwAvaG9tZS9hbnRvbi9kYXNoL2Jscy1zaWduYXR1cmVzL2NvbnRyaWIvcmVsaWMvc3JjL21kL3JlbGljX21kX3NoYTI1Ni5jAC9ob21lL2FudG9uL2Rhc2gvYmxzLXNpZ25hdHVyZXMvY29udHJpYi9yZWxpYy9zcmMvYm4vcmVsaWNfYm5fZGl2LmMAL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9ibi9yZWxpY19ibl9zcnQuYwBGQVRBTCBFUlJPUiBpbiAlczolZAoAL2hvbWUvYW50b24vZGFzaC9ibHMtc2lnbmF0dXJlcy9jb250cmliL3JlbGljL3NyYy9mcC9yZWxpY19mcF9wYXJhbS5jAHZvaWQAYm9vbABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAZmxvYXQAZG91YmxlAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nIGRvdWJsZT4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAAECBAcDBgUAaW5maW5pdHkALSsgICAwWDB4AChudWxsKQAtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOAC4ATENfQUxMAExBTkcAQy5VVEYtOABQT1NJWABNVVNMX0xPQ1BBVEgATlN0M19fMjhpb3NfYmFzZUUATlN0M19fMjliYXNpY19pb3NJY05TXzExY2hhcl90cmFpdHNJY0VFRUUATlN0M19fMjliYXNpY19pb3NJd05TXzExY2hhcl90cmFpdHNJd0VFRUUATlN0M19fMjE1YmFzaWNfc3RyZWFtYnVmSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAE5TdDNfXzIxNWJhc2ljX3N0cmVhbWJ1Zkl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRQBOU3QzX18yMTNiYXNpY19pc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAE5TdDNfXzIxM2Jhc2ljX2lzdHJlYW1Jd05TXzExY2hhcl90cmFpdHNJd0VFRUUATlN0M19fMjEzYmFzaWNfb3N0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQBOU3QzX18yMTNiYXNpY19vc3RyZWFtSXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFAE5TdDNfXzIxMV9fc3Rkb3V0YnVmSXdFRQBOU3QzX18yMTFfX3N0ZG91dGJ1ZkljRUUAdW5zdXBwb3J0ZWQgbG9jYWxlIGZvciBzdGFuZGFyZCBpbnB1dABOU3QzX18yMTBfX3N0ZGluYnVmSXdFRQBOU3QzX18yMTBfX3N0ZGluYnVmSWNFRQBOU3QzX18yN2NvbGxhdGVJY0VFAE5TdDNfXzI2bG9jYWxlNWZhY2V0RQBOU3QzX18yN2NvbGxhdGVJd0VFACVwAEMATlN0M19fMjdudW1fZ2V0SWNOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yOV9fbnVtX2dldEljRUUATlN0M19fMjE0X19udW1fZ2V0X2Jhc2VFAE5TdDNfXzI3bnVtX2dldEl3TlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjlfX251bV9nZXRJd0VFACVwAAAAAEwAbGwAJQAAAAAAbABOU3QzX18yN251bV9wdXRJY05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzI5X19udW1fcHV0SWNFRQBOU3QzX18yMTRfX251bV9wdXRfYmFzZUUATlN0M19fMjdudW1fcHV0SXdOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yOV9fbnVtX3B1dEl3RUUAJUg6JU06JVMAJW0vJWQvJXkAJUk6JU06JVMgJXAAJWEgJWIgJWQgJUg6JU06JVMgJVkAQU0AUE0ASmFudWFyeQBGZWJydWFyeQBNYXJjaABBcHJpbABNYXkASnVuZQBKdWx5AEF1Z3VzdABTZXB0ZW1iZXIAT2N0b2JlcgBOb3ZlbWJlcgBEZWNlbWJlcgBKYW4ARmViAE1hcgBBcHIASnVuAEp1bABBdWcAU2VwAE9jdABOb3YARGVjAFN1bmRheQBNb25kYXkAVHVlc2RheQBXZWRuZXNkYXkAVGh1cnNkYXkARnJpZGF5AFNhdHVyZGF5AFN1bgBNb24AVHVlAFdlZABUaHUARnJpAFNhdAAlbS8lZC8leSVZLSVtLSVkJUk6JU06JVMgJXAlSDolTSVIOiVNOiVTJUg6JU06JVNOU3QzX18yOHRpbWVfZ2V0SWNOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUljRUUATlN0M19fMjl0aW1lX2Jhc2VFAE5TdDNfXzI4dGltZV9nZXRJd05TXzE5aXN0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAE5TdDNfXzIyMF9fdGltZV9nZXRfY19zdG9yYWdlSXdFRQBOU3QzX18yOHRpbWVfcHV0SWNOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yMTBfX3RpbWVfcHV0RQBOU3QzX18yOHRpbWVfcHV0SXdOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yMTBtb25leXB1bmN0SWNMYjBFRUUATlN0M19fMjEwbW9uZXlfYmFzZUUATlN0M19fMjEwbW9uZXlwdW5jdEljTGIxRUVFAE5TdDNfXzIxMG1vbmV5cHVuY3RJd0xiMEVFRQBOU3QzX18yMTBtb25leXB1bmN0SXdMYjFFRUUAMDEyMzQ1Njc4OQAlTGYATlN0M19fMjltb25leV9nZXRJY05TXzE5aXN0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzIxMV9fbW9uZXlfZ2V0SWNFRQAwMTIzNDU2Nzg5AE5TdDNfXzI5bW9uZXlfZ2V0SXdOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yMTFfX21vbmV5X2dldEl3RUUAJS4wTGYATlN0M19fMjltb25leV9wdXRJY05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzIxMV9fbW9uZXlfcHV0SWNFRQBOU3QzX18yOW1vbmV5X3B1dEl3TlNfMTlvc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjExX19tb25leV9wdXRJd0VFAE5TdDNfXzI4bWVzc2FnZXNJY0VFAE5TdDNfXzIxM21lc3NhZ2VzX2Jhc2VFAE5TdDNfXzIxN19fd2lkZW5fZnJvbV91dGY4SUxtMzJFRUUATlN0M19fMjdjb2RlY3Z0SURpYzExX19tYnN0YXRlX3RFRQBOU3QzX18yMTJjb2RlY3Z0X2Jhc2VFAE5TdDNfXzIxNl9fbmFycm93X3RvX3V0ZjhJTG0zMkVFRQBOU3QzX18yOG1lc3NhZ2VzSXdFRQBOU3QzX18yN2NvZGVjdnRJY2MxMV9fbWJzdGF0ZV90RUUATlN0M19fMjdjb2RlY3Z0SXdjMTFfX21ic3RhdGVfdEVFAE5TdDNfXzI3Y29kZWN2dElEc2MxMV9fbWJzdGF0ZV90RUUATlN0M19fMjZsb2NhbGU1X19pbXBFAE5TdDNfXzI1Y3R5cGVJY0VFAE5TdDNfXzIxMGN0eXBlX2Jhc2VFAE5TdDNfXzI1Y3R5cGVJd0VFAGZhbHNlAHRydWUATlN0M19fMjhudW1wdW5jdEljRUUATlN0M19fMjhudW1wdW5jdEl3RUUATlN0M19fMjE0X19zaGFyZWRfY291bnRFAHRlcm1pbmF0aW5nIHdpdGggJXMgZXhjZXB0aW9uIG9mIHR5cGUgJXM6ICVzAHRlcm1pbmF0aW5nIHdpdGggJXMgZXhjZXB0aW9uIG9mIHR5cGUgJXMAdGVybWluYXRpbmcgd2l0aCAlcyBmb3JlaWduIGV4Y2VwdGlvbgB0ZXJtaW5hdGluZwB1bmNhdWdodABTdDlleGNlcHRpb24ATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAU3Q5dHlwZV9pbmZvAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAcHRocmVhZF9vbmNlIGZhaWx1cmUgaW4gX19jeGFfZ2V0X2dsb2JhbHNfZmFzdCgpAGNhbm5vdCBjcmVhdGUgcHRocmVhZCBrZXkgZm9yIF9fY3hhX2dldF9nbG9iYWxzKCkAY2Fubm90IHplcm8gb3V0IHRocmVhZCB2YWx1ZSBmb3IgX19jeGFfZ2V0X2dsb2JhbHMoKQB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgcmV0dXJuZWQAU3QxMWxvZ2ljX2Vycm9yAFN0MTJsZW5ndGhfZXJyb3IAU3QxMm91dF9vZl9yYW5nZQBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAHYARG4AYgBjAGgAYQBzAHQAaQBqAG0AZgBkAE4xMF9fY3h4YWJpdjEyMV9fdm1pX2NsYXNzX3R5cGVfaW5mb0U=";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function mergeMemory(newBuffer){var oldBuffer=Module["buffer"];if(newBuffer.byteLength<oldBuffer.byteLength){err("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here")}var oldView=new Int8Array(oldBuffer);var newView=new Int8Array(newBuffer);newView.set(oldView);updateGlobalBuffer(newBuffer);updateGlobalBufferViews()}function getBinary(){try{if(Module["wasmBinary"]){return new Uint8Array(Module["wasmBinary"])}var binary=tryParseAsDataURI(wasmBinaryFile);if(binary){return binary}if(Module["readBinary"]){return Module["readBinary"](wasmBinaryFile)}else{throw"sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)"}}catch(err){abort(err)}}function createWasm(env){if(typeof WebAssembly!=="object"){err("no native wasm support detected");return false}if(!(Module["wasmMemory"]instanceof WebAssembly.Memory)){err("no native wasm Memory in use");return false}env["memory"]=Module["wasmMemory"];var info={"global":{"NaN":NaN,"Infinity":Infinity},"global.Math":Math,"env":env,"asm2wasm":asm2wasmImports,"parent":Module};function receiveInstance(instance,module){var exports=instance.exports;if(exports.memory)mergeMemory(exports.memory);Module["asm"]=exports;removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}var instance;var module;try{module=new WebAssembly.Module(getBinary());instance=new WebAssembly.Instance(module,info)}catch(e){err("failed to compile wasm module: "+e);if(e.toString().indexOf("imported Memory with incompatible size")>=0){err("Memory size incompatibility issues may be due to changing TOTAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set TOTAL_MEMORY at runtime to something smaller than it was at compile time).")}return false}receiveInstance(instance,module);return Module["asm"]}var wasmReallocBuffer=(function(size){var PAGE_MULTIPLE=65536;size=alignUp(size,PAGE_MULTIPLE);var old=Module["buffer"];var oldSize=old.byteLength;try{var result=Module["wasmMemory"].grow((size-oldSize)/65536);if(result!==(-1|0)){return Module["buffer"]=Module["wasmMemory"].buffer}else{return null}}catch(e){return null}});Module["reallocBuffer"]=(function(size){return wasmReallocBuffer(size)});Module["asm"]=(function(global,env,providedBuffer){if(!env["table"]){var TABLE_SIZE=Module["wasmTableSize"];var MAX_TABLE_SIZE=Module["wasmMaxTableSize"];if(typeof WebAssembly==="object"&&typeof WebAssembly.Table==="function"){if(MAX_TABLE_SIZE!==undefined){env["table"]=new WebAssembly.Table({"initial":TABLE_SIZE,"maximum":MAX_TABLE_SIZE,"element":"anyfunc"})}else{env["table"]=new WebAssembly.Table({"initial":TABLE_SIZE,element:"anyfunc"})}}else{env["table"]=new Array(TABLE_SIZE)}Module["wasmTable"]=env["table"]}if(!env["__memory_base"]){env["__memory_base"]=Module["STATIC_BASE"]}if(!env["__table_base"]){env["__table_base"]=0}var exports=createWasm(env);return exports});STATIC_BASE=GLOBAL_BASE;__ATINIT__.push({func:(function(){__GLOBAL__I_000101()})},{func:(function(){__GLOBAL__sub_I_jsbindings_cpp()})},{func:(function(){__GLOBAL__sub_I_bls_cpp()})},{func:(function(){__GLOBAL__sub_I_bind_cpp()})},{func:(function(){__GLOBAL__sub_I_iostream_cpp()})});var STATIC_BUMP=826384;Module["STATIC_BASE"]=STATIC_BASE;Module["STATIC_BUMP"]=STATIC_BUMP;var tempDoublePtr=827392;function ___cxa_allocate_exception(size){return _malloc(size)}function ___cxa_free_exception(ptr){try{return _free(ptr)}catch(e){}}var EXCEPTIONS={last:0,caught:[],infos:{},deAdjust:(function(adjusted){if(!adjusted||EXCEPTIONS.infos[adjusted])return adjusted;for(var key in EXCEPTIONS.infos){var ptr=+key;var adj=EXCEPTIONS.infos[ptr].adjusted;var len=adj.length;for(var i=0;i<len;i++){if(adj[i]===adjusted){return ptr}}}return adjusted}),addRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount++}),decRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];assert(info.refcount>0);info.refcount--;if(info.refcount===0&&!info.rethrown){if(info.destructor){Module["dynCall_vi"](info.destructor,ptr)}delete EXCEPTIONS.infos[ptr];___cxa_free_exception(ptr)}}),clearRef:(function(ptr){if(!ptr)return;var info=EXCEPTIONS.infos[ptr];info.refcount=0})};function ___cxa_begin_catch(ptr){var info=EXCEPTIONS.infos[ptr];if(info&&!info.caught){info.caught=true;__ZSt18uncaught_exceptionv.uncaught_exception--}if(info)info.rethrown=false;EXCEPTIONS.caught.push(ptr);EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));return ptr}function ___resumeException(ptr){if(!EXCEPTIONS.last){EXCEPTIONS.last=ptr}throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___cxa_find_matching_catch(){var thrown=EXCEPTIONS.last;if(!thrown){return(setTempRet0(0),0)|0}var info=EXCEPTIONS.infos[thrown];var throwntype=info.type;if(!throwntype){return(setTempRet0(0),thrown)|0}var typeArray=Array.prototype.slice.call(arguments);var pointer=Module["___cxa_is_pointer_type"](throwntype);if(!___cxa_find_matching_catch.buffer)___cxa_find_matching_catch.buffer=_malloc(4);HEAP32[___cxa_find_matching_catch.buffer>>2]=thrown;thrown=___cxa_find_matching_catch.buffer;for(var i=0;i<typeArray.length;i++){if(typeArray[i]&&Module["___cxa_can_catch"](typeArray[i],throwntype,thrown)){thrown=HEAP32[thrown>>2];info.adjusted.push(thrown);return(setTempRet0(typeArray[i]),thrown)|0}}thrown=HEAP32[thrown>>2];return(setTempRet0(throwntype),thrown)|0}function ___cxa_throw(ptr,type,destructor){EXCEPTIONS.infos[ptr]={ptr:ptr,adjusted:[ptr],type:type,destructor:destructor,refcount:0,caught:false,rethrown:false};EXCEPTIONS.last=ptr;if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exception=1}else{__ZSt18uncaught_exceptionv.uncaught_exception++}throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___cxa_uncaught_exception(){return!!__ZSt18uncaught_exceptionv.uncaught_exception}function ___gxx_personality_v0(){}function ___lock(){}function ___setErrNo(value){if(Module["___errno_location"])HEAP32[Module["___errno_location"]()>>2]=value;return value}function ___map_file(pathname,size){___setErrNo(1);return-1}var PATH={splitPath:(function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)}),normalizeArray:(function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1)}else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift("..")}}return parts}),normalize:(function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter((function(p){return!!p})),!isAbsolute).join("/");if(!path&&!isAbsolute){path="."}if(path&&trailingSlash){path+="/"}return(isAbsolute?"/":"")+path}),dirname:(function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return"."}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir}),basename:(function(path){if(path==="/")return"/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)}),extname:(function(path){return PATH.splitPath(path)[3]}),join:(function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))}),join2:(function(l,r){return PATH.normalize(l+"/"+r)}),resolve:(function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/"}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter((function(p){return!!p})),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."}),relative:(function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")})};var TTY={ttys:[],init:(function(){}),shutdown:(function(){}),register:(function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)}),stream_ops:{open:(function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}stream.tty=tty;stream.seekable=false}),close:(function(stream){stream.tty.ops.flush(stream.tty)}),flush:(function(stream){stream.tty.ops.flush(stream.tty)}),read:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead}),write:(function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(length){stream.node.timestamp=Date.now()}return i})},default_tty_ops:{get_char:(function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=new Buffer(BUFSIZE);var bytesRead=0;var isPosixPlatform=process.platform!="win32";var fd=process.stdin.fd;if(isPosixPlatform){var usingDevice=false;try{fd=fs.openSync("/dev/stdin","r");usingDevice=true}catch(e){}}try{bytesRead=fs.readSync(fd,buf,0,BUFSIZE,null)}catch(e){if(e.toString().indexOf("EOF")!=-1)bytesRead=0;else throw e}if(usingDevice){fs.closeSync(fd)}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8")}else{result=null}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n"}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n"}}if(!result){return null}tty.input=intArrayFromString(result,true)}return tty.input.shift()}),put_char:(function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}}),flush:(function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}})},default_tty1_ops:{put_char:(function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}}),flush:(function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}})}};var MEMFS={ops_table:null,mount:(function(mount){return MEMFS.createNode(null,"/",16384|511,0)}),createNode:(function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}}}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node}return node}),getFileDataAsRegularArray:(function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents}),getFileDataAsTypedArray:(function(node){if(!node.contents)return new Uint8Array;if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)}),expandFileStorage:(function(node,newCapacity){if(node.contents&&node.contents.subarray&&newCapacity>node.contents.length){node.contents=MEMFS.getFileDataAsRegularArray(node);node.usedBytes=node.contents.length}if(!node.contents||node.contents.subarray){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return}if(!node.contents&&newCapacity>0)node.contents=[];while(node.contents.length<newCapacity)node.contents.push(0)}),resizeFileStorage:(function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize}),node_ops:{getattr:(function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}}),lookup:(function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT]}),mknod:(function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)}),rename:(function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}}}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=new_dir}),unlink:(function(parent,name){delete parent.contents[name]}),rmdir:(function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}delete parent.contents[name]}),readdir:(function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries}),symlink:(function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node}),readlink:(function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return node.link})},stream_ops:{read:(function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size}),write:(function(stream,buffer,offset,length,position,canOwn){if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position}),allocate:(function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<stream.node.usedBytes){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=_malloc(length);if(!ptr){throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)}buffer.set(contents,ptr)}return{ptr:ptr,allocated:allocated}}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0})}};var IDBFS={dbs:{},indexedDB:(function(){if(typeof indexedDB!=="undefined")return indexedDB;var ret=null;if(typeof window==="object")ret=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;assert(ret,"IDBFS used, but indexedDB not supported");return ret}),DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:(function(mount){return MEMFS.mount.apply(null,arguments)}),syncfs:(function(mount,populate,callback){IDBFS.getLocalSet(mount,(function(err,local){if(err)return callback(err);IDBFS.getRemoteSet(mount,(function(err,remote){if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,callback)}))}))}),getDB:(function(name,callback){var db=IDBFS.dbs[name];if(db){return callback(null,db)}var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION)}catch(e){return callback(e)}if(!req){return callback("Unable to connect to IndexedDB")}req.onupgradeneeded=(function(e){var db=e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)){fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME)}else{fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME)}if(!fileStore.indexNames.contains("timestamp")){fileStore.createIndex("timestamp","timestamp",{unique:false})}});req.onsuccess=(function(){db=req.result;IDBFS.dbs[name]=db;callback(null,db)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),getLocalSet:(function(mount,callback){var entries={};function isRealDir(p){return p!=="."&&p!==".."}function toAbsolute(root){return(function(p){return PATH.join2(root,p)})}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode)){check.push.apply(check,FS.readdir(path).filter(isRealDir).map(toAbsolute(path)))}entries[path]={timestamp:stat.mtime}}return callback(null,{type:"local",entries:entries})}),getRemoteSet:(function(mount,callback){var entries={};IDBFS.getDB(mount.mountpoint,(function(err,db){if(err)return callback(err);try{var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=(function(e){callback(this.error);e.preventDefault()});var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=(function(event){var cursor=event.target.result;if(!cursor){return callback(null,{type:"remote",db:db,entries:entries})}entries[cursor.primaryKey]={timestamp:cursor.key};cursor.continue()})}catch(e){return callback(e)}}))}),loadLocalEntry:(function(path,callback){var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode)){return callback(null,{timestamp:stat.mtime,mode:stat.mode})}else if(FS.isFile(stat.mode)){node.contents=MEMFS.getFileDataAsTypedArray(node);return callback(null,{timestamp:stat.mtime,mode:stat.mode,contents:node.contents})}else{return callback(new Error("node type not supported"))}}),storeLocalEntry:(function(path,entry,callback){try{if(FS.isDir(entry.mode)){FS.mkdir(path,entry.mode)}else if(FS.isFile(entry.mode)){FS.writeFile(path,entry.contents,{canOwn:true})}else{return callback(new Error("node type not supported"))}FS.chmod(path,entry.mode);FS.utime(path,entry.timestamp,entry.timestamp)}catch(e){return callback(e)}callback(null)}),removeLocalEntry:(function(path,callback){try{var lookup=FS.lookupPath(path);var stat=FS.stat(path);if(FS.isDir(stat.mode)){FS.rmdir(path)}else if(FS.isFile(stat.mode)){FS.unlink(path)}}catch(e){return callback(e)}callback(null)}),loadRemoteEntry:(function(store,path,callback){var req=store.get(path);req.onsuccess=(function(event){callback(null,event.target.result)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),storeRemoteEntry:(function(store,path,entry,callback){var req=store.put(entry,path);req.onsuccess=(function(){callback(null)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),removeRemoteEntry:(function(store,path,callback){var req=store.delete(path);req.onsuccess=(function(){callback(null)});req.onerror=(function(e){callback(this.error);e.preventDefault()})}),reconcile:(function(src,dst,callback){var total=0;var create=[];Object.keys(src.entries).forEach((function(key){var e=src.entries[key];var e2=dst.entries[key];if(!e2||e.timestamp>e2.timestamp){create.push(key);total++}}));var remove=[];Object.keys(dst.entries).forEach((function(key){var e=dst.entries[key];var e2=src.entries[key];if(!e2){remove.push(key);total++}}));if(!total){return callback(null)}var completed=0;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err){if(!done.errored){done.errored=true;return callback(err)}return}if(++completed>=total){return callback(null)}}transaction.onerror=(function(e){done(this.error);e.preventDefault()});create.sort().forEach((function(path){if(dst.type==="local"){IDBFS.loadRemoteEntry(store,path,(function(err,entry){if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done)}))}else{IDBFS.loadLocalEntry(path,(function(err,entry){if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done)}))}}));remove.sort().reverse().forEach((function(path){if(dst.type==="local"){IDBFS.removeLocalEntry(path,done)}else{IDBFS.removeRemoteEntry(store,path,done)}}))})};var NODEFS={isWindows:false,staticInit:(function(){NODEFS.isWindows=!!process.platform.match(/^win/);var flags=process["binding"]("constants");if(flags["fs"]){flags=flags["fs"]}NODEFS.flagsForNodeMap={"1024":flags["O_APPEND"],"64":flags["O_CREAT"],"128":flags["O_EXCL"],"0":flags["O_RDONLY"],"2":flags["O_RDWR"],"4096":flags["O_SYNC"],"512":flags["O_TRUNC"],"1":flags["O_WRONLY"]}}),bufferFrom:(function(arrayBuffer){return Buffer.alloc?Buffer.from(arrayBuffer):new Buffer(arrayBuffer)}),mount:(function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)}),createNode:(function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node}),getMode:(function(path){var stat;try{stat=fs.lstatSync(path);if(NODEFS.isWindows){stat.mode=stat.mode|(stat.mode&292)>>2}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return stat.mode}),realPath:(function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)}),flagsForNode:(function(flags){flags&=~2097152;flags&=~2048;flags&=~32768;flags&=~524288;var newFlags=0;for(var k in NODEFS.flagsForNodeMap){if(flags&k){newFlags|=NODEFS.flagsForNodeMap[k];flags^=k}}if(!flags){return newFlags}else{throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}}),node_ops:{getattr:(function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(NODEFS.isWindows&&!stat.blksize){stat.blksize=4096}if(NODEFS.isWindows&&!stat.blocks){stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0}return{dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}}),setattr:(function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,date,date)}if(attr.size!==undefined){fs.truncateSync(path,attr.size)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),lookup:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)}),mknod:(function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode)){fs.mkdirSync(path,node.mode)}else{fs.writeFileSync(path,"",{mode:node.mode})}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return node}),rename:(function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),unlink:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),rmdir:(function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readdir:(function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),symlink:(function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),readlink:(function(node){var path=NODEFS.realPath(node);try{path=fs.readlinkSync(path);path=NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root),path);return path}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}})},stream_ops:{open:(function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode)){stream.nfd=fs.openSync(path,NODEFS.flagsForNode(stream.flags))}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),close:(function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd){fs.closeSync(stream.nfd)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),read:(function(stream,buffer,offset,length,position){if(length===0)return 0;try{return fs.readSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),write:(function(stream,buffer,offset,length,position){try{return fs.writeSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){try{var stat=fs.fstatSync(stream.nfd);position+=stat.size}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:(function(mount){assert(ENVIRONMENT_IS_WORKER);if(!WORKERFS.reader)WORKERFS.reader=new FileReaderSync;var root=WORKERFS.createNode(null,"/",WORKERFS.DIR_MODE,0);var createdParents={};function ensureParent(path){var parts=path.split("/");var parent=root;for(var i=0;i<parts.length-1;i++){var curr=parts.slice(0,i+1).join("/");if(!createdParents[curr]){createdParents[curr]=WORKERFS.createNode(parent,parts[i],WORKERFS.DIR_MODE,0)}parent=createdParents[curr]}return parent}function base(path){var parts=path.split("/");return parts[parts.length-1]}Array.prototype.forEach.call(mount.opts["files"]||[],(function(file){WORKERFS.createNode(ensureParent(file.name),base(file.name),WORKERFS.FILE_MODE,0,file,file.lastModifiedDate)}));(mount.opts["blobs"]||[]).forEach((function(obj){WORKERFS.createNode(ensureParent(obj["name"]),base(obj["name"]),WORKERFS.FILE_MODE,0,obj["data"])}));(mount.opts["packages"]||[]).forEach((function(pack){pack["metadata"].files.forEach((function(file){var name=file.filename.substr(1);WORKERFS.createNode(ensureParent(name),base(name),WORKERFS.FILE_MODE,0,pack["blob"].slice(file.start,file.end))}))}));return root}),createNode:(function(parent,name,mode,dev,contents,mtime){var node=FS.createNode(parent,name,mode);node.mode=mode;node.node_ops=WORKERFS.node_ops;node.stream_ops=WORKERFS.stream_ops;node.timestamp=(mtime||new Date).getTime();assert(WORKERFS.FILE_MODE!==WORKERFS.DIR_MODE);if(mode===WORKERFS.FILE_MODE){node.size=contents.size;node.contents=contents}else{node.size=4096;node.contents={}}if(parent){parent.contents[name]=node}return node}),node_ops:{getattr:(function(node){return{dev:1,ino:undefined,mode:node.mode,nlink:1,uid:0,gid:0,rdev:undefined,size:node.size,atime:new Date(node.timestamp),mtime:new Date(node.timestamp),ctime:new Date(node.timestamp),blksize:4096,blocks:Math.ceil(node.size/4096)}}),setattr:(function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}}),lookup:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.ENOENT)}),mknod:(function(parent,name,mode,dev){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rename:(function(oldNode,newDir,newName){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),unlink:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),rmdir:(function(parent,name){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readdir:(function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries}),symlink:(function(parent,newName,oldPath){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}),readlink:(function(node){throw new FS.ErrnoError(ERRNO_CODES.EPERM)})},stream_ops:{read:(function(stream,buffer,offset,length,position){if(position>=stream.node.size)return 0;var chunk=stream.node.contents.slice(position,position+length);var ab=WORKERFS.reader.readAsArrayBuffer(chunk);buffer.set(new Uint8Array(ab),offset);return chunk.size}),write:(function(stream,buffer,offset,length,position){throw new FS.ErrnoError(ERRNO_CODES.EIO)}),llseek:(function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.size}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position})}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:(function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)}),lookupPath:(function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};if(!path)return{path:"",node:null};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults){if(opts[key]===undefined){opts[key]=defaults[key]}}if(opts.recurse_count>8){throw new FS.ErrnoError(40)}var parts=PATH.normalizeArray(path.split("/").filter((function(p){return!!p})),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40){throw new FS.ErrnoError(40)}}}}return{path:current_path,node:current}}),getPath:(function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent}}),hashName:(function(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length}),hashAddNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node}),hashRemoveNode:(function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}}),lookupNode:(function(parent,name){var err=FS.mayLookup(parent);if(err){throw new FS.ErrnoError(err,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)}),createNode:(function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=(function(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev});FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:(function(){return(this.mode&readMode)===readMode}),set:(function(val){val?this.mode|=readMode:this.mode&=~readMode})},write:{get:(function(){return(this.mode&writeMode)===writeMode}),set:(function(val){val?this.mode|=writeMode:this.mode&=~writeMode})},isFolder:{get:(function(){return FS.isDir(this.mode)})},isDevice:{get:(function(){return FS.isChrdev(this.mode)})}})}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node}),destroyNode:(function(node){FS.hashRemoveNode(node)}),isRoot:(function(node){return node===node.parent}),isMountpoint:(function(node){return!!node.mounted}),isFile:(function(mode){return(mode&61440)===32768}),isDir:(function(mode){return(mode&61440)===16384}),isLink:(function(mode){return(mode&61440)===40960}),isChrdev:(function(mode){return(mode&61440)===8192}),isBlkdev:(function(mode){return(mode&61440)===24576}),isFIFO:(function(mode){return(mode&61440)===4096}),isSocket:(function(mode){return(mode&49152)===49152}),flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:(function(str){var flags=FS.flagModes[str];if(typeof flags==="undefined"){throw new Error("Unknown file open mode: "+str)}return flags}),flagsToPermissionString:(function(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w"}return perms}),nodePermissions:(function(node,perms){if(FS.ignorePermissions){return 0}if(perms.indexOf("r")!==-1&&!(node.mode&292)){return 13}else if(perms.indexOf("w")!==-1&&!(node.mode&146)){return 13}else if(perms.indexOf("x")!==-1&&!(node.mode&73)){return 13}return 0}),mayLookup:(function(dir){var err=FS.nodePermissions(dir,"x");if(err)return err;if(!dir.node_ops.lookup)return 13;return 0}),mayCreate:(function(dir,name){try{var node=FS.lookupNode(dir,name);return 17}catch(e){}return FS.nodePermissions(dir,"wx")}),mayDelete:(function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err){return err}if(isdir){if(!FS.isDir(node.mode)){return 20}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 16}}else{if(FS.isDir(node.mode)){return 21}}return 0}),mayOpen:(function(node,flags){if(!node){return 2}if(FS.isLink(node.mode)){return 40}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 21}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))}),MAX_OPEN_FDS:4096,nextfd:(function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(24)}),getStream:(function(fd){return FS.streams[fd]}),createStream:(function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=(function(){});FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:(function(){return this.node}),set:(function(val){this.node=val})},isRead:{get:(function(){return(this.flags&2097155)!==1})},isWrite:{get:(function(){return(this.flags&2097155)!==0})},isAppend:{get:(function(){return this.flags&1024})}})}var newStream=new FS.FSStream;for(var p in stream){newStream[p]=stream[p]}stream=newStream;var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream}),closeStream:(function(fd){FS.streams[fd]=null}),chrdev_stream_ops:{open:(function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream)}}),llseek:(function(){throw new FS.ErrnoError(29)})},major:(function(dev){return dev>>8}),minor:(function(dev){return dev&255}),makedev:(function(ma,mi){return ma<<8|mi}),registerDevice:(function(dev,ops){FS.devices[dev]={stream_ops:ops}}),getDevice:(function(dev){return FS.devices[dev]}),getMounts:(function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts}),syncfs:(function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){console.log("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work")}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(err){assert(FS.syncFSRequests>0);FS.syncFSRequests--;return callback(err)}function done(err){if(err){if(!done.errored){done.errored=true;return doCallback(err)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach((function(mount){if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)}))}),mount:(function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(16)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(20)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot}),unmount:(function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(22)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach((function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1){FS.destroyNode(current)}current=next}}));node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1)}),lookup:(function(parent,name){return parent.node_ops.lookup(parent,name)}),mknod:(function(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(22)}var err=FS.mayCreate(parent,name);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(1)}return parent.node_ops.mknod(parent,name,mode,dev)}),create:(function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)}),mkdir:(function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)}),mkdirTree:(function(path,mode){var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=17)throw e}}}),mkdev:(function(path,mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)}),symlink:(function(oldpath,newpath){if(!PATH.resolve(oldpath)){throw new FS.ErrnoError(2)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(2)}var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(1)}return parent.node_ops.symlink(parent,newname,oldpath)}),rename:(function(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node}catch(e){throw new FS.ErrnoError(16)}if(!old_dir||!new_dir)throw new FS.ErrnoError(2);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(18)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(22)}relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(39)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err){throw new FS.ErrnoError(err)}err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err){throw new FS.ErrnoError(err)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(1)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(16)}if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err){throw new FS.ErrnoError(err)}}try{if(FS.trackingDelegate["willMovePath"]){FS.trackingDelegate["willMovePath"](old_path,new_path)}}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}}),rmdir:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(1)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}}),readdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(20)}return node.node_ops.readdir(node)}),unlink:(function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(1)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}}),readlink:(function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(2)}if(!link.node_ops.readlink){throw new FS.ErrnoError(22)}return PATH.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))}),stat:(function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(2)}if(!node.node_ops.getattr){throw new FS.ErrnoError(1)}return node.node_ops.getattr(node)}),lstat:(function(path){return FS.stat(path,true)}),chmod:(function(path,mode,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})}),lchmod:(function(path,mode){FS.chmod(path,mode,true)}),fchmod:(function(fd,mode){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}FS.chmod(stream.node,mode)}),chown:(function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}node.node_ops.setattr(node,{timestamp:Date.now()})}),lchown:(function(path,uid,gid){FS.chown(path,uid,gid,true)}),fchown:(function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}FS.chown(stream.node,uid,gid)}),truncate:(function(path,len){if(len<0){throw new FS.ErrnoError(22)}var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(21)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(22)}var err=FS.nodePermissions(node,"w");if(err){throw new FS.ErrnoError(err)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})}),ftruncate:(function(fd,len){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(22)}FS.truncate(stream.node,len)}),utime:(function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})}),open:(function(path,flags,mode,fd_start,fd_end){if(path===""){throw new FS.ErrnoError(2)}flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path==="object"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(17)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(2)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(20)}if(!created){var err=FS.mayOpen(node,flags);if(err){throw new FS.ErrnoError(err)}}if(flags&512){FS.truncate(node,0)}flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;console.log("FS.trackingDelegate error on read file: "+path)}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1){trackingFlags|=FS.tracking.openFlags.READ}if((flags&2097155)!==0){trackingFlags|=FS.tracking.openFlags.WRITE}FS.trackingDelegate["onOpenFile"](path,trackingFlags)}}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message)}return stream}),close:(function(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null}),isClosed:(function(stream){return stream.fd===null}),llseek:(function(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(29)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position}),read:(function(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(22)}if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(9)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(21)}if(!stream.stream_ops.read){throw new FS.ErrnoError(22)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(29)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead}),write:(function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(22)}if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(9)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(21)}if(!stream.stream_ops.write){throw new FS.ErrnoError(22)}if(stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(29)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path)}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: "+e.message)}return bytesWritten}),allocate:(function(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(offset<0||length<=0){throw new FS.ErrnoError(22)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(9)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(19)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(95)}stream.stream_ops.allocate(stream,offset,length)}),mmap:(function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1){throw new FS.ErrnoError(13)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(19)}return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)}),msync:(function(stream,buffer,offset,length,mmapFlags){if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)}),munmap:(function(stream){return 0}),ioctl:(function(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(25)}return stream.stream_ops.ioctl(stream,cmd,arg)}),readFile:(function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding==="binary"){ret=buf}FS.close(stream);return ret}),writeFile:(function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error("Unsupported data type")}FS.close(stream)}),cwd:(function(){return FS.currentPath}),chdir:(function(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(2)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(20)}var err=FS.nodePermissions(lookup.node,"x");if(err){throw new FS.ErrnoError(err)}FS.currentPath=lookup.path}),createDefaultDirectories:(function(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user")}),createDefaultDevices:(function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:(function(){return 0}),write:(function(stream,buffer,offset,length,pos){return length})});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device;if(typeof crypto!=="undefined"){var randomBuffer=new Uint8Array(1);random_device=(function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]})}else if(ENVIRONMENT_IS_NODE){random_device=(function(){return require("crypto")["randomBytes"](1)[0]})}else{random_device=(function(){abort("random_device")})}FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")}),createSpecialDirectories:(function(){FS.mkdir("/proc");FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:(function(){var node=FS.createNode("/proc/self","fd",16384|511,73);node.node_ops={lookup:(function(parent,name){var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(9);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:(function(){return stream.path})}};ret.parent=ret;return ret})};return node})},{},"/proc/self/fd")}),createStandardStreams:(function(){if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"])}else{FS.symlink("/dev/tty","/dev/stdin")}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"])}else{FS.symlink("/dev/tty","/dev/stdout")}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"])}else{FS.symlink("/dev/tty1","/dev/stderr")}var stdin=FS.open("/dev/stdin","r");assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");var stdout=FS.open("/dev/stdout","w");assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");var stderr=FS.open("/dev/stderr","w");assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")")}),ensureErrnoError:(function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=(function(errno){this.errno=errno});this.setErrno(errno);this.message="FS error";if(this.stack)Object.defineProperty(this,"stack",{value:(new Error).stack,writable:true})};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[2].forEach((function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"}))}),staticInit:(function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"IDBFS":IDBFS,"NODEFS":NODEFS,"WORKERFS":WORKERFS}}),init:(function(input,output,error){assert(!FS.init.initialized,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()}),quit:(function(){FS.init.initialized=false;var fflush=Module["_fflush"];if(fflush)fflush(0);for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}}),getMode:(function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode}),joinPath:(function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path}),absolutePath:(function(relative,base){return PATH.resolve(base,relative)}),standardizePath:(function(path){return PATH.normalize(path)}),findObject:(function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else{___setErrNo(ret.error);return null}}),analyzePath:(function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret}),createFolder:(function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)}),createPath:(function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current}),createFile:(function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)}),createDataFile:(function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node}),createDevice:(function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:(function(stream){stream.seekable=false}),close:(function(stream){if(output&&output.buffer&&output.buffer.length){output(10)}}),read:(function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(5)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(11)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead}),write:(function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(5)}}if(length){stream.node.timestamp=Date.now()}return i})});return FS.mkdev(path,mode,dev)}),createLink:(function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)}),forceLoadFile:(function(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(Module["read"]){try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length}catch(e){success=false}}else{throw new Error("Cannot load without read() or XMLHttpRequest.")}if(!success)___setErrNo(5);return success}),createLazyFile:(function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else{return intArrayFromString(xhr.responseText||"",true)}});var lazyArray=this;lazyArray.setDataGetter((function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]}));if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;console.log("LazyFiles on gzip forces download of the whole file when length is accessed")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:(function(){if(!this.lengthKnown){this.cacheLength()}return this._length})},chunkSize:{get:(function(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize})}});var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:(function(){return this.contents.length})}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach((function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(5)}return fn.apply(null,arguments)}}));stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(5)}var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size};node.stream_ops=stream_ops;return node}),createPreloadedFile:(function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency("cp "+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}if(onload)onload();removeRunDependency(dep)}var handled=false;Module["preloadPlugins"].forEach((function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,(function(){if(onerror)onerror();removeRunDependency(dep)}));handled=true}}));if(!handled)finish(byteArray)}addRunDependency(dep);if(typeof url=="string"){Browser.asyncLoad(url,(function(byteArray){processData(byteArray)}),onerror)}else{processData(url)}}),indexedDB:(function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB}),DB_NAME:(function(){return"EM_FS_"+window.location.pathname}),DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach((function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish()};putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish()}}));transaction.onerror=onerror};openRequest.onerror=onerror}),loadFilesFromDB:(function(paths,onload,onerror){onload=onload||(function(){});onerror=onerror||(function(){});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach((function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists){FS.unlink(path)}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=function getRequest_onerror(){fail++;if(ok+fail==total)finish()}}));transaction.onerror=onerror};openRequest.onerror=onerror})};var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:(function(dirfd,path){if(path[0]!=="/"){var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);dir=dirstream.path}path=PATH.join2(dir,path)}return path}),doStat:(function(func,path,buf){try{var stat=func(path)}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return-ERRNO_CODES.ENOTDIR}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;HEAP32[buf+36>>2]=stat.size;HEAP32[buf+40>>2]=4096;HEAP32[buf+44>>2]=stat.blocks;HEAP32[buf+48>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+52>>2]=0;HEAP32[buf+56>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ino;return 0}),doMsync:(function(addr,stream,len,flags){var buffer=new Uint8Array(HEAPU8.subarray(addr,addr+len));FS.msync(stream,buffer,0,len,flags)}),doMkdir:(function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0}),doMknod:(function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-ERRNO_CODES.EINVAL}FS.mknod(path,mode,dev);return 0}),doReadlink:(function(path,buf,bufsize){if(bufsize<=0)return-ERRNO_CODES.EINVAL;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}),doAccess:(function(path,amode){if(amode&~7){return-ERRNO_CODES.EINVAL}var node;var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return-ERRNO_CODES.EACCES}return 0}),doDup:(function(path,flags,suggestFD){var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(path,flags,0,suggestFD,suggestFD).fd}),doReadv:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break}return ret}),doWritev:(function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr}return ret}),varargs:0,get:(function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret}),getStr:(function(){var ret=UTF8ToString(SYSCALLS.get());return ret}),getStreamFromFD:(function(){var stream=FS.getStream(SYSCALLS.get());if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return stream}),getSocketFromFD:(function(){var socket=SOCKFS.getSocket(SYSCALLS.get());if(!socket)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return socket}),getSocketAddress:(function(allowNull){var addrp=SYSCALLS.get(),addrlen=SYSCALLS.get();if(allowNull&&addrp===0)return null;var info=__read_sockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info}),get64:(function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low}),getZero:(function(){assert(SYSCALLS.get()===0)})};function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);HEAP32[result>>2]=stream.position;if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall145(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doReadv(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doWritev(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall221(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),cmd=SYSCALLS.get();switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-ERRNO_CODES.EINVAL}var newStream;newStream=FS.open(stream.path,stream.flags,0,arg);return newStream.fd};case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0};case 12:case 12:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>1]=2;return 0};case 13:case 14:case 13:case 14:return 0;case 16:case 8:return-ERRNO_CODES.EINVAL;case 9:___setErrNo(ERRNO_CODES.EINVAL);return-1;default:{return-ERRNO_CODES.EINVAL}}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall3(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),buf=SYSCALLS.get(),count=SYSCALLS.get();return FS.read(stream,HEAP8,buf,count)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall5(which,varargs){SYSCALLS.varargs=varargs;try{var pathname=SYSCALLS.getStr(),flags=SYSCALLS.get(),mode=SYSCALLS.get();var stream=FS.open(pathname,flags,mode);return stream.fd}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),op=SYSCALLS.get();switch(op){case 21509:case 21505:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0};case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0};case 21519:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0};case 21520:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return-ERRNO_CODES.EINVAL};case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)};case 21523:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0};case 21524:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0};default:abort("bad ioctl syscall "+op)}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall91(which,varargs){SYSCALLS.varargs=varargs;try{var addr=SYSCALLS.get(),len=SYSCALLS.get();var info=SYSCALLS.mappings[addr];if(!info)return 0;if(len===info.len){var stream=FS.getStream(info.fd);SYSCALLS.doMsync(addr,stream,len,info.flags);FS.munmap(stream);SYSCALLS.mappings[addr]=null;if(info.allocated){_free(info.malloc)}}return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___unlock(){}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i)}embind_charCodes=codes}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]]}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return"_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return"_"+name}else{return name}}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return(new Function("body","return function "+name+"() {\n"+'    "use strict";'+"    return body.apply(this, arguments);\n"+"};\n"))(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,(function(message){this.name=errorName;this.message=message;var stack=(new Error(message)).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"")}}));errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=(function(){if(this.message===undefined){return this.name}else{return this.name+": "+this.message}});return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach((function(type){typeDependencies[type]=dependentTypes}));function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count")}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i])}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach((function(dt,i){if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt]}else{unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[]}awaitingDependencies[dt].push((function(){typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters)}}))}}));if(0===unregisteredTypes.length){onComplete(typeConverters)}}function registerType(rawType,registeredInstance,options){options=options||{};if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer')}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else{throwBindingError("Cannot register type '"+name+"' twice")}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach((function(cb){cb()}))}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":(function(wt){return!!wt}),"toWireType":(function(destructors,o){return o?trueValue:falseValue}),"argPackAdvance":8,"readValueFromPointer":(function(pointer){var heap;if(size===1){heap=HEAP8}else if(size===2){heap=HEAP16}else if(size===4){heap=HEAP32}else{throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])}),destructorFunction:null})}function ClassHandle_isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass}return leftClass===rightClass&&left===right}function shallowCopyInternalPointer(o){return{count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType}}function throwInstanceAlreadyDeleted(obj){function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+" instance already deleted")}function ClassHandle_clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else{var clone=Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}});clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}}function runDestructor(handle){var $$=handle.$$;if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr)}else{$$.ptrType.registeredClass.rawDestructor($$.ptr)}}function ClassHandle_delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion")}this.$$.count.value-=1;var toDelete=0===this.$$.count.value;if(toDelete){runDestructor(this)}if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined}}function ClassHandle_isDeleted(){return!this.$$.ptr}var delayFunction=undefined;var deletionQueue=[];function flushPendingDeletes(){while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj["delete"]()}}function ClassHandle_deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this)}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion")}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes)}this.$$.deleteScheduled=true;return this}function init_ClassHandle(){ClassHandle.prototype["isAliasOf"]=ClassHandle_isAliasOf;ClassHandle.prototype["clone"]=ClassHandle_clone;ClassHandle.prototype["delete"]=ClassHandle_delete;ClassHandle.prototype["isDeleted"]=ClassHandle_isDeleted;ClassHandle.prototype["deleteLater"]=ClassHandle_deleteLater}function ClassHandle(){}var registeredPointers={};function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=(function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!")}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)});proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice")}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!")}Module[name].overloadTable[numArguments]=value}else{Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments}}}function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[]}function upcastPointer(ptr,ptrClass,desiredClass){while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError("Expected null or instance of "+desiredClass.name+", got an instance of "+ptrClass.name)}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass}return ptr}function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name)}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name)}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name)}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name)}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr)}return ptr}else{return 0}}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name)}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name)}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name)}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError("Passing raw pointer to smart pointer is illegal")}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr}else{throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name)}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr}else{var clonedHandle=handle["clone"]();ptr=this.rawShare(ptr,__emval_register((function(){clonedHandle["delete"]()})));if(destructors!==null){destructors.push(this.rawDestructor,ptr)}}break;default:throwBindingError("Unsupporting sharing policy")}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name)}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name)}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name)}if(handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+handle.$$.ptrType.name+" to parameter type "+this.name)}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function RegisteredPointer_getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr)}return ptr}function RegisteredPointer_destructor(ptr){if(this.rawDestructor){this.rawDestructor(ptr)}}function RegisteredPointer_deleteObject(handle){if(handle!==null){handle["delete"]()}}function downcastPointer(ptr,ptrClass,desiredClass){if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)}function getInheritedInstanceCount(){return Object.keys(registeredInstances).length}function getLiveInheritedInstances(){var rv=[];for(var k in registeredInstances){if(registeredInstances.hasOwnProperty(k)){rv.push(registeredInstances[k])}}return rv}function setDelayFunction(fn){delayFunction=fn;if(deletionQueue.length&&delayFunction){delayFunction(flushPendingDeletes)}}function init_embind(){Module["getInheritedInstanceCount"]=getInheritedInstanceCount;Module["getLiveInheritedInstances"]=getLiveInheritedInstances;Module["flushPendingDeletes"]=flushPendingDeletes;Module["setDelayFunction"]=setDelayFunction}var registeredInstances={};function getBasestPointer(class_,ptr){if(ptr===undefined){throwBindingError("ptr should not be undefined")}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass}return ptr}function getInheritedInstance(class_,ptr){ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]}function makeClassHandle(prototype,record){if(!record.ptrType||!record.ptr){throwInternalError("makeClassHandle requires ptr and ptrType")}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError("Both smartPtrType and smartPtr must be specified")}record.count={value:1};return Object.create(prototype,{$$:{value:record}})}function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance["clone"]()}else{var rv=registeredInstance["clone"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr:ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType}else{toType=registeredPointerRecord.pointerType}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else{return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}function init_RegisteredPointer(){RegisteredPointer.prototype.getPointee=RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor=RegisteredPointer_destructor;RegisteredPointer.prototype["argPackAdvance"]=8;RegisteredPointer.prototype["readValueFromPointer"]=simpleReadValueFromPointer;RegisteredPointer.prototype["deleteObject"]=RegisteredPointer_deleteObject;RegisteredPointer.prototype["fromWireType"]=RegisteredPointer_fromWireType}function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this["toWireType"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null}else{this["toWireType"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null}}else{this["toWireType"]=genericPointerToWireType}}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol")}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value}else{Module[name]=value;Module[name].argCount=numArguments}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(dynCall){var args=[];for(var i=1;i<signature.length;++i){args.push("a"+i)}var name="dynCall_"+signature+"_"+rawFunction;var body="return function "+name+"("+args.join(", ")+") {\n";body+="    return dynCall(rawFunction"+(args.length?", ":"")+args.join(", ")+");\n";body+="};\n";return(new Function("dynCall","rawFunction",body))(dynCall,rawFunction)}var fp;if(Module["FUNCTION_TABLE_"+signature]!==undefined){fp=Module["FUNCTION_TABLE_"+signature][rawFunction]}else if(typeof FUNCTION_TABLE!=="undefined"){fp=FUNCTION_TABLE[rawFunction]}else{var dc=Module["dynCall_"+signature];if(dc===undefined){dc=Module["dynCall_"+signature.replace(/f/g,"d")];if(dc===undefined){throwBindingError("No dynCall invoker for signature: "+signature)}}fp=makeDynCaller(dc)}if(typeof fp!=="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction)}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);if(upcast){upcast=embind__requireFunction(upcastSignature,upcast)}if(downcast){downcast=embind__requireFunction(downcastSignature,downcast)}rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,(function(){throwUnboundTypeError("Cannot construct "+name+" due to unbound types",[baseClassRawType])}));whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],(function(base){base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype}else{basePrototype=ClassHandle.prototype}var constructor=createNamedFunction(legalFunctionName,(function(){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError("Use 'new' to construct "+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+" has no accessible constructor")}var body=registeredClass.constructor_body[arguments.length];if(undefined===body){throw new BindingError("Tried to invoke ctor of "+name+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(registeredClass.constructor_body).toString()+") parameters instead!")}return body.apply(this,arguments)}));var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+"*",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+" const*",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return[referenceConverter,pointerConverter,constPointerConverter]}))}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError("new_ called with constructor type "+typeof constructor+" which is not a function")}var dummy=createNamedFunction(constructor.name||"unknownFunctionName",(function(){}));dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr)}}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!")}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var argsList="";var argsListWired="";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?", ":"")+"arg"+i;argsListWired+=(i!==0?", ":"")+"arg"+i+"Wired"}var invokerFnBody="return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n"+"if (arguments.length !== "+(argCount-2)+") {\n"+"throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount-2)+" args!');\n"+"}\n";if(needsDestructorStack){invokerFnBody+="var destructors = [];\n"}var dtorStack=needsDestructorStack?"destructors":"null";var args1=["throwBindingError","invoker","fn","runDestructors","retType","classParam"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+="var thisWired = classParam.toWireType("+dtorStack+", this);\n"}for(var i=0;i<argCount-2;++i){invokerFnBody+="var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";args1.push("argType"+i);args2.push(argTypes[i+2])}if(isClassMethodFunc){argsListWired="thisWired"+(argsListWired.length>0?", ":"")+argsListWired}invokerFnBody+=(returns?"var rv = ":"")+"invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";if(needsDestructorStack){invokerFnBody+="runDestructors(destructors);\n"}else{for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?"thisWired":"arg"+(i-2)+"Wired";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";args1.push(paramName+"_dtor");args2.push(argTypes[i].destructorFunction)}}}if(returns){invokerFnBody+="var ret = retType.fromWireType(rv);\n"+"return ret;\n"}else{}invokerFnBody+="}\n";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i])}return array}function __embind_register_class_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,fn){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],(function(classType){classType=classType[0];var humanName=classType.name+"."+methodName;function unboundTypesHandler(){throwUnboundTypeError("Cannot call "+humanName+" due to unbound types",rawArgTypes)}var proto=classType.registeredClass.constructor;if(undefined===proto[methodName]){unboundTypesHandler.argCount=argCount-1;proto[methodName]=unboundTypesHandler}else{ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-1]=unboundTypesHandler}whenDependentTypesAreResolved([],rawArgTypes,(function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));var func=craftInvokerFunction(humanName,invokerArgsArray,null,rawInvoker,fn);if(undefined===proto[methodName].overloadTable){func.argCount=argCount-1;proto[methodName]=func}else{proto[methodName].overloadTable[argCount-1]=func}return[]}));return[]}))}function validateThis(this_,classType,humanName){if(!(this_ instanceof Object)){throwBindingError(humanName+' with invalid "this": '+this_)}if(!(this_ instanceof classType.registeredClass.constructor)){throwBindingError(humanName+' incompatible with "this" of type '+this_.constructor.name)}if(!this_.$$.ptr){throwBindingError("cannot call emscripten binding method "+humanName+" on deleted object")}return upcastPointer(this_.$$.ptr,this_.$$.ptrType.registeredClass,classType.registeredClass)}function __embind_register_class_class_property(rawClassType,fieldName,rawFieldType,rawFieldPtr,getterSignature,getter,setterSignature,setter){fieldName=readLatin1String(fieldName);getter=embind__requireFunction(getterSignature,getter);whenDependentTypesAreResolved([],[rawClassType],(function(classType){classType=classType[0];var humanName=classType.name+"."+fieldName;var desc={get:(function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[rawFieldType])}),enumerable:true,configurable:true};if(setter){desc.set=(function(){throwUnboundTypeError("Cannot access "+humanName+" due to unbound types",[rawFieldType])})}else{desc.set=(function(v){throwBindingError(humanName+" is a read-only property")})}Object.defineProperty(classType.registeredClass.constructor,fieldName,desc);whenDependentTypesAreResolved([],[rawFieldType],(function(fieldType){fieldType=fieldType[0];var desc={get:(function(){return fieldType["fromWireType"](getter(rawFieldPtr))}),enumerable:true};if(setter){setter=embind__requireFunction(setterSignature,setter);desc.set=(function(v){var destructors=[];setter(rawFieldPtr,fieldType["toWireType"](destructors,v));runDestructors(destructors)})}Object.defineProperty(classType.registeredClass.constructor,fieldName,desc);return[]}));return[]}))}function __embind_register_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],(function(classType){classType=classType[0];var humanName=classType.name+"."+methodName;if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName)}function unboundTypesHandler(){throwUnboundTypeError("Cannot call "+humanName+" due to unbound types",rawArgTypes)}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler}else{ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler}whenDependentTypesAreResolved([],rawArgTypes,(function(argTypes){var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction}else{proto[methodName].overloadTable[argCount-2]=memberFunction}return[]}));return[]}))}function __embind_register_constant(name,type,value){name=readLatin1String(name);whenDependentTypesAreResolved([],[type],(function(type){type=type[0];Module[name]=type["fromWireType"](value);return[]}))}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle)}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval}function __emval_register(value){switch(value){case undefined:{return 1};case null:{return 2};case true:{return 3};case false:{return 4};default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":(function(handle){var rv=emval_handle_array[handle].value;__emval_decref(handle);return rv}),"toWireType":(function(destructors,value){return __emval_register(value)}),"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null})}function _embind_repr(v){if(v===null){return"null"}var t=typeof v;if(t==="object"||t==="array"||t==="function"){return v.toString()}else{return""+v}}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return(function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])});case 3:return(function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])});default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":(function(value){return value}),"toWireType":(function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}return value}),"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null})}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,(function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes)}),argCount-1);whenDependentTypesAreResolved([],argTypes,(function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return[]}))}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295}var shift=getShiftFromSize(size);var fromWireType=(function(value){return value});if(minRange===0){var bitshift=32-8*size;fromWireType=(function(value){return value<<bitshift>>>bitshift})}var isUnsignedType=name.indexOf("unsigned")!=-1;registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":(function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}if(value<minRange||value>maxRange){throw new TypeError('Passing a number "'+_embind_repr(value)+'" from JS side to C/C++ side to an argument of type "'+name+'", which is outside the valid range ['+minRange+", "+maxRange+"]!")}return isUnsignedType?value>>>0:value|0}),"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null})}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(heap["buffer"],data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true})}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":(function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var endChar=HEAPU8[value+4+length];var endCharSwap=0;if(endChar!=0){endCharSwap=endChar;HEAPU8[value+4+length]=0}var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(HEAPU8[currentBytePtr]==0){var stringSegment=UTF8ToString(decodeStartPtr);if(str===undefined)str=stringSegment;else{str+=String.fromCharCode(0);str+=stringSegment}decodeStartPtr=currentBytePtr+1}}if(endCharSwap!=0)HEAPU8[value+4+length]=endCharSwap}else{var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i])}str=a.join("")}_free(value);return str}),"toWireType":(function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value)}var getLength;var valueIsOfTypeString=typeof value==="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string")}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=(function(){return lengthBytesUTF8(value)})}else{getLength=(function(){return value.length})}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1)}else{if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits")}HEAPU8[ptr+4+i]=charCode}}else{for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i]}}}if(destructors!==null){destructors.push(_free,ptr)}return ptr}),"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:(function(ptr){_free(ptr)})})}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var getHeap,shift;if(charSize===2){getHeap=(function(){return HEAPU16});shift=1}else if(charSize===4){getHeap=(function(){return HEAPU32});shift=2}registerType(rawType,{name:name,"fromWireType":(function(value){var HEAP=getHeap();var length=HEAPU32[value>>2];var a=new Array(length);var start=value+4>>shift;for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAP[start+i])}_free(value);return a.join("")}),"toWireType":(function(destructors,value){var HEAP=getHeap();var length=value.length;var ptr=_malloc(4+length*charSize);HEAPU32[ptr>>2]=length;var start=ptr+4>>shift;for(var i=0;i<length;++i){HEAP[start+i]=value.charCodeAt(i)}if(destructors!==null){destructors.push(_free,ptr)}return ptr}),"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:(function(ptr){_free(ptr)})})}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":(function(){return undefined}),"toWireType":(function(destructors,o){return undefined})})}function requireHandle(handle){if(!handle){throwBindingError("Cannot use deleted val. handle = "+handle)}return emval_handle_array[handle].value}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType))}return impl}function __emval_as(handle,returnType,destructorsRef){handle=requireHandle(handle);returnType=requireRegisteredType(returnType,"emval::as");var destructors=[];var rd=__emval_register(destructors);HEAP32[destructorsRef>>2]=rd;return returnType["toWireType"](destructors,handle)}function __emval_allocateDestructors(destructorsRef){var destructors=[];HEAP32[destructorsRef>>2]=__emval_register(destructors);return destructors}var emval_symbols={};function getStringOrSymbol(address){var symbol=emval_symbols[address];if(symbol===undefined){return readLatin1String(address)}else{return symbol}}var emval_methodCallers=[];function __emval_call_method(caller,handle,methodName,destructorsRef,args){caller=emval_methodCallers[caller];handle=requireHandle(handle);methodName=getStringOrSymbol(methodName);return caller(handle,methodName,__emval_allocateDestructors(destructorsRef),args)}function __emval_call_void_method(caller,handle,methodName,args){caller=emval_methodCallers[caller];handle=requireHandle(handle);methodName=getStringOrSymbol(methodName);caller(handle,methodName,null,args)}function emval_get_global(){return(function(){return Function})()("return this")()}function __emval_get_global(name){if(name===0){return __emval_register(emval_get_global())}else{name=getStringOrSymbol(name);return __emval_register(emval_get_global()[name])}}function __emval_addMethodCaller(caller){var id=emval_methodCallers.length;emval_methodCallers.push(caller);return id}function __emval_lookupTypes(argCount,argTypes,argWireTypes){var a=new Array(argCount);for(var i=0;i<argCount;++i){a[i]=requireRegisteredType(HEAP32[(argTypes>>2)+i],"parameter "+i)}return a}function __emval_get_method_caller(argCount,argTypes){var types=__emval_lookupTypes(argCount,argTypes);var retType=types[0];var signatureName=retType.name+"_$"+types.slice(1).map((function(t){return t.name})).join("_")+"$";var params=["retType"];var args=[retType];var argsList="";for(var i=0;i<argCount-1;++i){argsList+=(i!==0?", ":"")+"arg"+i;params.push("argType"+i);args.push(types[1+i])}var functionName=makeLegalFunctionName("methodCaller_"+signatureName);var functionBody="return function "+functionName+"(handle, name, destructors, args) {\n";var offset=0;for(var i=0;i<argCount-1;++i){functionBody+="    var arg"+i+" = argType"+i+".readValueFromPointer(args"+(offset?"+"+offset:"")+");\n";offset+=types[i+1]["argPackAdvance"]}functionBody+="    var rv = handle[name]("+argsList+");\n";for(var i=0;i<argCount-1;++i){if(types[i+1]["deleteObject"]){functionBody+="    argType"+i+".deleteObject(arg"+i+");\n"}}if(!retType.isVoid){functionBody+="    return retType.toWireType(destructors, rv);\n"}functionBody+="};\n";params.push(functionBody);var invokerFunction=new_(Function,params).apply(null,args);return __emval_addMethodCaller(invokerFunction)}function __emval_get_property(handle,key){handle=requireHandle(handle);key=requireHandle(key);return __emval_register(handle[key])}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1}}function craftEmvalAllocator(argCount){var argsList="";for(var i=0;i<argCount;++i){argsList+=(i!==0?", ":"")+"arg"+i}var functionBody="return function emval_allocator_"+argCount+"(constructor, argTypes, args) {\n";for(var i=0;i<argCount;++i){functionBody+="var argType"+i+" = requireRegisteredType(Module['HEAP32'][(argTypes >> 2) + "+i+'], "parameter '+i+'");\n'+"var arg"+i+" = argType"+i+".readValueFromPointer(args);\n"+"args += argType"+i+"['argPackAdvance'];\n"}functionBody+="var obj = new constructor("+argsList+");\n"+"return __emval_register(obj);\n"+"}\n";return(new Function("requireRegisteredType","Module","__emval_register",functionBody))(requireRegisteredType,Module,__emval_register)}var emval_newers={};function __emval_new(handle,argCount,argTypes,args){handle=requireHandle(handle);var newer=emval_newers[argCount];if(!newer){newer=craftEmvalAllocator(argCount);emval_newers[argCount]=newer}return newer(handle,argTypes,args)}function __emval_new_cstring(v){return __emval_register(getStringOrSymbol(v))}function __emval_run_destructors(handle){var destructors=emval_handle_array[handle].value;runDestructors(destructors);__emval_decref(handle)}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return __emval_register(v)}function _abort(){Module["abort"]()}function _emscripten_get_heap_size(){return TOTAL_MEMORY}function _emscripten_resize_heap(requestedSize){abortOnCannotGrowMemory()}var ENV={};function _getenv(name){if(name===0)return 0;name=UTF8ToString(name);if(!ENV.hasOwnProperty(name))return 0;if(_getenv.ret)_free(_getenv.ret);_getenv.ret=allocateUTF8(ENV[name]);return _getenv.ret}function _llvm_stackrestore(p){var self=_llvm_stacksave;var ret=self.LLVM_SAVEDSTACKS[p];self.LLVM_SAVEDSTACKS.splice(p,1);stackRestore(ret)}function _llvm_stacksave(){var self=_llvm_stacksave;if(!self.LLVM_SAVEDSTACKS){self.LLVM_SAVEDSTACKS=[]}self.LLVM_SAVEDSTACKS.push(stackSave());return self.LLVM_SAVEDSTACKS.length-1}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest)}function _pthread_cond_wait(){return 0}var PTHREAD_SPECIFIC={};function _pthread_getspecific(key){return PTHREAD_SPECIFIC[key]||0}var PTHREAD_SPECIFIC_NEXT_KEY=1;function _pthread_key_create(key,destructor){if(key==0){return ERRNO_CODES.EINVAL}HEAP32[key>>2]=PTHREAD_SPECIFIC_NEXT_KEY;PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY]=0;PTHREAD_SPECIFIC_NEXT_KEY++;return 0}function _pthread_once(ptr,func){if(!_pthread_once.seen)_pthread_once.seen={};if(ptr in _pthread_once.seen)return;Module["dynCall_v"](func);_pthread_once.seen[ptr]=1}function _pthread_setspecific(key,value){if(!(key in PTHREAD_SPECIFIC)){return ERRNO_CODES.EINVAL}PTHREAD_SPECIFIC[key]=value;return 0}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]);return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule])}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value==="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":(function(date){return WEEKDAYS[date.tm_wday].substring(0,3)}),"%A":(function(date){return WEEKDAYS[date.tm_wday]}),"%b":(function(date){return MONTHS[date.tm_mon].substring(0,3)}),"%B":(function(date){return MONTHS[date.tm_mon]}),"%C":(function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)}),"%d":(function(date){return leadingNulls(date.tm_mday,2)}),"%e":(function(date){return leadingSomething(date.tm_mday,2," ")}),"%g":(function(date){return getWeekBasedYear(date).toString().substring(2)}),"%G":(function(date){return getWeekBasedYear(date)}),"%H":(function(date){return leadingNulls(date.tm_hour,2)}),"%I":(function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)}),"%j":(function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)}),"%m":(function(date){return leadingNulls(date.tm_mon+1,2)}),"%M":(function(date){return leadingNulls(date.tm_min,2)}),"%n":(function(){return"\n"}),"%p":(function(date){if(date.tm_hour>=0&&date.tm_hour<12){return"AM"}else{return"PM"}}),"%S":(function(date){return leadingNulls(date.tm_sec,2)}),"%t":(function(){return"\t"}),"%u":(function(date){var day=new Date(date.tm_year+1900,date.tm_mon+1,date.tm_mday,0,0,0,0);return day.getDay()||7}),"%U":(function(date){var janFirst=new Date(date.tm_year+1900,0,1);var firstSunday=janFirst.getDay()===0?janFirst:__addDays(janFirst,7-janFirst.getDay());var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstSunday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstSundayUntilEndJanuary=31-firstSunday.getDate();var days=firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstSunday,janFirst)===0?"01":"00"}),"%V":(function(date){var janFourthThisYear=new Date(date.tm_year+1900,0,4);var janFourthNextYear=new Date(date.tm_year+1901,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);var endDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);if(compareByDay(endDate,firstWeekStartThisYear)<0){return"53"}if(compareByDay(firstWeekStartNextYear,endDate)<=0){return"01"}var daysDifference;if(firstWeekStartThisYear.getFullYear()<date.tm_year+1900){daysDifference=date.tm_yday+32-firstWeekStartThisYear.getDate()}else{daysDifference=date.tm_yday+1-firstWeekStartThisYear.getDate()}return leadingNulls(Math.ceil(daysDifference/7),2)}),"%w":(function(date){var day=new Date(date.tm_year+1900,date.tm_mon+1,date.tm_mday,0,0,0,0);return day.getDay()}),"%W":(function(date){var janFirst=new Date(date.tm_year,0,1);var firstMonday=janFirst.getDay()===1?janFirst:__addDays(janFirst,janFirst.getDay()===0?1:7-janFirst.getDay()+1);var endDate=new Date(date.tm_year+1900,date.tm_mon,date.tm_mday);if(compareByDay(firstMonday,endDate)<0){var februaryFirstUntilEndMonth=__arraySum(__isLeapYear(endDate.getFullYear())?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,endDate.getMonth()-1)-31;var firstMondayUntilEndJanuary=31-firstMonday.getDate();var days=firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();return leadingNulls(Math.ceil(days/7),2)}return compareByDay(firstMonday,janFirst)===0?"01":"00"}),"%y":(function(date){return(date.tm_year+1900).toString().substring(2)}),"%Y":(function(date){return date.tm_year+1900}),"%z":(function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?"+":"-")+String("0000"+off).slice(-4)}),"%Z":(function(date){return date.tm_zone}),"%%":(function(){return"%"})};for(var rule in EXPANSION_RULES_2){if(pattern.indexOf(rule)>=0){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date))}}var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}FS.staticInit();__ATINIT__.unshift((function(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init()}));__ATMAIN__.push((function(){FS.ignorePermissions=false}));__ATEXIT__.push((function(){FS.quit()}));__ATINIT__.unshift((function(){TTY.init()}));__ATEXIT__.push((function(){TTY.shutdown()}));if(ENVIRONMENT_IS_NODE){var fs=require("fs");var NODEJS_PATH=require("path");NODEFS.staticInit()}embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_ClassHandle();init_RegisteredPointer();init_embind();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");init_emval();var ASSERTIONS=false;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255){if(ASSERTIONS){assert(false,"Character code "+chr+" ("+String.fromCharCode(chr)+")  at offset "+i+" not in 0x00-0xFF.")}chr&=255}ret.push(String.fromCharCode(chr))}return ret.join("")}var decodeBase64=typeof atob==="function"?atob:(function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output});function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}Module["wasmTableSize"]=740;Module["wasmMaxTableSize"]=740;var asmGlobalArg={};Module.asmLibraryArg={"abort":abort,"assert":assert,"setTempRet0":setTempRet0,"getTempRet0":getTempRet0,"abortOnCannotGrowMemory":abortOnCannotGrowMemory,"ClassHandle":ClassHandle,"ClassHandle_clone":ClassHandle_clone,"ClassHandle_delete":ClassHandle_delete,"ClassHandle_deleteLater":ClassHandle_deleteLater,"ClassHandle_isAliasOf":ClassHandle_isAliasOf,"ClassHandle_isDeleted":ClassHandle_isDeleted,"RegisteredClass":RegisteredClass,"RegisteredPointer":RegisteredPointer,"RegisteredPointer_deleteObject":RegisteredPointer_deleteObject,"RegisteredPointer_destructor":RegisteredPointer_destructor,"RegisteredPointer_fromWireType":RegisteredPointer_fromWireType,"RegisteredPointer_getPointee":RegisteredPointer_getPointee,"___cxa_allocate_exception":___cxa_allocate_exception,"___cxa_begin_catch":___cxa_begin_catch,"___cxa_find_matching_catch":___cxa_find_matching_catch,"___cxa_free_exception":___cxa_free_exception,"___cxa_throw":___cxa_throw,"___cxa_uncaught_exception":___cxa_uncaught_exception,"___gxx_personality_v0":___gxx_personality_v0,"___lock":___lock,"___map_file":___map_file,"___resumeException":___resumeException,"___setErrNo":___setErrNo,"___syscall140":___syscall140,"___syscall145":___syscall145,"___syscall146":___syscall146,"___syscall221":___syscall221,"___syscall3":___syscall3,"___syscall5":___syscall5,"___syscall54":___syscall54,"___syscall6":___syscall6,"___syscall91":___syscall91,"___unlock":___unlock,"__addDays":__addDays,"__arraySum":__arraySum,"__embind_register_bool":__embind_register_bool,"__embind_register_class":__embind_register_class,"__embind_register_class_class_function":__embind_register_class_class_function,"__embind_register_class_class_property":__embind_register_class_class_property,"__embind_register_class_function":__embind_register_class_function,"__embind_register_constant":__embind_register_constant,"__embind_register_emval":__embind_register_emval,"__embind_register_float":__embind_register_float,"__embind_register_function":__embind_register_function,"__embind_register_integer":__embind_register_integer,"__embind_register_memory_view":__embind_register_memory_view,"__embind_register_std_string":__embind_register_std_string,"__embind_register_std_wstring":__embind_register_std_wstring,"__embind_register_void":__embind_register_void,"__emval_addMethodCaller":__emval_addMethodCaller,"__emval_allocateDestructors":__emval_allocateDestructors,"__emval_as":__emval_as,"__emval_call_method":__emval_call_method,"__emval_call_void_method":__emval_call_void_method,"__emval_decref":__emval_decref,"__emval_get_global":__emval_get_global,"__emval_get_method_caller":__emval_get_method_caller,"__emval_get_property":__emval_get_property,"__emval_incref":__emval_incref,"__emval_lookupTypes":__emval_lookupTypes,"__emval_new":__emval_new,"__emval_new_cstring":__emval_new_cstring,"__emval_register":__emval_register,"__emval_run_destructors":__emval_run_destructors,"__emval_take_value":__emval_take_value,"__isLeapYear":__isLeapYear,"_abort":_abort,"_embind_repr":_embind_repr,"_emscripten_get_heap_size":_emscripten_get_heap_size,"_emscripten_memcpy_big":_emscripten_memcpy_big,"_emscripten_resize_heap":_emscripten_resize_heap,"_getenv":_getenv,"_llvm_stackrestore":_llvm_stackrestore,"_llvm_stacksave":_llvm_stacksave,"_pthread_cond_wait":_pthread_cond_wait,"_pthread_getspecific":_pthread_getspecific,"_pthread_key_create":_pthread_key_create,"_pthread_once":_pthread_once,"_pthread_setspecific":_pthread_setspecific,"_strftime":_strftime,"_strftime_l":_strftime_l,"constNoSmartPtrRawPointerToWireType":constNoSmartPtrRawPointerToWireType,"count_emval_handles":count_emval_handles,"craftEmvalAllocator":craftEmvalAllocator,"craftInvokerFunction":craftInvokerFunction,"createNamedFunction":createNamedFunction,"downcastPointer":downcastPointer,"embind__requireFunction":embind__requireFunction,"embind_init_charCodes":embind_init_charCodes,"emval_get_global":emval_get_global,"ensureOverloadTable":ensureOverloadTable,"exposePublicSymbol":exposePublicSymbol,"extendError":extendError,"floatReadValueFromPointer":floatReadValueFromPointer,"flushPendingDeletes":flushPendingDeletes,"genericPointerToWireType":genericPointerToWireType,"getBasestPointer":getBasestPointer,"getInheritedInstance":getInheritedInstance,"getInheritedInstanceCount":getInheritedInstanceCount,"getLiveInheritedInstances":getLiveInheritedInstances,"getShiftFromSize":getShiftFromSize,"getStringOrSymbol":getStringOrSymbol,"getTypeName":getTypeName,"get_first_emval":get_first_emval,"heap32VectorToArray":heap32VectorToArray,"init_ClassHandle":init_ClassHandle,"init_RegisteredPointer":init_RegisteredPointer,"init_embind":init_embind,"init_emval":init_emval,"integerReadValueFromPointer":integerReadValueFromPointer,"makeClassHandle":makeClassHandle,"makeLegalFunctionName":makeLegalFunctionName,"new_":new_,"nonConstNoSmartPtrRawPointerToWireType":nonConstNoSmartPtrRawPointerToWireType,"readLatin1String":readLatin1String,"registerType":registerType,"replacePublicSymbol":replacePublicSymbol,"requireHandle":requireHandle,"requireRegisteredType":requireRegisteredType,"runDestructor":runDestructor,"runDestructors":runDestructors,"setDelayFunction":setDelayFunction,"shallowCopyInternalPointer":shallowCopyInternalPointer,"simpleReadValueFromPointer":simpleReadValueFromPointer,"throwBindingError":throwBindingError,"throwInstanceAlreadyDeleted":throwInstanceAlreadyDeleted,"throwInternalError":throwInternalError,"throwUnboundTypeError":throwUnboundTypeError,"upcastPointer":upcastPointer,"validateThis":validateThis,"whenDependentTypesAreResolved":whenDependentTypesAreResolved,"DYNAMICTOP_PTR":DYNAMICTOP_PTR,"tempDoublePtr":tempDoublePtr};var asm=Module["asm"](asmGlobalArg,Module.asmLibraryArg,buffer);var __GLOBAL__I_000101=Module["__GLOBAL__I_000101"]=asm["__GLOBAL__I_000101"];var __GLOBAL__sub_I_bind_cpp=Module["__GLOBAL__sub_I_bind_cpp"]=asm["__GLOBAL__sub_I_bind_cpp"];var __GLOBAL__sub_I_bls_cpp=Module["__GLOBAL__sub_I_bls_cpp"]=asm["__GLOBAL__sub_I_bls_cpp"];var __GLOBAL__sub_I_iostream_cpp=Module["__GLOBAL__sub_I_iostream_cpp"]=asm["__GLOBAL__sub_I_iostream_cpp"];var __GLOBAL__sub_I_jsbindings_cpp=Module["__GLOBAL__sub_I_jsbindings_cpp"]=asm["__GLOBAL__sub_I_jsbindings_cpp"];var __ZSt18uncaught_exceptionv=Module["__ZSt18uncaught_exceptionv"]=asm["__ZSt18uncaught_exceptionv"];var ___cxa_can_catch=Module["___cxa_can_catch"]=asm["___cxa_can_catch"];var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=asm["___cxa_is_pointer_type"];var ___errno_location=Module["___errno_location"]=asm["___errno_location"];var ___getTypeName=Module["___getTypeName"]=asm["___getTypeName"];var _free=Module["_free"]=asm["_free"];var _llvm_bswap_i32=Module["_llvm_bswap_i32"]=asm["_llvm_bswap_i32"];var _malloc=Module["_malloc"]=asm["_malloc"];var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _memmove=Module["_memmove"]=asm["_memmove"];var _memset=Module["_memset"]=asm["_memset"];var _pthread_cond_broadcast=Module["_pthread_cond_broadcast"]=asm["_pthread_cond_broadcast"];var _pthread_mutex_lock=Module["_pthread_mutex_lock"]=asm["_pthread_mutex_lock"];var _pthread_mutex_unlock=Module["_pthread_mutex_unlock"]=asm["_pthread_mutex_unlock"];var _sbrk=Module["_sbrk"]=asm["_sbrk"];var establishStackSpace=Module["establishStackSpace"]=asm["establishStackSpace"];var setThrew=Module["setThrew"]=asm["setThrew"];var stackAlloc=Module["stackAlloc"]=asm["stackAlloc"];var stackRestore=Module["stackRestore"]=asm["stackRestore"];var stackSave=Module["stackSave"]=asm["stackSave"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];var dynCall_iii=Module["dynCall_iii"]=asm["dynCall_iii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_iiiii=Module["dynCall_iiiii"]=asm["dynCall_iiiii"];var dynCall_iiiiid=Module["dynCall_iiiiid"]=asm["dynCall_iiiiid"];var dynCall_iiiiii=Module["dynCall_iiiiii"]=asm["dynCall_iiiiii"];var dynCall_iiiiiid=Module["dynCall_iiiiiid"]=asm["dynCall_iiiiiid"];var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=asm["dynCall_iiiiiii"];var dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=asm["dynCall_iiiiiiii"];var dynCall_iiiiiiiii=Module["dynCall_iiiiiiiii"]=asm["dynCall_iiiiiiiii"];var dynCall_iiiiij=Module["dynCall_iiiiij"]=asm["dynCall_iiiiij"];var dynCall_v=Module["dynCall_v"]=asm["dynCall_v"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];var dynCall_viii=Module["dynCall_viii"]=asm["dynCall_viii"];var dynCall_viiii=Module["dynCall_viiii"]=asm["dynCall_viiii"];var dynCall_viiiii=Module["dynCall_viiiii"]=asm["dynCall_viiiii"];var dynCall_viiiiii=Module["dynCall_viiiiii"]=asm["dynCall_viiiiii"];var dynCall_viijii=Module["dynCall_viijii"]=asm["dynCall_viijii"];Module["asm"]=asm;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};function run(args){args=args||Module["arguments"];if(runDependencies>0){return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout((function(){setTimeout((function(){Module["setStatus"]("")}),1);doRun()}),1)}else{doRun()}}Module["run"]=run;function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(what!==undefined){out(what);err(what);what=JSON.stringify(what)}else{what=""}ABORT=true;EXITSTATUS=1;throw"abort("+what+"). Build with -s ASSERTIONS=1 for more info."}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}Module["noExitRuntime"]=true;run()





  return Module;
}
)(typeof Module === 'object' ? Module : {});
if (typeof exports === 'object' && typeof module === 'object')
      module.exports = Module;
    else if (typeof define === 'function' && define['amd'])
      define([], function() { return Module; });
    else if (typeof exports === 'object')
      exports["Module"] = Module;
    
}).call(this,require('_process'),require("buffer").Buffer,"/node_modules/bls-signatures")
},{"_process":565,"buffer":98,"crypto":432,"fs":96,"path":558}],66:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buffer').Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":68}],67:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":68}],68:[function(require,module,exports){

},{}],69:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":590}],70:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":69,"./ghash":74,"./incr32":75,"buffer-xor":97,"cipher-base":99,"inherits":510,"safe-buffer":590}],71:[function(require,module,exports){
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":72,"./encrypter":73,"./modes/list.json":83}],72:[function(require,module,exports){
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./aes":69,"./authCipher":70,"./modes":82,"./streamCipher":85,"cipher-base":99,"evp_bytestokey":464,"inherits":510,"safe-buffer":590}],73:[function(require,module,exports){
var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./aes":69,"./authCipher":70,"./modes":82,"./streamCipher":85,"cipher-base":99,"evp_bytestokey":464,"inherits":510,"safe-buffer":590}],74:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":590}],75:[function(require,module,exports){
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],76:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":97}],77:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"buffer-xor":97,"safe-buffer":590}],78:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":590}],79:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":590}],80:[function(require,module,exports){
var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"../incr32":75,"buffer-xor":97,"safe-buffer":590}],81:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],82:[function(require,module,exports){
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./cbc":76,"./cfb":77,"./cfb1":78,"./cfb8":79,"./ctr":80,"./ecb":81,"./list.json":83,"./ofb":84}],83:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],84:[function(require,module,exports){
(function (Buffer){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this,require("buffer").Buffer)
},{"buffer":98,"buffer-xor":97}],85:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":69,"cipher-base":99,"inherits":510,"safe-buffer":590}],86:[function(require,module,exports){
var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":71,"browserify-aes/modes":82,"browserify-des":87,"browserify-des/modes":88,"evp_bytestokey":464}],87:[function(require,module,exports){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

},{"cipher-base":99,"des.js":435,"inherits":510,"safe-buffer":590}],88:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],89:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
var randomBytes = require('randombytes');
module.exports = crt;
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p);
  h.imul(q);
  m2.iadd(h);
  return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
}
crt.getr = getr;
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r = new bn(randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
    r = new bn(randomBytes(len));
  }
  return r;
}

}).call(this,require("buffer").Buffer)
},{"bn.js":66,"buffer":98,"randombytes":573}],90:[function(require,module,exports){
module.exports = require('./browser/algorithms.json')

},{"./browser/algorithms.json":91}],91:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],92:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],93:[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash')
var stream = require('stream')
var inherits = require('inherits')
var sign = require('./sign')
var verify = require('./verify')

var algorithms = require('./algorithms.json')
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = new Buffer(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = new Buffer(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = new Buffer(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

}).call(this,require("buffer").Buffer)
},{"./algorithms.json":91,"./sign":94,"./verify":95,"buffer":98,"create-hash":428,"inherits":510,"stream":600}],94:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var EC = require('elliptic').ec
var BN = require('bn.js')
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [ 0, 1 ]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return new Buffer(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [ 0 ].concat(r)
  if (s[0] & 0x80) s = [ 0 ].concat(s)

  var total = r.length + s.length + 4
  var res = [ 0x30, total, 0x02, r.length ]
  res = res.concat(r, [ 0x02, s.length ], s)
  return new Buffer(res)
}

function getKey (x, q, hash, algo) {
  x = new Buffer(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length)
    zeros.fill(0)
    x = Buffer.concat([ zeros, x ])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = new Buffer(hlen)
  v.fill(1)
  var k = new Buffer(hlen)
  k.fill(0)
  k = createHmac(algo, k).update(v).update(new Buffer([ 0 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(new Buffer([ 1 ])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = new Buffer(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length)
    zeros.fill(0)
    out = Buffer.concat([ zeros, out ])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = new Buffer(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([ t, kv.v ])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([ 0 ])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

}).call(this,require("buffer").Buffer)
},{"./curves.json":92,"bn.js":66,"browserify-rsa":89,"buffer":98,"create-hmac":430,"elliptic":445,"parse-asn1":557}],95:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var BN = require('bn.js')
var EC = require('elliptic').ec
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [ 1 ]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = new Buffer(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = new Buffer(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

}).call(this,require("buffer").Buffer)
},{"./curves.json":92,"bn.js":66,"buffer":98,"elliptic":445,"parse-asn1":557}],96:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"dup":68}],97:[function(require,module,exports){
(function (Buffer){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this,require("buffer").Buffer)
},{"buffer":98}],98:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":64,"buffer":98,"ieee754":509}],99:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":510,"safe-buffer":590,"stream":600,"string_decoder":601}],100:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],101:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":116}],102:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":141,"./_wks":226}],103:[function(require,module,exports){
'use strict';
var at = require('./_string-at')(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

},{"./_string-at":203}],104:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],105:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":150}],106:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":211,"./_to-length":215,"./_to-object":216}],107:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":211,"./_to-length":215,"./_to-object":216}],108:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":137}],109:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":211,"./_to-iobject":214,"./_to-length":215}],110:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":113,"./_ctx":123,"./_iobject":146,"./_to-length":215,"./_to-object":216}],111:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":100,"./_iobject":146,"./_to-length":215,"./_to-object":216}],112:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":148,"./_is-object":150,"./_wks":226}],113:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":112}],114:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":100,"./_invoke":145,"./_is-object":150}],115:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":116,"./_wks":226}],116:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],117:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":104,"./_ctx":123,"./_descriptors":127,"./_for-of":137,"./_iter-define":154,"./_iter-step":156,"./_meta":164,"./_object-create":169,"./_object-dp":170,"./_redefine-all":189,"./_set-species":197,"./_validate-collection":223}],118:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":108,"./_classof":115}],119:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":104,"./_an-object":105,"./_array-methods":110,"./_for-of":137,"./_has":140,"./_is-object":150,"./_meta":164,"./_redefine-all":189,"./_validate-collection":223}],120:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":104,"./_export":131,"./_fails":133,"./_for-of":137,"./_global":139,"./_inherit-if-required":144,"./_is-object":150,"./_iter-detect":155,"./_meta":164,"./_redefine":190,"./_redefine-all":189,"./_set-to-string-tag":198}],121:[function(require,module,exports){
var core = module.exports = { version: '2.6.9' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],122:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":170,"./_property-desc":188}],123:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":100}],124:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":133}],125:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":105,"./_to-primitive":217}],126:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],127:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":133}],128:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":139,"./_is-object":150}],129:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],130:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":176,"./_object-keys":179,"./_object-pie":180}],131:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":121,"./_ctx":123,"./_global":139,"./_hide":141,"./_redefine":190}],132:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":226}],133:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],134:[function(require,module,exports){
'use strict';
require('./es6.regexp.exec');
var redefine = require('./_redefine');
var hide = require('./_hide');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');
var regexpExec = require('./_regexp-exec');

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":126,"./_fails":133,"./_hide":141,"./_redefine":190,"./_regexp-exec":192,"./_wks":226,"./es6.regexp.exec":322}],135:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":105}],136:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":123,"./_is-array":148,"./_is-object":150,"./_to-length":215,"./_wks":226}],137:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":105,"./_ctx":123,"./_is-array-iter":147,"./_iter-call":152,"./_to-length":215,"./core.get-iterator-method":227}],138:[function(require,module,exports){
module.exports = require('./_shared')('native-function-to-string', Function.toString);

},{"./_shared":200}],139:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],140:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],141:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":127,"./_object-dp":170,"./_property-desc":188}],142:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":139}],143:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":127,"./_dom-create":128,"./_fails":133}],144:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":150,"./_set-proto":196}],145:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],146:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":116}],147:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":157,"./_wks":226}],148:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":116}],149:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":150}],150:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],151:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":116,"./_is-object":150,"./_wks":226}],152:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":105}],153:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":141,"./_object-create":169,"./_property-desc":188,"./_set-to-string-tag":198,"./_wks":226}],154:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":131,"./_hide":141,"./_iter-create":153,"./_iterators":157,"./_library":158,"./_object-gpo":177,"./_redefine":190,"./_set-to-string-tag":198,"./_wks":226}],155:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":226}],156:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],157:[function(require,module,exports){
module.exports = {};

},{}],158:[function(require,module,exports){
module.exports = false;

},{}],159:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],160:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":163}],161:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],162:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],163:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],164:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":133,"./_has":140,"./_is-object":150,"./_object-dp":170,"./_uid":221}],165:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":131,"./_shared":200,"./es6.map":257,"./es6.weak-map":364}],166:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":116,"./_global":139,"./_task":210}],167:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":100}],168:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;

},{"./_descriptors":127,"./_fails":133,"./_iobject":146,"./_object-gops":176,"./_object-keys":179,"./_object-pie":180,"./_to-object":216}],169:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":105,"./_dom-create":128,"./_enum-bug-keys":129,"./_html":142,"./_object-dps":171,"./_shared-key":199}],170:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":105,"./_descriptors":127,"./_ie8-dom-define":143,"./_to-primitive":217}],171:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":105,"./_descriptors":127,"./_object-dp":170,"./_object-keys":179}],172:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":133,"./_global":139,"./_library":158}],173:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":127,"./_has":140,"./_ie8-dom-define":143,"./_object-pie":180,"./_property-desc":188,"./_to-iobject":214,"./_to-primitive":217}],174:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":175,"./_to-iobject":214}],175:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":129,"./_object-keys-internal":178}],176:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],177:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":140,"./_shared-key":199,"./_to-object":216}],178:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":109,"./_has":140,"./_shared-key":199,"./_to-iobject":214}],179:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":129,"./_object-keys-internal":178}],180:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],181:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":121,"./_export":131,"./_fails":133}],182:[function(require,module,exports){
var DESCRIPTORS = require('./_descriptors');
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

},{"./_descriptors":127,"./_object-keys":179,"./_object-pie":180,"./_to-iobject":214}],183:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":105,"./_global":139,"./_object-gopn":175,"./_object-gops":176}],184:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":139,"./_string-trim":208,"./_string-ws":209}],185:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":139,"./_string-trim":208,"./_string-ws":209}],186:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],187:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":105,"./_is-object":150,"./_new-promise-capability":167}],188:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],189:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":190}],190:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var $toString = require('./_function-to-string');
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":121,"./_function-to-string":138,"./_global":139,"./_has":140,"./_hide":141,"./_uid":221}],191:[function(require,module,exports){
'use strict';

var classof = require('./_classof');
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};

},{"./_classof":115}],192:[function(require,module,exports){
'use strict';

var regexpFlags = require('./_flags');

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

},{"./_flags":135}],193:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],194:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":100,"./_ctx":123,"./_export":131,"./_for-of":137}],195:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":131}],196:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":105,"./_ctx":123,"./_is-object":150,"./_object-gopd":173}],197:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":127,"./_global":139,"./_object-dp":170,"./_wks":226}],198:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":140,"./_object-dp":170,"./_wks":226}],199:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":200,"./_uid":221}],200:[function(require,module,exports){
var core = require('./_core');
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: require('./_library') ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

},{"./_core":121,"./_global":139,"./_library":158}],201:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":100,"./_an-object":105,"./_wks":226}],202:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":133}],203:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":126,"./_to-integer":213}],204:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":126,"./_is-regexp":151}],205:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":126,"./_export":131,"./_fails":133}],206:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":126,"./_string-repeat":207,"./_to-length":215}],207:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":126,"./_to-integer":213}],208:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":126,"./_export":131,"./_fails":133,"./_string-ws":209}],209:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],210:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":116,"./_ctx":123,"./_dom-create":128,"./_global":139,"./_html":142,"./_invoke":145}],211:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":213}],212:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":213,"./_to-length":215}],213:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],214:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":126,"./_iobject":146}],215:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":213}],216:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":126}],217:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":150}],218:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":104,"./_array-copy-within":106,"./_array-fill":107,"./_array-includes":109,"./_array-methods":110,"./_classof":115,"./_ctx":123,"./_descriptors":127,"./_export":131,"./_fails":133,"./_global":139,"./_has":140,"./_hide":141,"./_is-array-iter":147,"./_is-object":150,"./_iter-detect":155,"./_iterators":157,"./_library":158,"./_object-create":169,"./_object-dp":170,"./_object-gopd":173,"./_object-gopn":175,"./_object-gpo":177,"./_property-desc":188,"./_redefine-all":189,"./_set-species":197,"./_species-constructor":201,"./_to-absolute-index":211,"./_to-index":212,"./_to-integer":213,"./_to-length":215,"./_to-object":216,"./_to-primitive":217,"./_typed":220,"./_typed-buffer":219,"./_uid":221,"./_wks":226,"./core.get-iterator-method":227,"./es6.array.iterator":238}],219:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":104,"./_array-fill":107,"./_descriptors":127,"./_fails":133,"./_global":139,"./_hide":141,"./_library":158,"./_object-dp":170,"./_object-gopn":175,"./_redefine-all":189,"./_set-to-string-tag":198,"./_to-index":212,"./_to-integer":213,"./_to-length":215,"./_typed":220}],220:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":139,"./_hide":141,"./_uid":221}],221:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],222:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":139}],223:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":150}],224:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":121,"./_global":139,"./_library":158,"./_object-dp":170,"./_wks-ext":225}],225:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":226}],226:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":139,"./_shared":200,"./_uid":221}],227:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":115,"./_core":121,"./_iterators":157,"./_wks":226}],228:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":102,"./_array-copy-within":106,"./_export":131}],229:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":110,"./_export":131,"./_strict-method":202}],230:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":102,"./_array-fill":107,"./_export":131}],231:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":110,"./_export":131,"./_strict-method":202}],232:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":102,"./_array-methods":110,"./_export":131}],233:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":102,"./_array-methods":110,"./_export":131}],234:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":110,"./_export":131,"./_strict-method":202}],235:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":122,"./_ctx":123,"./_export":131,"./_is-array-iter":147,"./_iter-call":152,"./_iter-detect":155,"./_to-length":215,"./_to-object":216,"./core.get-iterator-method":227}],236:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":109,"./_export":131,"./_strict-method":202}],237:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":131,"./_is-array":148}],238:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":102,"./_iter-define":154,"./_iter-step":156,"./_iterators":157,"./_to-iobject":214}],239:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":131,"./_iobject":146,"./_strict-method":202,"./_to-iobject":214}],240:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":131,"./_strict-method":202,"./_to-integer":213,"./_to-iobject":214,"./_to-length":215}],241:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":110,"./_export":131,"./_strict-method":202}],242:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":122,"./_export":131,"./_fails":133}],243:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":111,"./_export":131,"./_strict-method":202}],244:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":111,"./_export":131,"./_strict-method":202}],245:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":116,"./_export":131,"./_fails":133,"./_html":142,"./_to-absolute-index":211,"./_to-length":215}],246:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":110,"./_export":131,"./_strict-method":202}],247:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":100,"./_export":131,"./_fails":133,"./_strict-method":202,"./_to-object":216}],248:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":197}],249:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":131}],250:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":124,"./_export":131}],251:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":131,"./_fails":133,"./_to-object":216,"./_to-primitive":217}],252:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":125,"./_hide":141,"./_wks":226}],253:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":190}],254:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":114,"./_export":131}],255:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":150,"./_object-dp":170,"./_object-gpo":177,"./_wks":226}],256:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":127,"./_object-dp":170}],257:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":120,"./_collection-strong":117,"./_validate-collection":223}],258:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":131,"./_math-log1p":161}],259:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":131}],260:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":131}],261:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":131,"./_math-sign":163}],262:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":131}],263:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":131}],264:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":131,"./_math-expm1":159}],265:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":131,"./_math-fround":160}],266:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":131}],267:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":131,"./_fails":133}],268:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":131}],269:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":131,"./_math-log1p":161}],270:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":131}],271:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":131,"./_math-sign":163}],272:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":131,"./_fails":133,"./_math-expm1":159}],273:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":131,"./_math-expm1":159}],274:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":131}],275:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":116,"./_descriptors":127,"./_fails":133,"./_global":139,"./_has":140,"./_inherit-if-required":144,"./_object-create":169,"./_object-dp":170,"./_object-gopd":173,"./_object-gopn":175,"./_redefine":190,"./_string-trim":208,"./_to-primitive":217}],276:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":131}],277:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":131,"./_global":139}],278:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":131,"./_is-integer":149}],279:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":131}],280:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":131,"./_is-integer":149}],281:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":131}],282:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":131}],283:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":131,"./_parse-float":184}],284:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":131,"./_parse-int":185}],285:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":101,"./_export":131,"./_fails":133,"./_string-repeat":207,"./_to-integer":213}],286:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":101,"./_export":131,"./_fails":133}],287:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":131,"./_object-assign":168}],288:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":131,"./_object-create":169}],289:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":127,"./_export":131,"./_object-dps":171}],290:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":127,"./_export":131,"./_object-dp":170}],291:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":150,"./_meta":164,"./_object-sap":181}],292:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":173,"./_object-sap":181,"./_to-iobject":214}],293:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":174,"./_object-sap":181}],294:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":177,"./_object-sap":181,"./_to-object":216}],295:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":150,"./_object-sap":181}],296:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":150,"./_object-sap":181}],297:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":150,"./_object-sap":181}],298:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":131,"./_same-value":193}],299:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":179,"./_object-sap":181,"./_to-object":216}],300:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":150,"./_meta":164,"./_object-sap":181}],301:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":150,"./_meta":164,"./_object-sap":181}],302:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":131,"./_set-proto":196}],303:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":115,"./_redefine":190,"./_wks":226}],304:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":131,"./_parse-float":184}],305:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":131,"./_parse-int":185}],306:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var userAgent = require('./_user-agent');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":100,"./_an-instance":104,"./_classof":115,"./_core":121,"./_ctx":123,"./_export":131,"./_for-of":137,"./_global":139,"./_is-object":150,"./_iter-detect":155,"./_library":158,"./_microtask":166,"./_new-promise-capability":167,"./_perform":186,"./_promise-resolve":187,"./_redefine-all":189,"./_set-species":197,"./_set-to-string-tag":198,"./_species-constructor":201,"./_task":210,"./_user-agent":222,"./_wks":226}],307:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":100,"./_an-object":105,"./_export":131,"./_fails":133,"./_global":139}],308:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":100,"./_an-object":105,"./_bind":114,"./_export":131,"./_fails":133,"./_global":139,"./_is-object":150,"./_object-create":169}],309:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":105,"./_export":131,"./_fails":133,"./_object-dp":170,"./_to-primitive":217}],310:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":105,"./_export":131,"./_object-gopd":173}],311:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":105,"./_export":131,"./_iter-create":153}],312:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":105,"./_export":131,"./_object-gopd":173}],313:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":105,"./_export":131,"./_object-gpo":177}],314:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":105,"./_export":131,"./_has":140,"./_is-object":150,"./_object-gopd":173,"./_object-gpo":177}],315:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":131}],316:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":105,"./_export":131}],317:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":131,"./_own-keys":183}],318:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":105,"./_export":131}],319:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":131,"./_set-proto":196}],320:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":105,"./_export":131,"./_has":140,"./_is-object":150,"./_object-dp":170,"./_object-gopd":173,"./_object-gpo":177,"./_property-desc":188}],321:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":127,"./_fails":133,"./_flags":135,"./_global":139,"./_inherit-if-required":144,"./_is-regexp":151,"./_object-dp":170,"./_object-gopn":175,"./_redefine":190,"./_set-species":197,"./_wks":226}],322:[function(require,module,exports){
'use strict';
var regexpExec = require('./_regexp-exec');
require('./_export')({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

},{"./_export":131,"./_regexp-exec":192}],323:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":127,"./_flags":135,"./_object-dp":170}],324:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object');
var toLength = require('./_to-length');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');

// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});

},{"./_advance-string-index":103,"./_an-object":105,"./_fix-re-wks":134,"./_regexp-exec-abstract":191,"./_to-length":215}],325:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var advanceStringIndex = require('./_advance-string-index');
var regExpExec = require('./_regexp-exec-abstract');
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});

},{"./_advance-string-index":103,"./_an-object":105,"./_fix-re-wks":134,"./_regexp-exec-abstract":191,"./_to-integer":213,"./_to-length":215,"./_to-object":216}],326:[function(require,module,exports){
'use strict';

var anObject = require('./_an-object');
var sameValue = require('./_same-value');
var regExpExec = require('./_regexp-exec-abstract');

// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});

},{"./_an-object":105,"./_fix-re-wks":134,"./_regexp-exec-abstract":191,"./_same-value":193}],327:[function(require,module,exports){
'use strict';

var isRegExp = require('./_is-regexp');
var anObject = require('./_an-object');
var speciesConstructor = require('./_species-constructor');
var advanceStringIndex = require('./_advance-string-index');
var toLength = require('./_to-length');
var callRegExpExec = require('./_regexp-exec-abstract');
var regexpExec = require('./_regexp-exec');
var fails = require('./_fails');
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});

},{"./_advance-string-index":103,"./_an-object":105,"./_fails":133,"./_fix-re-wks":134,"./_is-regexp":151,"./_regexp-exec":192,"./_regexp-exec-abstract":191,"./_species-constructor":201,"./_to-length":215}],328:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":105,"./_descriptors":127,"./_fails":133,"./_flags":135,"./_redefine":190,"./es6.regexp.flags":323}],329:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":120,"./_collection-strong":117,"./_validate-collection":223}],330:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":205}],331:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":205}],332:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":205}],333:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":205}],334:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":131,"./_string-at":203}],335:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":131,"./_fails-is-regexp":132,"./_string-context":204,"./_to-length":215}],336:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":205}],337:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":205}],338:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":205}],339:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":131,"./_to-absolute-index":211}],340:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":131,"./_fails-is-regexp":132,"./_string-context":204}],341:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":205}],342:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":154,"./_string-at":203}],343:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":205}],344:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":131,"./_to-iobject":214,"./_to-length":215}],345:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":131,"./_string-repeat":207}],346:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":205}],347:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":131,"./_fails-is-regexp":132,"./_string-context":204,"./_to-length":215}],348:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":205}],349:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":205}],350:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":205}],351:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":208}],352:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toObject = require('./_to-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $GOPS = require('./_object-gops');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":105,"./_descriptors":127,"./_enum-keys":130,"./_export":131,"./_fails":133,"./_global":139,"./_has":140,"./_hide":141,"./_is-array":148,"./_is-object":150,"./_library":158,"./_meta":164,"./_object-create":169,"./_object-dp":170,"./_object-gopd":173,"./_object-gopn":175,"./_object-gopn-ext":174,"./_object-gops":176,"./_object-keys":179,"./_object-pie":180,"./_property-desc":188,"./_redefine":190,"./_set-to-string-tag":198,"./_shared":200,"./_to-iobject":214,"./_to-object":216,"./_to-primitive":217,"./_uid":221,"./_wks":226,"./_wks-define":224,"./_wks-ext":225}],353:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":105,"./_export":131,"./_fails":133,"./_global":139,"./_is-object":150,"./_set-species":197,"./_species-constructor":201,"./_to-absolute-index":211,"./_to-length":215,"./_typed":220,"./_typed-buffer":219}],354:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":131,"./_typed":220,"./_typed-buffer":219}],355:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],356:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],357:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],358:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],359:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],360:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],361:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],362:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":218}],363:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":218}],364:[function(require,module,exports){
'use strict';
var global = require('./_global');
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var validate = require('./_validate-collection');
var NATIVE_WEAK_MAP = require('./_validate-collection');
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":110,"./_collection":120,"./_collection-weak":119,"./_global":139,"./_is-object":150,"./_meta":164,"./_object-assign":168,"./_redefine":190,"./_validate-collection":223}],365:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":120,"./_collection-weak":119,"./_validate-collection":223}],366:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":100,"./_add-to-unscopables":102,"./_array-species-create":113,"./_export":131,"./_flatten-into-array":136,"./_to-length":215,"./_to-object":216}],367:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":102,"./_array-species-create":113,"./_export":131,"./_flatten-into-array":136,"./_to-integer":213,"./_to-length":215,"./_to-object":216}],368:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":102,"./_array-includes":109,"./_export":131}],369:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":116,"./_export":131,"./_global":139,"./_microtask":166}],370:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":116,"./_export":131}],371:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":131,"./_global":139}],372:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":194}],373:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":195}],374:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":118,"./_export":131}],375:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":131}],376:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":131}],377:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":131}],378:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":131,"./_math-fround":160,"./_math-scale":162}],379:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":131}],380:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":131}],381:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":131}],382:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":131}],383:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":131}],384:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":131,"./_math-scale":162}],385:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":131}],386:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":131}],387:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":100,"./_descriptors":127,"./_export":131,"./_object-dp":170,"./_object-forced-pam":172,"./_to-object":216}],388:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":100,"./_descriptors":127,"./_export":131,"./_object-dp":170,"./_object-forced-pam":172,"./_to-object":216}],389:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":131,"./_object-to-array":182}],390:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":122,"./_export":131,"./_object-gopd":173,"./_own-keys":183,"./_to-iobject":214}],391:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":127,"./_export":131,"./_object-forced-pam":172,"./_object-gopd":173,"./_object-gpo":177,"./_to-object":216,"./_to-primitive":217}],392:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":127,"./_export":131,"./_object-forced-pam":172,"./_object-gopd":173,"./_object-gpo":177,"./_to-object":216,"./_to-primitive":217}],393:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":131,"./_object-to-array":182}],394:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":100,"./_an-instance":104,"./_an-object":105,"./_core":121,"./_export":131,"./_for-of":137,"./_global":139,"./_hide":141,"./_microtask":166,"./_redefine-all":189,"./_set-species":197,"./_wks":226}],395:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":121,"./_export":131,"./_global":139,"./_promise-resolve":187,"./_species-constructor":201}],396:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":131,"./_new-promise-capability":167,"./_perform":186}],397:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":105,"./_metadata":165}],398:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":105,"./_metadata":165}],399:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":105,"./_array-from-iterable":108,"./_metadata":165,"./_object-gpo":177,"./es6.set":329}],400:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":105,"./_metadata":165,"./_object-gpo":177}],401:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":105,"./_metadata":165}],402:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":105,"./_metadata":165}],403:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":105,"./_metadata":165,"./_object-gpo":177}],404:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":105,"./_metadata":165}],405:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":100,"./_an-object":105,"./_metadata":165}],406:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":194}],407:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":195}],408:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":118,"./_export":131}],409:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":131,"./_string-at":203}],410:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":126,"./_export":131,"./_flags":135,"./_is-regexp":151,"./_iter-create":153,"./_to-length":215}],411:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":131,"./_string-pad":206,"./_user-agent":222}],412:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":131,"./_string-pad":206,"./_user-agent":222}],413:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":208}],414:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":208}],415:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":224}],416:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":224}],417:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":131,"./_global":139}],418:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":194}],419:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":195}],420:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":194}],421:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":195}],422:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":139,"./_hide":141,"./_iterators":157,"./_object-keys":179,"./_redefine":190,"./_wks":226,"./es6.array.iterator":238}],423:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":131,"./_task":210}],424:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":131,"./_global":139,"./_user-agent":222}],425:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.exec');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":121,"./modules/es6.array.copy-within":228,"./modules/es6.array.every":229,"./modules/es6.array.fill":230,"./modules/es6.array.filter":231,"./modules/es6.array.find":233,"./modules/es6.array.find-index":232,"./modules/es6.array.for-each":234,"./modules/es6.array.from":235,"./modules/es6.array.index-of":236,"./modules/es6.array.is-array":237,"./modules/es6.array.iterator":238,"./modules/es6.array.join":239,"./modules/es6.array.last-index-of":240,"./modules/es6.array.map":241,"./modules/es6.array.of":242,"./modules/es6.array.reduce":244,"./modules/es6.array.reduce-right":243,"./modules/es6.array.slice":245,"./modules/es6.array.some":246,"./modules/es6.array.sort":247,"./modules/es6.array.species":248,"./modules/es6.date.now":249,"./modules/es6.date.to-iso-string":250,"./modules/es6.date.to-json":251,"./modules/es6.date.to-primitive":252,"./modules/es6.date.to-string":253,"./modules/es6.function.bind":254,"./modules/es6.function.has-instance":255,"./modules/es6.function.name":256,"./modules/es6.map":257,"./modules/es6.math.acosh":258,"./modules/es6.math.asinh":259,"./modules/es6.math.atanh":260,"./modules/es6.math.cbrt":261,"./modules/es6.math.clz32":262,"./modules/es6.math.cosh":263,"./modules/es6.math.expm1":264,"./modules/es6.math.fround":265,"./modules/es6.math.hypot":266,"./modules/es6.math.imul":267,"./modules/es6.math.log10":268,"./modules/es6.math.log1p":269,"./modules/es6.math.log2":270,"./modules/es6.math.sign":271,"./modules/es6.math.sinh":272,"./modules/es6.math.tanh":273,"./modules/es6.math.trunc":274,"./modules/es6.number.constructor":275,"./modules/es6.number.epsilon":276,"./modules/es6.number.is-finite":277,"./modules/es6.number.is-integer":278,"./modules/es6.number.is-nan":279,"./modules/es6.number.is-safe-integer":280,"./modules/es6.number.max-safe-integer":281,"./modules/es6.number.min-safe-integer":282,"./modules/es6.number.parse-float":283,"./modules/es6.number.parse-int":284,"./modules/es6.number.to-fixed":285,"./modules/es6.number.to-precision":286,"./modules/es6.object.assign":287,"./modules/es6.object.create":288,"./modules/es6.object.define-properties":289,"./modules/es6.object.define-property":290,"./modules/es6.object.freeze":291,"./modules/es6.object.get-own-property-descriptor":292,"./modules/es6.object.get-own-property-names":293,"./modules/es6.object.get-prototype-of":294,"./modules/es6.object.is":298,"./modules/es6.object.is-extensible":295,"./modules/es6.object.is-frozen":296,"./modules/es6.object.is-sealed":297,"./modules/es6.object.keys":299,"./modules/es6.object.prevent-extensions":300,"./modules/es6.object.seal":301,"./modules/es6.object.set-prototype-of":302,"./modules/es6.object.to-string":303,"./modules/es6.parse-float":304,"./modules/es6.parse-int":305,"./modules/es6.promise":306,"./modules/es6.reflect.apply":307,"./modules/es6.reflect.construct":308,"./modules/es6.reflect.define-property":309,"./modules/es6.reflect.delete-property":310,"./modules/es6.reflect.enumerate":311,"./modules/es6.reflect.get":314,"./modules/es6.reflect.get-own-property-descriptor":312,"./modules/es6.reflect.get-prototype-of":313,"./modules/es6.reflect.has":315,"./modules/es6.reflect.is-extensible":316,"./modules/es6.reflect.own-keys":317,"./modules/es6.reflect.prevent-extensions":318,"./modules/es6.reflect.set":320,"./modules/es6.reflect.set-prototype-of":319,"./modules/es6.regexp.constructor":321,"./modules/es6.regexp.exec":322,"./modules/es6.regexp.flags":323,"./modules/es6.regexp.match":324,"./modules/es6.regexp.replace":325,"./modules/es6.regexp.search":326,"./modules/es6.regexp.split":327,"./modules/es6.regexp.to-string":328,"./modules/es6.set":329,"./modules/es6.string.anchor":330,"./modules/es6.string.big":331,"./modules/es6.string.blink":332,"./modules/es6.string.bold":333,"./modules/es6.string.code-point-at":334,"./modules/es6.string.ends-with":335,"./modules/es6.string.fixed":336,"./modules/es6.string.fontcolor":337,"./modules/es6.string.fontsize":338,"./modules/es6.string.from-code-point":339,"./modules/es6.string.includes":340,"./modules/es6.string.italics":341,"./modules/es6.string.iterator":342,"./modules/es6.string.link":343,"./modules/es6.string.raw":344,"./modules/es6.string.repeat":345,"./modules/es6.string.small":346,"./modules/es6.string.starts-with":347,"./modules/es6.string.strike":348,"./modules/es6.string.sub":349,"./modules/es6.string.sup":350,"./modules/es6.string.trim":351,"./modules/es6.symbol":352,"./modules/es6.typed.array-buffer":353,"./modules/es6.typed.data-view":354,"./modules/es6.typed.float32-array":355,"./modules/es6.typed.float64-array":356,"./modules/es6.typed.int16-array":357,"./modules/es6.typed.int32-array":358,"./modules/es6.typed.int8-array":359,"./modules/es6.typed.uint16-array":360,"./modules/es6.typed.uint32-array":361,"./modules/es6.typed.uint8-array":362,"./modules/es6.typed.uint8-clamped-array":363,"./modules/es6.weak-map":364,"./modules/es6.weak-set":365,"./modules/es7.array.flat-map":366,"./modules/es7.array.flatten":367,"./modules/es7.array.includes":368,"./modules/es7.asap":369,"./modules/es7.error.is-error":370,"./modules/es7.global":371,"./modules/es7.map.from":372,"./modules/es7.map.of":373,"./modules/es7.map.to-json":374,"./modules/es7.math.clamp":375,"./modules/es7.math.deg-per-rad":376,"./modules/es7.math.degrees":377,"./modules/es7.math.fscale":378,"./modules/es7.math.iaddh":379,"./modules/es7.math.imulh":380,"./modules/es7.math.isubh":381,"./modules/es7.math.rad-per-deg":382,"./modules/es7.math.radians":383,"./modules/es7.math.scale":384,"./modules/es7.math.signbit":385,"./modules/es7.math.umulh":386,"./modules/es7.object.define-getter":387,"./modules/es7.object.define-setter":388,"./modules/es7.object.entries":389,"./modules/es7.object.get-own-property-descriptors":390,"./modules/es7.object.lookup-getter":391,"./modules/es7.object.lookup-setter":392,"./modules/es7.object.values":393,"./modules/es7.observable":394,"./modules/es7.promise.finally":395,"./modules/es7.promise.try":396,"./modules/es7.reflect.define-metadata":397,"./modules/es7.reflect.delete-metadata":398,"./modules/es7.reflect.get-metadata":400,"./modules/es7.reflect.get-metadata-keys":399,"./modules/es7.reflect.get-own-metadata":402,"./modules/es7.reflect.get-own-metadata-keys":401,"./modules/es7.reflect.has-metadata":403,"./modules/es7.reflect.has-own-metadata":404,"./modules/es7.reflect.metadata":405,"./modules/es7.set.from":406,"./modules/es7.set.of":407,"./modules/es7.set.to-json":408,"./modules/es7.string.at":409,"./modules/es7.string.match-all":410,"./modules/es7.string.pad-end":411,"./modules/es7.string.pad-start":412,"./modules/es7.string.trim-left":413,"./modules/es7.string.trim-right":414,"./modules/es7.symbol.async-iterator":415,"./modules/es7.symbol.observable":416,"./modules/es7.system.global":417,"./modules/es7.weak-map.from":418,"./modules/es7.weak-map.of":419,"./modules/es7.weak-set.from":420,"./modules/es7.weak-set.of":421,"./modules/web.dom.iterable":422,"./modules/web.immediate":423,"./modules/web.timers":424}],426:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":511}],427:[function(require,module,exports){
(function (Buffer){
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

}).call(this,require("buffer").Buffer)
},{"bn.js":66,"buffer":98,"elliptic":445}],428:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":99,"inherits":510,"md5.js":547,"ripemd160":589,"sha.js":593}],429:[function(require,module,exports){
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":547}],430:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"./legacy":431,"cipher-base":99,"create-hash/md5":429,"inherits":510,"ripemd160":589,"safe-buffer":590,"sha.js":593}],431:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"cipher-base":99,"inherits":510,"safe-buffer":590}],432:[function(require,module,exports){
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var algos = require('browserify-sign/algos')
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = require('diffie-hellman')

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = require('browserify-sign')

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill')

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}

},{"browserify-cipher":86,"browserify-sign":93,"browserify-sign/algos":90,"create-ecdh":427,"create-hash":428,"create-hmac":430,"diffie-hellman":441,"pbkdf2":559,"public-encrypt":567,"randombytes":573,"randomfill":574}],433:[function(require,module,exports){
var AbstractIterator = require('abstract-leveldown').AbstractIterator
var inherits = require('inherits')

function DeferredIterator (options) {
  AbstractIterator.call(this, options)

  this._options = options
  this._iterator = null
  this._operations = []
}

inherits(DeferredIterator, AbstractIterator)

DeferredIterator.prototype.setDb = function (db) {
  var it = this._iterator = db.iterator(this._options)
  this._operations.forEach(function (op) {
    it[op.method].apply(it, op.args)
  })
}

DeferredIterator.prototype._operation = function (method, args) {
  if (this._iterator) return this._iterator[method].apply(this._iterator, args)
  this._operations.push({ method: method, args: args })
}

'next end'.split(' ').forEach(function (m) {
  DeferredIterator.prototype['_' + m] = function () {
    this._operation(m, arguments)
  }
})

// Must defer seek() rather than _seek() because it requires db._serializeKey to be available
DeferredIterator.prototype.seek = function () {
  this._operation('seek', arguments)
}

module.exports = DeferredIterator

},{"abstract-leveldown":44,"inherits":510}],434:[function(require,module,exports){
var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var inherits = require('inherits')
var DeferredIterator = require('./deferred-iterator')
var deferrables = 'put get del batch'.split(' ')

function DeferredLevelDOWN (db) {
  AbstractLevelDOWN.call(this, '')
  this._db = db
  this._operations = []
  this._iterators = []
  closed(this)
}

inherits(DeferredLevelDOWN, AbstractLevelDOWN)

DeferredLevelDOWN.prototype._open = function (options, callback) {
  var self = this

  this._db.open(options, function (err) {
    if (err) return callback(err)

    self._operations.forEach(function (op) {
      self._db[op.method].apply(self._db, op.args)
    })
    self._operations = []
    self._iterators.forEach(function (it) {
      it.setDb(self._db)
    })
    self._iterators = []
    open(self)
    callback()
  })
}

DeferredLevelDOWN.prototype._close = function (callback) {
  var self = this

  this._db.close(function (err) {
    if (err) return callback(err)
    closed(self)
    callback()
  })
}

function open (self) {
  deferrables.concat('iterator').forEach(function (m) {
    self['_' + m] = function () {
      return this._db[m].apply(this._db, arguments)
    }
  })
  if (self._db.approximateSize) {
    self.approximateSize = function () {
      return this._db.approximateSize.apply(this._db, arguments)
    }
  }
}

function closed (self) {
  deferrables.forEach(function (m) {
    self['_' + m] = function () {
      this._operations.push({ method: m, args: arguments })
    }
  })
  if (typeof self._db.approximateSize === 'function') {
    self.approximateSize = function () {
      this._operations.push({
        method: 'approximateSize',
        args: arguments
      })
    }
  }
  self._iterator = function (options) {
    var it = new DeferredIterator(options)
    this._iterators.push(it)
    return it
  }
}

DeferredLevelDOWN.prototype._serializeKey = function (key) {
  return key
}

DeferredLevelDOWN.prototype._serializeValue = function (value) {
  return value
}

module.exports = DeferredLevelDOWN
module.exports.DeferredIterator = DeferredIterator

},{"./deferred-iterator":433,"abstract-leveldown":44,"inherits":510}],435:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":436,"./des/cipher":437,"./des/des":438,"./des/ede":439,"./des/utils":440}],436:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":510,"minimalistic-assert":550}],437:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":550}],438:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var utils = des.utils;
var Cipher = des.Cipher;

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"../des":435,"inherits":510,"minimalistic-assert":550}],439:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var des = require('../des');
var Cipher = des.Cipher;
var DES = des.DES;

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"../des":435,"inherits":510,"minimalistic-assert":550}],440:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],441:[function(require,module,exports){
(function (Buffer){
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

}).call(this,require("buffer").Buffer)
},{"./lib/dh":442,"./lib/generatePrime":443,"./lib/primes.json":444,"buffer":98}],442:[function(require,module,exports){
(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this,require("buffer").Buffer)
},{"./generatePrime":443,"bn.js":66,"buffer":98,"miller-rabin":549,"randombytes":573}],443:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":66,"miller-rabin":549,"randombytes":573}],444:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],445:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":460,"./elliptic/curve":448,"./elliptic/curves":451,"./elliptic/ec":452,"./elliptic/eddsa":455,"./elliptic/utils":459,"brorand":67}],446:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
                          bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len)) ;
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":459,"bn.js":66}],447:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":459,"./base":446,"bn.js":66,"inherits":510}],448:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":446,"./edwards":447,"./mont":449,"./short":450}],449:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":459,"./base":446,"bn.js":66,"inherits":510}],450:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);

  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":459,"./base":446,"bn.js":66,"inherits":510}],451:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ]
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ]
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ]
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
  ]
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650'
  ]
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre
  ]
});

},{"./curve":448,"./precomputed/secp256k1":458,"./utils":459,"hash.js":496}],452:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  do {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; true; iter++) {
    var k = options.k ?
        options.k(iter) :
        new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);

  if (!this.curve._maxwellTrick) {
    var p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  var p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":451,"../utils":459,"./key":453,"./signature":454,"bn.js":66,"brorand":67,"hmac-drbg":508}],453:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":459,"bn.js":66}],454:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
  }
  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0 && (r[1] & 0x80)) {
    r = r.slice(1);
  }
  if (s[0] === 0 && (s[1] & 0x80)) {
    s = s.slice(1);
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":459,"bn.js":66}],455:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  var curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":451,"../utils":459,"./key":456,"./signature":457,"hash.js":496}],456:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":459}],457:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":459,"bn.js":66}],458:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
      ]
    ]
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
      ]
    ]
  }
};

},{}],459:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.iushrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
           this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
                                     bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":66,"minimalistic-assert":550,"minimalistic-crypto-utils":551}],460:[function(require,module,exports){
module.exports={
  "_from": "elliptic@^6.0.0",
  "_id": "elliptic@6.5.0",
  "_inBundle": false,
  "_integrity": "sha512-eFOJTMyCYb7xtE/caJ6JJu+bhi67WCYNbkGSknu20pmM8Ke/bqOfdnZWxyoGN26JgfxTbXrsCkEw4KheCT/KGg==",
  "_location": "/elliptic",
  "_phantomChildren": {},
  "_requested": {
    "type": "range",
    "registry": true,
    "raw": "elliptic@^6.0.0",
    "name": "elliptic",
    "escapedName": "elliptic",
    "rawSpec": "^6.0.0",
    "saveSpec": null,
    "fetchSpec": "^6.0.0"
  },
  "_requiredBy": [
    "/browserify-sign",
    "/create-ecdh"
  ],
  "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.0.tgz",
  "_shasum": "2b8ed4c891b7de3200e14412a5b8248c7af505ca",
  "_spec": "elliptic@^6.0.0",
  "_where": "/Users/jeremiahwagstaff/Desktop/subspace-core/node_modules/browserify-sign",
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "bn.js": "^4.4.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.0",
    "inherits": "^2.0.1",
    "minimalistic-assert": "^1.0.0",
    "minimalistic-crypto-utils": "^1.0.0"
  },
  "deprecated": false,
  "description": "EC cryptography",
  "devDependencies": {
    "brfs": "^1.4.3",
    "coveralls": "^2.11.3",
    "grunt": "^0.4.5",
    "grunt-browserify": "^5.0.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-connect": "^1.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^1.0.1",
    "grunt-mocha-istanbul": "^3.0.1",
    "grunt-saucelabs": "^8.6.2",
    "istanbul": "^0.4.2",
    "jscs": "^2.9.0",
    "jshint": "^2.6.0",
    "mocha": "^2.1.0"
  },
  "files": [
    "lib"
  ],
  "homepage": "https://github.com/indutny/elliptic",
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "license": "MIT",
  "main": "lib/elliptic.js",
  "name": "elliptic",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/indutny/elliptic.git"
  },
  "scripts": {
    "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
    "lint": "npm run jscs && npm run jshint",
    "test": "npm run lint && npm run unit",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "version": "grunt dist && git add dist/"
  },
  "version": "6.5.0"
}

},{}],461:[function(require,module,exports){
var prr = require('prr')

function init (type, message, cause) {
  if (!!message && typeof message != 'string') {
    message = message.message || message.name
  }
  prr(this, {
      type    : type
    , name    : type
      // can be passed just a 'cause'
    , cause   : typeof message != 'string' ? message : cause
    , message : message
  }, 'ewr')
}

// generic prototype, not intended to be actually used - helpful for `instanceof`
function CustomError (message, cause) {
  Error.call(this)
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, this.constructor)
  init.call(this, 'CustomError', message, cause)
}

CustomError.prototype = new Error()

function createError (errno, type, proto) {
  var err = function (message, cause) {
    init.call(this, type, message, cause)
    //TODO: the specificity here is stupid, errno should be available everywhere
    if (type == 'FilesystemError') {
      this.code    = this.cause.code
      this.path    = this.cause.path
      this.errno   = this.cause.errno
      this.message =
        (errno.errno[this.cause.errno]
          ? errno.errno[this.cause.errno].description
          : this.cause.message)
        + (this.cause.path ? ' [' + this.cause.path + ']' : '')
    }
    Error.call(this)
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, err)
  }
  err.prototype = !!proto ? new proto() : new CustomError()
  return err
}

module.exports = function (errno) {
  var ce = function (type, proto) {
    return createError(errno, type, proto)
  }
  return {
      CustomError     : CustomError
    , FilesystemError : ce('FilesystemError')
    , createError     : ce
  }
}

},{"prr":566}],462:[function(require,module,exports){
var all = module.exports.all = [
  {
    errno: -2,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: -1,
    code: 'UNKNOWN',
    description: 'unknown error'
  },
  {
    errno: 0,
    code: 'OK',
    description: 'success'
  },
  {
    errno: 1,
    code: 'EOF',
    description: 'end of file'
  },
  {
    errno: 2,
    code: 'EADDRINFO',
    description: 'getaddrinfo error'
  },
  {
    errno: 3,
    code: 'EACCES',
    description: 'permission denied'
  },
  {
    errno: 4,
    code: 'EAGAIN',
    description: 'resource temporarily unavailable'
  },
  {
    errno: 5,
    code: 'EADDRINUSE',
    description: 'address already in use'
  },
  {
    errno: 6,
    code: 'EADDRNOTAVAIL',
    description: 'address not available'
  },
  {
    errno: 7,
    code: 'EAFNOSUPPORT',
    description: 'address family not supported'
  },
  {
    errno: 8,
    code: 'EALREADY',
    description: 'connection already in progress'
  },
  {
    errno: 9,
    code: 'EBADF',
    description: 'bad file descriptor'
  },
  {
    errno: 10,
    code: 'EBUSY',
    description: 'resource busy or locked'
  },
  {
    errno: 11,
    code: 'ECONNABORTED',
    description: 'software caused connection abort'
  },
  {
    errno: 12,
    code: 'ECONNREFUSED',
    description: 'connection refused'
  },
  {
    errno: 13,
    code: 'ECONNRESET',
    description: 'connection reset by peer'
  },
  {
    errno: 14,
    code: 'EDESTADDRREQ',
    description: 'destination address required'
  },
  {
    errno: 15,
    code: 'EFAULT',
    description: 'bad address in system call argument'
  },
  {
    errno: 16,
    code: 'EHOSTUNREACH',
    description: 'host is unreachable'
  },
  {
    errno: 17,
    code: 'EINTR',
    description: 'interrupted system call'
  },
  {
    errno: 18,
    code: 'EINVAL',
    description: 'invalid argument'
  },
  {
    errno: 19,
    code: 'EISCONN',
    description: 'socket is already connected'
  },
  {
    errno: 20,
    code: 'EMFILE',
    description: 'too many open files'
  },
  {
    errno: 21,
    code: 'EMSGSIZE',
    description: 'message too long'
  },
  {
    errno: 22,
    code: 'ENETDOWN',
    description: 'network is down'
  },
  {
    errno: 23,
    code: 'ENETUNREACH',
    description: 'network is unreachable'
  },
  {
    errno: 24,
    code: 'ENFILE',
    description: 'file table overflow'
  },
  {
    errno: 25,
    code: 'ENOBUFS',
    description: 'no buffer space available'
  },
  {
    errno: 26,
    code: 'ENOMEM',
    description: 'not enough memory'
  },
  {
    errno: 27,
    code: 'ENOTDIR',
    description: 'not a directory'
  },
  {
    errno: 28,
    code: 'EISDIR',
    description: 'illegal operation on a directory'
  },
  {
    errno: 29,
    code: 'ENONET',
    description: 'machine is not on the network'
  },
  {
    errno: 31,
    code: 'ENOTCONN',
    description: 'socket is not connected'
  },
  {
    errno: 32,
    code: 'ENOTSOCK',
    description: 'socket operation on non-socket'
  },
  {
    errno: 33,
    code: 'ENOTSUP',
    description: 'operation not supported on socket'
  },
  {
    errno: 34,
    code: 'ENOENT',
    description: 'no such file or directory'
  },
  {
    errno: 35,
    code: 'ENOSYS',
    description: 'function not implemented'
  },
  {
    errno: 36,
    code: 'EPIPE',
    description: 'broken pipe'
  },
  {
    errno: 37,
    code: 'EPROTO',
    description: 'protocol error'
  },
  {
    errno: 38,
    code: 'EPROTONOSUPPORT',
    description: 'protocol not supported'
  },
  {
    errno: 39,
    code: 'EPROTOTYPE',
    description: 'protocol wrong type for socket'
  },
  {
    errno: 40,
    code: 'ETIMEDOUT',
    description: 'connection timed out'
  },
  {
    errno: 41,
    code: 'ECHARSET',
    description: 'invalid Unicode character'
  },
  {
    errno: 42,
    code: 'EAIFAMNOSUPPORT',
    description: 'address family for hostname not supported'
  },
  {
    errno: 44,
    code: 'EAISERVICE',
    description: 'servname not supported for ai_socktype'
  },
  {
    errno: 45,
    code: 'EAISOCKTYPE',
    description: 'ai_socktype not supported'
  },
  {
    errno: 46,
    code: 'ESHUTDOWN',
    description: 'cannot send after transport endpoint shutdown'
  },
  {
    errno: 47,
    code: 'EEXIST',
    description: 'file already exists'
  },
  {
    errno: 48,
    code: 'ESRCH',
    description: 'no such process'
  },
  {
    errno: 49,
    code: 'ENAMETOOLONG',
    description: 'name too long'
  },
  {
    errno: 50,
    code: 'EPERM',
    description: 'operation not permitted'
  },
  {
    errno: 51,
    code: 'ELOOP',
    description: 'too many symbolic links encountered'
  },
  {
    errno: 52,
    code: 'EXDEV',
    description: 'cross-device link not permitted'
  },
  {
    errno: 53,
    code: 'ENOTEMPTY',
    description: 'directory not empty'
  },
  {
    errno: 54,
    code: 'ENOSPC',
    description: 'no space left on device'
  },
  {
    errno: 55,
    code: 'EIO',
    description: 'i/o error'
  },
  {
    errno: 56,
    code: 'EROFS',
    description: 'read-only file system'
  },
  {
    errno: 57,
    code: 'ENODEV',
    description: 'no such device'
  },
  {
    errno: 58,
    code: 'ESPIPE',
    description: 'invalid seek'
  },
  {
    errno: 59,
    code: 'ECANCELED',
    description: 'operation canceled'
  }
]

module.exports.errno = {}
module.exports.code = {}

all.forEach(function (error) {
  module.exports.errno[error.errno] = error
  module.exports.code[error.code] = error
})

module.exports.custom = require('./custom')(module.exports)
module.exports.create = module.exports.custom.createError

},{"./custom":461}],463:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],464:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"md5.js":547,"safe-buffer":590}],465:[function(require,module,exports){
(function (global){
require("core-js/shim");
var fakeIndexedDB = require("./build/fakeIndexedDB").default;
var FDBCursor = require("./build/FDBCursor").default;
var FDBCursorWithValue = require("./build/FDBCursorWithValue").default;
var FDBDatabase = require("./build/FDBDatabase").default;
var FDBFactory = require("./build/FDBFactory").default;
var FDBIndex = require("./build/FDBIndex").default;
var FDBKeyRange = require("./build/FDBKeyRange").default;
var FDBObjectStore = require("./build/FDBObjectStore").default;
var FDBOpenDBRequest = require("./build/FDBOpenDBRequest").default;
var FDBRequest = require("./build/FDBRequest").default;
var FDBTransaction = require("./build/FDBTransaction").default;
var FDBVersionChangeEvent = require("./build/FDBVersionChangeEvent").default;

// http://stackoverflow.com/a/33268326/786644 - works in browser, worker, and Node.js
var globalVar =
    typeof window !== "undefined"
        ? window
        : typeof WorkerGlobalScope !== "undefined"
            ? self
            : typeof global !== "undefined"
                ? global
                : Function("return this;")();

globalVar.indexedDB = fakeIndexedDB;
globalVar.IDBCursor = FDBCursor;
globalVar.IDBCursorWithValue = FDBCursorWithValue;
globalVar.IDBDatabase = FDBDatabase;
globalVar.IDBFactory = FDBFactory;
globalVar.IDBIndex = FDBIndex;
globalVar.IDBKeyRange = FDBKeyRange;
globalVar.IDBObjectStore = FDBObjectStore;
globalVar.IDBOpenDBRequest = FDBOpenDBRequest;
globalVar.IDBRequest = FDBRequest;
globalVar.IDBTransaction = FDBTransaction;
globalVar.IDBVersionChangeEvent = FDBVersionChangeEvent;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./build/FDBCursor":466,"./build/FDBCursorWithValue":467,"./build/FDBDatabase":468,"./build/FDBFactory":469,"./build/FDBIndex":470,"./build/FDBKeyRange":471,"./build/FDBObjectStore":472,"./build/FDBOpenDBRequest":473,"./build/FDBRequest":474,"./build/FDBTransaction":475,"./build/FDBVersionChangeEvent":476,"./build/fakeIndexedDB":477,"core-js/shim":425}],466:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var FDBKeyRange_1 = require("./FDBKeyRange");
var FDBObjectStore_1 = require("./FDBObjectStore");
var cmp_1 = require("./lib/cmp");
var errors_1 = require("./lib/errors");
var extractKey_1 = require("./lib/extractKey");
var structuredClone_1 = require("./lib/structuredClone");
var valueToKey_1 = require("./lib/valueToKey");
var getEffectiveObjectStore = function (cursor) {
    if (cursor.source instanceof FDBObjectStore_1.default) {
        return cursor.source;
    }
    return cursor.source.objectStore;
};
// This takes a key range, a list of lower bounds, and a list of upper bounds and combines them all into a single key
// range. It does not handle gt/gte distinctions, because it doesn't really matter much anyway, since for next/prev
// cursor iteration it'd also have to look at values to be precise, which would be complicated. This should get us 99%
// of the way there.
var makeKeyRange = function (range, lowers, uppers) {
    var e_1, _a, e_2, _b;
    // Start with bounds from range
    var lower = range !== undefined ? range.lower : undefined;
    var upper = range !== undefined ? range.upper : undefined;
    try {
        // Augment with values from lowers and uppers
        for (var lowers_1 = __values(lowers), lowers_1_1 = lowers_1.next(); !lowers_1_1.done; lowers_1_1 = lowers_1.next()) {
            var lowerTemp = lowers_1_1.value;
            if (lowerTemp === undefined) {
                continue;
            }
            if (lower === undefined || cmp_1.default(lower, lowerTemp) === 1) {
                lower = lowerTemp;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (lowers_1_1 && !lowers_1_1.done && (_a = lowers_1.return)) _a.call(lowers_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var uppers_1 = __values(uppers), uppers_1_1 = uppers_1.next(); !uppers_1_1.done; uppers_1_1 = uppers_1.next()) {
            var upperTemp = uppers_1_1.value;
            if (upperTemp === undefined) {
                continue;
            }
            if (upper === undefined || cmp_1.default(upper, upperTemp) === -1) {
                upper = upperTemp;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (uppers_1_1 && !uppers_1_1.done && (_b = uppers_1.return)) _b.call(uppers_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    if (lower !== undefined && upper !== undefined) {
        return FDBKeyRange_1.default.bound(lower, upper);
    }
    if (lower !== undefined) {
        return FDBKeyRange_1.default.lowerBound(lower);
    }
    if (upper !== undefined) {
        return FDBKeyRange_1.default.upperBound(upper);
    }
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#cursor
var FDBCursor = /** @class */ (function () {
    function FDBCursor(source, range, direction, request, keyOnly) {
        if (direction === void 0) { direction = "next"; }
        if (keyOnly === void 0) { keyOnly = false; }
        this._gotValue = false;
        this._position = undefined; // Key of previously returned record
        this._objectStorePosition = undefined;
        this._keyOnly = false;
        this._key = undefined;
        this._primaryKey = undefined;
        this._range = range;
        this._source = source;
        this._direction = direction;
        this._request = request;
        this._keyOnly = keyOnly;
    }
    Object.defineProperty(FDBCursor.prototype, "source", {
        // Read only properties
        get: function () {
            return this._source;
        },
        set: function (val) {
            /* For babel */
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FDBCursor.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        set: function (val) {
            /* For babel */
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FDBCursor.prototype, "key", {
        get: function () {
            return this._key;
        },
        set: function (val) {
            /* For babel */
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FDBCursor.prototype, "primaryKey", {
        get: function () {
            return this._primaryKey;
        },
        set: function (val) {
            /* For babel */
        },
        enumerable: true,
        configurable: true
    });
    // https://w3c.github.io/IndexedDB/#iterate-a-cursor
    FDBCursor.prototype._iterate = function (key, primaryKey) {
        var e_3, _a, e_4, _b, e_5, _c, e_6, _d;
        var sourceIsObjectStore = this.source instanceof FDBObjectStore_1.default;
        // Can't use sourceIsObjectStore because TypeScript
        var records = this.source instanceof FDBObjectStore_1.default
            ? this.source._rawObjectStore.records
            : this.source._rawIndex.records;
        var foundRecord;
        if (this.direction === "next") {
            var range = makeKeyRange(this._range, [key, this._position], []);
            try {
                for (var _e = __values(records.values(range)), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var record = _f.value;
                    var cmpResultKey = key !== undefined ? cmp_1.default(record.key, key) : undefined;
                    var cmpResultPosition = this._position !== undefined
                        ? cmp_1.default(record.key, this._position)
                        : undefined;
                    if (key !== undefined) {
                        if (cmpResultKey === -1) {
                            continue;
                        }
                    }
                    if (primaryKey !== undefined) {
                        if (cmpResultKey === -1) {
                            continue;
                        }
                        var cmpResultPrimaryKey = cmp_1.default(record.value, primaryKey);
                        if (cmpResultKey === 0 && cmpResultPrimaryKey === -1) {
                            continue;
                        }
                    }
                    if (this._position !== undefined && sourceIsObjectStore) {
                        if (cmpResultPosition !== 1) {
                            continue;
                        }
                    }
                    if (this._position !== undefined && !sourceIsObjectStore) {
                        if (cmpResultPosition === -1) {
                            continue;
                        }
                        if (cmpResultPosition === 0 &&
                            cmp_1.default(record.value, this._objectStorePosition) !== 1) {
                            continue;
                        }
                    }
                    if (this._range !== undefined) {
                        if (!this._range.includes(record.key)) {
                            continue;
                        }
                    }
                    foundRecord = record;
                    break;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        else if (this.direction === "nextunique") {
            // This could be done without iterating, if the range was defined slightly better (to handle gt/gte cases).
            // But the performance difference should be small, and that wouldn't work anyway for directions where the
            // value needs to be used (like next and prev).
            var range = makeKeyRange(this._range, [key, this._position], []);
            try {
                for (var _g = __values(records.values(range)), _h = _g.next(); !_h.done; _h = _g.next()) {
                    var record = _h.value;
                    if (key !== undefined) {
                        if (cmp_1.default(record.key, key) === -1) {
                            continue;
                        }
                    }
                    if (this._position !== undefined) {
                        if (cmp_1.default(record.key, this._position) !== 1) {
                            continue;
                        }
                    }
                    if (this._range !== undefined) {
                        if (!this._range.includes(record.key)) {
                            continue;
                        }
                    }
                    foundRecord = record;
                    break;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        else if (this.direction === "prev") {
            var range = makeKeyRange(this._range, [], [key, this._position]);
            try {
                for (var _j = __values(records.values(range, "prev")), _k = _j.next(); !_k.done; _k = _j.next()) {
                    var record = _k.value;
                    var cmpResultKey = key !== undefined ? cmp_1.default(record.key, key) : undefined;
                    var cmpResultPosition = this._position !== undefined
                        ? cmp_1.default(record.key, this._position)
                        : undefined;
                    if (key !== undefined) {
                        if (cmpResultKey === 1) {
                            continue;
                        }
                    }
                    if (primaryKey !== undefined) {
                        if (cmpResultKey === 1) {
                            continue;
                        }
                        var cmpResultPrimaryKey = cmp_1.default(record.value, primaryKey);
                        if (cmpResultKey === 0 && cmpResultPrimaryKey === 1) {
                            continue;
                        }
                    }
                    if (this._position !== undefined && sourceIsObjectStore) {
                        if (cmpResultPosition !== -1) {
                            continue;
                        }
                    }
                    if (this._position !== undefined && !sourceIsObjectStore) {
                        if (cmpResultPosition === 1) {
                            continue;
                        }
                        if (cmpResultPosition === 0 &&
                            cmp_1.default(record.value, this._objectStorePosition) !== -1) {
                            continue;
                        }
                    }
                    if (this._range !== undefined) {
                        if (!this._range.includes(record.key)) {
                            continue;
                        }
                    }
                    foundRecord = record;
                    break;
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
        else if (this.direction === "prevunique") {
            var tempRecord = void 0;
            var range = makeKeyRange(this._range, [], [key, this._position]);
            try {
                for (var _l = __values(records.values(range, "prev")), _m = _l.next(); !_m.done; _m = _l.next()) {
                    var record = _m.value;
                    if (key !== undefined) {
                        if (cmp_1.default(record.key, key) === 1) {
                            continue;
                        }
                    }
                    if (this._position !== undefined) {
                        if (cmp_1.default(record.key, this._position) !== -1) {
                            continue;
                        }
                    }
                    if (this._range !== undefined) {
                        if (!this._range.includes(record.key)) {
                            continue;
                        }
                    }
                    tempRecord = record;
                    break;
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                }
                finally { if (e_6) throw e_6.error; }
            }
            if (tempRecord) {
                foundRecord = records.get(tempRecord.key);
            }
        }
        var result;
        if (!foundRecord) {
            this._key = undefined;
            if (!sourceIsObjectStore) {
                this._objectStorePosition = undefined;
            }
            // "this instanceof FDBCursorWithValue" would be better and not require (this as any), but causes runtime
            // error due to circular dependency.
            if (!this._keyOnly &&
                this.constructor.name === "FDBCursorWithValue") {
                this.value = undefined;
            }
            result = null;
        }
        else {
            this._position = foundRecord.key;
            if (!sourceIsObjectStore) {
                this._objectStorePosition = foundRecord.value;
            }
            this._key = foundRecord.key;
            if (sourceIsObjectStore) {
                this._primaryKey = structuredClone_1.default(foundRecord.key);
                if (!this._keyOnly &&
                    this.constructor.name === "FDBCursorWithValue") {
                    this.value = structuredClone_1.default(foundRecord.value);
                }
            }
            else {
                this._primaryKey = structuredClone_1.default(foundRecord.value);
                if (!this._keyOnly &&
                    this.constructor.name === "FDBCursorWithValue") {
                    if (this.source instanceof FDBObjectStore_1.default) {
                        // Can't use sourceIsObjectStore because TypeScript
                        throw new Error("This should never happen");
                    }
                    var value = this.source.objectStore._rawObjectStore.getValue(foundRecord.value);
                    this.value = structuredClone_1.default(value);
                }
            }
            this._gotValue = true;
            result = this;
        }
        return result;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-update-IDBRequest-any-value
    FDBCursor.prototype.update = function (value) {
        if (value === undefined) {
            throw new TypeError();
        }
        var effectiveObjectStore = getEffectiveObjectStore(this);
        var effectiveKey = this.source.hasOwnProperty("_rawIndex")
            ? this.primaryKey
            : this._position;
        var transaction = effectiveObjectStore.transaction;
        if (transaction._state !== "active") {
            throw new errors_1.TransactionInactiveError();
        }
        if (transaction.mode === "readonly") {
            throw new errors_1.ReadOnlyError();
        }
        if (effectiveObjectStore._rawObjectStore.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!(this.source instanceof FDBObjectStore_1.default) &&
            this.source._rawIndex.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!this._gotValue || !this.hasOwnProperty("value")) {
            throw new errors_1.InvalidStateError();
        }
        var clone = structuredClone_1.default(value);
        if (effectiveObjectStore.keyPath !== null) {
            var tempKey = void 0;
            try {
                tempKey = extractKey_1.default(effectiveObjectStore.keyPath, clone);
            }
            catch (err) {
                /* Handled immediately below */
            }
            if (cmp_1.default(tempKey, effectiveKey) !== 0) {
                throw new errors_1.DataError();
            }
        }
        var record = {
            key: effectiveKey,
            value: clone,
        };
        return transaction._execRequestAsync({
            operation: effectiveObjectStore._rawObjectStore.storeRecord.bind(effectiveObjectStore._rawObjectStore, record, false, transaction._rollbackLog),
            source: this,
        });
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-advance-void-unsigned-long-count
    FDBCursor.prototype.advance = function (count) {
        var _this = this;
        if (!Number.isInteger(count) || count <= 0) {
            throw new TypeError();
        }
        var effectiveObjectStore = getEffectiveObjectStore(this);
        var transaction = effectiveObjectStore.transaction;
        if (transaction._state !== "active") {
            throw new errors_1.TransactionInactiveError();
        }
        if (effectiveObjectStore._rawObjectStore.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!(this.source instanceof FDBObjectStore_1.default) &&
            this.source._rawIndex.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!this._gotValue) {
            throw new errors_1.InvalidStateError();
        }
        if (this._request) {
            this._request.readyState = "pending";
        }
        transaction._execRequestAsync({
            operation: function () {
                var result;
                for (var i = 0; i < count; i++) {
                    result = _this._iterate();
                    // Not sure why this is needed
                    if (!result) {
                        break;
                    }
                }
                return result;
            },
            request: this._request,
            source: this.source,
        });
        this._gotValue = false;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBCursor-continue-void-any-key
    FDBCursor.prototype.continue = function (key) {
        var effectiveObjectStore = getEffectiveObjectStore(this);
        var transaction = effectiveObjectStore.transaction;
        if (transaction._state !== "active") {
            throw new errors_1.TransactionInactiveError();
        }
        if (effectiveObjectStore._rawObjectStore.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!(this.source instanceof FDBObjectStore_1.default) &&
            this.source._rawIndex.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!this._gotValue) {
            throw new errors_1.InvalidStateError();
        }
        if (key !== undefined) {
            key = valueToKey_1.default(key);
            var cmpResult = cmp_1.default(key, this._position);
            if ((cmpResult <= 0 &&
                (this.direction === "next" ||
                    this.direction === "nextunique")) ||
                (cmpResult >= 0 &&
                    (this.direction === "prev" ||
                        this.direction === "prevunique"))) {
                throw new errors_1.DataError();
            }
        }
        if (this._request) {
            this._request.readyState = "pending";
        }
        transaction._execRequestAsync({
            operation: this._iterate.bind(this, key),
            request: this._request,
            source: this.source,
        });
        this._gotValue = false;
    };
    // hthttps://w3c.github.io/IndexedDB/#dom-idbcursor-continueprimarykey
    FDBCursor.prototype.continuePrimaryKey = function (key, primaryKey) {
        var effectiveObjectStore = getEffectiveObjectStore(this);
        var transaction = effectiveObjectStore.transaction;
        if (transaction._state !== "active") {
            throw new errors_1.TransactionInactiveError();
        }
        if (effectiveObjectStore._rawObjectStore.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!(this.source instanceof FDBObjectStore_1.default) &&
            this.source._rawIndex.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (this.source instanceof FDBObjectStore_1.default ||
            (this.direction !== "next" && this.direction !== "prev")) {
            throw new errors_1.InvalidAccessError();
        }
        if (!this._gotValue) {
            throw new errors_1.InvalidStateError();
        }
        // Not sure about this
        if (key === undefined || primaryKey === undefined) {
            throw new errors_1.DataError();
        }
        key = valueToKey_1.default(key);
        var cmpResult = cmp_1.default(key, this._position);
        if ((cmpResult === -1 && this.direction === "next") ||
            (cmpResult === 1 && this.direction === "prev")) {
            throw new errors_1.DataError();
        }
        var cmpResult2 = cmp_1.default(primaryKey, this._objectStorePosition);
        if (cmpResult === 0) {
            if ((cmpResult2 <= 0 && this.direction === "next") ||
                (cmpResult2 >= 0 && this.direction === "prev")) {
                throw new errors_1.DataError();
            }
        }
        if (this._request) {
            this._request.readyState = "pending";
        }
        transaction._execRequestAsync({
            operation: this._iterate.bind(this, key, primaryKey),
            request: this._request,
            source: this.source,
        });
        this._gotValue = false;
    };
    FDBCursor.prototype.delete = function () {
        var effectiveObjectStore = getEffectiveObjectStore(this);
        var effectiveKey = this.source.hasOwnProperty("_rawIndex")
            ? this.primaryKey
            : this._position;
        var transaction = effectiveObjectStore.transaction;
        if (transaction._state !== "active") {
            throw new errors_1.TransactionInactiveError();
        }
        if (transaction.mode === "readonly") {
            throw new errors_1.ReadOnlyError();
        }
        if (effectiveObjectStore._rawObjectStore.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!(this.source instanceof FDBObjectStore_1.default) &&
            this.source._rawIndex.deleted) {
            throw new errors_1.InvalidStateError();
        }
        if (!this._gotValue || !this.hasOwnProperty("value")) {
            throw new errors_1.InvalidStateError();
        }
        return transaction._execRequestAsync({
            operation: effectiveObjectStore._rawObjectStore.deleteRecord.bind(effectiveObjectStore._rawObjectStore, effectiveKey, transaction._rollbackLog),
            source: this,
        });
    };
    FDBCursor.prototype.toString = function () {
        return "[object IDBCursor]";
    };
    return FDBCursor;
}());
exports.default = FDBCursor;

},{"./FDBKeyRange":471,"./FDBObjectStore":472,"./lib/cmp":486,"./lib/errors":488,"./lib/extractKey":489,"./lib/structuredClone":491,"./lib/valueToKey":493}],467:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var FDBCursor_1 = require("./FDBCursor");
var FDBCursorWithValue = /** @class */ (function (_super) {
    __extends(FDBCursorWithValue, _super);
    function FDBCursorWithValue(source, range, direction, request) {
        var _this = _super.call(this, source, range, direction, request) || this;
        _this.value = undefined;
        return _this;
    }
    FDBCursorWithValue.prototype.toString = function () {
        return "[object IDBCursorWithValue]";
    };
    return FDBCursorWithValue;
}(FDBCursor_1.default));
exports.default = FDBCursorWithValue;

},{"./FDBCursor":466}],468:[function(require,module,exports){
(function (setImmediate){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var FDBTransaction_1 = require("./FDBTransaction");
var errors_1 = require("./lib/errors");
var fakeDOMStringList_1 = require("./lib/fakeDOMStringList");
var FakeEventTarget_1 = require("./lib/FakeEventTarget");
var ObjectStore_1 = require("./lib/ObjectStore");
var validateKeyPath_1 = require("./lib/validateKeyPath");
var confirmActiveVersionchangeTransaction = function (database) {
    if (!database._runningVersionchangeTransaction) {
        throw new errors_1.InvalidStateError();
    }
    // Find the latest versionchange transaction
    var transactions = database._rawDatabase.transactions.filter(function (tx) {
        return tx.mode === "versionchange";
    });
    var transaction = transactions[transactions.length - 1];
    if (!transaction || transaction._state === "finished") {
        throw new errors_1.InvalidStateError();
    }
    if (transaction._state !== "active") {
        throw new errors_1.TransactionInactiveError();
    }
    return transaction;
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#database-closing-steps
var closeConnection = function (connection) {
    connection._closePending = true;
    var transactionsComplete = connection._rawDatabase.transactions.every(function (transaction) {
        return transaction._state === "finished";
    });
    if (transactionsComplete) {
        connection._closed = true;
        connection._rawDatabase.connections = connection._rawDatabase.connections.filter(function (otherConnection) {
            return connection !== otherConnection;
        });
    }
    else {
        setImmediate(function () {
            closeConnection(connection);
        });
    }
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#database-interface
var FDBDatabase = /** @class */ (function (_super) {
    __extends(FDBDatabase, _super);
    function FDBDatabase(rawDatabase) {
        var _this = _super.call(this) || this;
        _this._closePending = false;
        _this._closed = false;
        _this._runningVersionchangeTransaction = false;
        _this._rawDatabase = rawDatabase;
        _this._rawDatabase.connections.push(_this);
        _this.name = rawDatabase.name;
        _this.version = rawDatabase.version;
        _this.objectStoreNames = fakeDOMStringList_1.default(Array.from(rawDatabase.rawObjectStores.keys())).sort();
        return _this;
    }
    // http://w3c.github.io/IndexedDB/#dom-idbdatabase-createobjectstore
    FDBDatabase.prototype.createObjectStore = function (name, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (name === undefined) {
            throw new TypeError();
        }
        var transaction = confirmActiveVersionchangeTransaction(this);
        var keyPath = options !== null && options.keyPath !== undefined
            ? options.keyPath
            : null;
        var autoIncrement = options !== null && options.autoIncrement !== undefined
            ? options.autoIncrement
            : false;
        if (keyPath !== null) {
            validateKeyPath_1.default(keyPath);
        }
        if (this._rawDatabase.rawObjectStores.has(name)) {
            throw new errors_1.ConstraintError();
        }
        if (autoIncrement && (keyPath === "" || Array.isArray(keyPath))) {
            throw new errors_1.InvalidAccessError();
        }
        var objectStoreNames = this.objectStoreNames.slice();
        transaction._rollbackLog.push(function () {
            var objectStore = _this._rawDatabase.rawObjectStores.get(name);
            if (objectStore) {
                objectStore.deleted = true;
            }
            _this.objectStoreNames = fakeDOMStringList_1.default(objectStoreNames);
            transaction._scope.delete(name);
            _this._rawDatabase.rawObjectStores.delete(name);
        });
        var rawObjectStore = new ObjectStore_1.default(this._rawDatabase, name, keyPath, autoIncrement);
        this.objectStoreNames.push(name);
        this.objectStoreNames.sort();
        transaction._scope.add(name);
        this._rawDatabase.rawObjectStores.set(name, rawObjectStore);
        transaction.objectStoreNames = fakeDOMStringList_1.default(this.objectStoreNames.slice());
        return transaction.objectStore(name);
    };
    FDBDatabase.prototype.deleteObjectStore = function (name) {
        var _this = this;
        if (name === undefined) {
            throw new TypeError();
        }
        var transaction = confirmActiveVersionchangeTransaction(this);
        var store = this._rawDatabase.rawObjectStores.get(name);
        if (store === undefined) {
            throw new errors_1.NotFoundError();
        }
        this.objectStoreNames = fakeDOMStringList_1.default(this.objectStoreNames.filter(function (objectStoreName) {
            return objectStoreName !== name;
        }));
        transaction.objectStoreNames = fakeDOMStringList_1.default(this.objectStoreNames.slice());
        transaction._rollbackLog.push(function () {
            store.deleted = false;
            _this._rawDatabase.rawObjectStores.set(name, store);
            _this.objectStoreNames.push(name);
            _this.objectStoreNames.sort();
        });
        store.deleted = true;
        this._rawDatabase.rawObjectStores.delete(name);
        transaction._objectStoresCache.delete(name);
    };
    FDBDatabase.prototype.transaction = function (storeNames, mode) {
        var _this = this;
        var e_1, _a;
        mode = mode !== undefined ? mode : "readonly";
        if (mode !== "readonly" &&
            mode !== "readwrite" &&
            mode !== "versionchange") {
            throw new TypeError("Invalid mode: " + mode);
        }
        var hasActiveVersionchange = this._rawDatabase.transactions.some(function (transaction) {
            return (transaction._state === "active" &&
                transaction.mode === "versionchange" &&
                transaction.db === _this);
        });
        if (hasActiveVersionchange) {
            throw new errors_1.InvalidStateError();
        }
        if (this._closePending) {
            throw new errors_1.InvalidStateError();
        }
        if (!Array.isArray(storeNames)) {
            storeNames = [storeNames];
        }
        if (storeNames.length === 0 && mode !== "versionchange") {
            throw new errors_1.InvalidAccessError();
        }
        try {
            for (var storeNames_1 = __values(storeNames), storeNames_1_1 = storeNames_1.next(); !storeNames_1_1.done; storeNames_1_1 = storeNames_1.next()) {
                var storeName = storeNames_1_1.value;
                if (this.objectStoreNames.indexOf(storeName) < 0) {
                    throw new errors_1.NotFoundError("No objectStore named " + storeName + " in this database");
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (storeNames_1_1 && !storeNames_1_1.done && (_a = storeNames_1.return)) _a.call(storeNames_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var tx = new FDBTransaction_1.default(storeNames, mode, this);
        this._rawDatabase.transactions.push(tx);
        this._rawDatabase.processTransactions(); // See if can start right away (async)
        return tx;
    };
    FDBDatabase.prototype.close = function () {
        closeConnection(this);
    };
    FDBDatabase.prototype.toString = function () {
        return "[object IDBDatabase]";
    };
    return FDBDatabase;
}(FakeEventTarget_1.default));
exports.default = FDBDatabase;

}).call(this,require("timers").setImmediate)
},{"./FDBTransaction":475,"./lib/FakeEventTarget":480,"./lib/ObjectStore":483,"./lib/errors":488,"./lib/fakeDOMStringList":490,"./lib/validateKeyPath":492,"timers":602}],469:[function(require,module,exports){
(function (setImmediate){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
require("setimmediate");
var FDBDatabase_1 = require("./FDBDatabase");
var FDBOpenDBRequest_1 = require("./FDBOpenDBRequest");
var FDBVersionChangeEvent_1 = require("./FDBVersionChangeEvent");
var cmp_1 = require("./lib/cmp");
var Database_1 = require("./lib/Database");
var enforceRange_1 = require("./lib/enforceRange");
var errors_1 = require("./lib/errors");
var FakeEvent_1 = require("./lib/FakeEvent");
var waitForOthersClosedDelete = function (databases, name, openDatabases, cb) {
    var anyOpen = openDatabases.some(function (openDatabase2) {
        return !openDatabase2._closed && !openDatabase2._closePending;
    });
    if (anyOpen) {
        setImmediate(function () {
            return waitForOthersClosedDelete(databases, name, openDatabases, cb);
        });
        return;
    }
    databases.delete(name);
    cb(null);
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-deleting-a-database
var deleteDatabase = function (databases, name, request, cb) {
    var e_1, _a;
    try {
        var db = databases.get(name);
        if (db === undefined) {
            cb(null);
            return;
        }
        db.deletePending = true;
        var openDatabases = db.connections.filter(function (connection) {
            return !connection._closed && !connection._closePending;
        });
        try {
            for (var openDatabases_1 = __values(openDatabases), openDatabases_1_1 = openDatabases_1.next(); !openDatabases_1_1.done; openDatabases_1_1 = openDatabases_1.next()) {
                var openDatabase2 = openDatabases_1_1.value;
                if (!openDatabase2._closePending) {
                    var event_1 = new FDBVersionChangeEvent_1.default("versionchange", {
                        newVersion: null,
                        oldVersion: db.version,
                    });
                    openDatabase2.dispatchEvent(event_1);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (openDatabases_1_1 && !openDatabases_1_1.done && (_a = openDatabases_1.return)) _a.call(openDatabases_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var anyOpen = openDatabases.some(function (openDatabase3) {
            return !openDatabase3._closed && !openDatabase3._closePending;
        });
        if (request && anyOpen) {
            var event_2 = new FDBVersionChangeEvent_1.default("blocked", {
                newVersion: null,
                oldVersion: db.version,
            });
            request.dispatchEvent(event_2);
        }
        waitForOthersClosedDelete(databases, name, openDatabases, cb);
    }
    catch (err) {
        cb(err);
    }
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-running-a-versionchange-transaction
var runVersionchangeTransaction = function (connection, version, request, cb) {
    var e_2, _a;
    connection._runningVersionchangeTransaction = true;
    var oldVersion = connection.version;
    var openDatabases = connection._rawDatabase.connections.filter(function (otherDatabase) {
        return connection !== otherDatabase;
    });
    try {
        for (var openDatabases_2 = __values(openDatabases), openDatabases_2_1 = openDatabases_2.next(); !openDatabases_2_1.done; openDatabases_2_1 = openDatabases_2.next()) {
            var openDatabase2 = openDatabases_2_1.value;
            if (!openDatabase2._closed && !openDatabase2._closePending) {
                var event_3 = new FDBVersionChangeEvent_1.default("versionchange", {
                    newVersion: version,
                    oldVersion: oldVersion,
                });
                openDatabase2.dispatchEvent(event_3);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (openDatabases_2_1 && !openDatabases_2_1.done && (_a = openDatabases_2.return)) _a.call(openDatabases_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var anyOpen = openDatabases.some(function (openDatabase3) {
        return !openDatabase3._closed && !openDatabase3._closePending;
    });
    if (anyOpen) {
        var event_4 = new FDBVersionChangeEvent_1.default("blocked", {
            newVersion: version,
            oldVersion: oldVersion,
        });
        request.dispatchEvent(event_4);
    }
    var waitForOthersClosed = function () {
        var anyOpen2 = openDatabases.some(function (openDatabase2) {
            return !openDatabase2._closed && !openDatabase2._closePending;
        });
        if (anyOpen2) {
            setImmediate(waitForOthersClosed);
            return;
        }
        // Set the version of database to version. This change is considered part of the transaction, and so if the
        // transaction is aborted, this change is reverted.
        connection._rawDatabase.version = version;
        connection.version = version;
        // Get rid of this setImmediate?
        var transaction = connection.transaction(connection.objectStoreNames, "versionchange");
        request.result = connection;
        request.readyState = "done";
        request.transaction = transaction;
        transaction._rollbackLog.push(function () {
            connection._rawDatabase.version = oldVersion;
            connection.version = oldVersion;
        });
        var event = new FDBVersionChangeEvent_1.default("upgradeneeded", {
            newVersion: version,
            oldVersion: oldVersion,
        });
        request.dispatchEvent(event);
        transaction.addEventListener("error", function () {
            connection._runningVersionchangeTransaction = false;
            // throw arguments[0].target.error;
            // console.log("error in versionchange transaction - not sure if anything needs to be done here", e.target.error.name);
        });
        transaction.addEventListener("abort", function () {
            connection._runningVersionchangeTransaction = false;
            request.transaction = null;
            setImmediate(function () {
                cb(new errors_1.AbortError());
            });
        });
        transaction.addEventListener("complete", function () {
            connection._runningVersionchangeTransaction = false;
            request.transaction = null;
            // Let other complete event handlers run before continuing
            setImmediate(function () {
                if (connection._closePending) {
                    cb(new errors_1.AbortError());
                }
                else {
                    cb(null);
                }
            });
        });
    };
    waitForOthersClosed();
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-opening-a-database
var openDatabase = function (databases, name, version, request, cb) {
    var db = databases.get(name);
    if (db === undefined) {
        db = new Database_1.default(name, 0);
        databases.set(name, db);
    }
    if (version === undefined) {
        version = db.version !== 0 ? db.version : 1;
    }
    if (db.version > version) {
        return cb(new errors_1.VersionError());
    }
    var connection = new FDBDatabase_1.default(db);
    if (db.version < version) {
        runVersionchangeTransaction(connection, version, request, function (err) {
            if (err) {
                // DO THIS HERE: ensure that connection is closed by running the steps for closing a database connection before these
                // steps are aborted.
                return cb(err);
            }
            cb(null, connection);
        });
    }
    else {
        cb(null, connection);
    }
};
var FDBFactory = /** @class */ (function () {
    function FDBFactory() {
        this.cmp = cmp_1.default;
        this._databases = new Map();
    }
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-deleteDatabase-IDBOpenDBRequest-DOMString-name
    FDBFactory.prototype.deleteDatabase = function (name) {
        var _this = this;
        var request = new FDBOpenDBRequest_1.default();
        request.source = null;
        setImmediate(function () {
            var db = _this._databases.get(name);
            var oldVersion = db !== undefined ? db.version : 0;
            deleteDatabase(_this._databases, name, request, function (err) {
                if (err) {
                    request.error = new Error();
                    request.error.name = err.name;
                    request.readyState = "done";
                    var event_5 = new FakeEvent_1.default("error", {
                        bubbles: true,
                        cancelable: true,
                    });
                    event_5.eventPath = [];
                    request.dispatchEvent(event_5);
                    return;
                }
                request.result = undefined;
                request.readyState = "done";
                var event2 = new FDBVersionChangeEvent_1.default("success", {
                    newVersion: null,
                    oldVersion: oldVersion,
                });
                request.dispatchEvent(event2);
            });
        });
        return request;
    };
    // tslint:disable-next-line max-line-length
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBFactory-open-IDBOpenDBRequest-DOMString-name-unsigned-long-long-version
    FDBFactory.prototype.open = function (name, version) {
        var _this = this;
        if (arguments.length > 1 && version !== undefined) {
            // Based on spec, not sure why "MAX_SAFE_INTEGER" instead of "unsigned long long", but it's needed to pass
            // tests
            version = enforceRange_1.default(version, "MAX_SAFE_INTEGER");
        }
        if (version === 0) {
            throw new TypeError();
        }
        var request = new FDBOpenDBRequest_1.default();
        request.source = null;
        setImmediate(function () {
            openDatabase(_this._databases, name, version, request, function (err, connection) {
                if (err) {
                    request.result = undefined;
                    request.readyState = "done";
                    request.error = new Error();
                    request.error.name = err.name;
                    var event_6 = new FakeEvent_1.default("error", {
                        bubbles: true,
                        cancelable: true,
                    });
                    event_6.eventPath = [];
                    request.dispatchEvent(event_6);
                    return;
                }
                request.result = connection;
                request.readyState = "done";
                var event2 = new FakeEvent_1.default("success");
                event2.eventPath = [];
                request.dispatchEvent(event2);
            });
        });
        return request;
    };
    // https://w3c.github.io/IndexedDB/#dom-idbfactory-databases
    FDBFactory.prototype.databases = function () {
        var _this = this;
        return new Promise(function (resolve) {
            var e_3, _a;
            var result = [];
            try {
                for (var _b = __values(_this._databases), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), name_1 = _d[0], database = _d[1];
                    result.push({
                        name: name_1,
                        version: database.version,
                    });
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            resolve(result);
        });
    };
    FDBFactory.prototype.toString = function () {
        return "[object IDBFactory]";
    };
    return FDBFactory;
}());
exports.default = FDBFactory;

}).call(this,require("timers").setImmediate)
},{"./FDBDatabase":468,"./FDBOpenDBRequest":473,"./FDBVersionChangeEvent":476,"./lib/Database":478,"./lib/FakeEvent":479,"./lib/cmp":486,"./lib/enforceRange":487,"./lib/errors":488,"setimmediate":591,"timers":602}],470:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FDBCursor_1 = require("./FDBCursor");
var FDBCursorWithValue_1 = require("./FDBCursorWithValue");
var FDBKeyRange_1 = require("./FDBKeyRange");
var FDBRequest_1 = require("./FDBRequest");
var enforceRange_1 = require("./lib/enforceRange");
var errors_1 = require("./lib/errors");
var fakeDOMStringList_1 = require("./lib/fakeDOMStringList");
var valueToKey_1 = require("./lib/valueToKey");
var valueToKeyRange_1 = require("./lib/valueToKeyRange");
var confirmActiveTransaction = function (index) {
    if (index._rawIndex.deleted || index.objectStore._rawObjectStore.deleted) {
        throw new errors_1.InvalidStateError();
    }
    if (index.objectStore.transaction._state !== "active") {
        throw new errors_1.TransactionInactiveError();
    }
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#idl-def-IDBIndex
var FDBIndex = /** @class */ (function () {
    function FDBIndex(objectStore, rawIndex) {
        this._rawIndex = rawIndex;
        this._name = rawIndex.name;
        this.objectStore = objectStore;
        this.keyPath = rawIndex.keyPath;
        this.multiEntry = rawIndex.multiEntry;
        this.unique = rawIndex.unique;
    }
    Object.defineProperty(FDBIndex.prototype, "name", {
        get: function () {
            return this._name;
        },
        // https://w3c.github.io/IndexedDB/#dom-idbindex-name
        set: function (name) {
            var _this = this;
            var transaction = this.objectStore.transaction;
            if (!transaction.db._runningVersionchangeTransaction) {
                throw new errors_1.InvalidStateError();
            }
            if (transaction._state !== "active") {
                throw new errors_1.TransactionInactiveError();
            }
            if (this._rawIndex.deleted ||
                this.objectStore._rawObjectStore.deleted) {
                throw new errors_1.InvalidStateError();
            }
            name = String(name);
            if (name === this._name) {
                return;
            }
            if (this.objectStore.indexNames.indexOf(name) >= 0) {
                throw new errors_1.ConstraintError();
            }
            var oldName = this._name;
            var oldIndexNames = this.objectStore.indexNames.slice();
            this._name = name;
            this._rawIndex.name = name;
            this.objectStore._indexesCache.delete(oldName);
            this.objectStore._indexesCache.set(name, this);
            this.objectStore._rawObjectStore.rawIndexes.delete(oldName);
            this.objectStore._rawObjectStore.rawIndexes.set(name, this._rawIndex);
            this.objectStore.indexNames = fakeDOMStringList_1.default(Array.from(this.objectStore._rawObjectStore.rawIndexes.keys()).filter(function (indexName) {
                var index = _this.objectStore._rawObjectStore.rawIndexes.get(indexName);
                return index && !index.deleted;
            })).sort();
            transaction._rollbackLog.push(function () {
                _this._name = oldName;
                _this._rawIndex.name = oldName;
                _this.objectStore._indexesCache.delete(name);
                _this.objectStore._indexesCache.set(oldName, _this);
                _this.objectStore._rawObjectStore.rawIndexes.delete(name);
                _this.objectStore._rawObjectStore.rawIndexes.set(oldName, _this._rawIndex);
                _this.objectStore.indexNames = fakeDOMStringList_1.default(oldIndexNames);
            });
        },
        enumerable: true,
        configurable: true
    });
    // tslint:disable-next-line max-line-length
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openCursor-IDBRequest-any-range-IDBCursorDirection-direction
    FDBIndex.prototype.openCursor = function (range, direction) {
        confirmActiveTransaction(this);
        if (range === null) {
            range = undefined;
        }
        if (range !== undefined && !(range instanceof FDBKeyRange_1.default)) {
            range = FDBKeyRange_1.default.only(valueToKey_1.default(range));
        }
        var request = new FDBRequest_1.default();
        request.source = this;
        request.transaction = this.objectStore.transaction;
        var cursor = new FDBCursorWithValue_1.default(this, range, direction, request);
        return this.objectStore.transaction._execRequestAsync({
            operation: cursor._iterate.bind(cursor),
            request: request,
            source: this,
        });
    };
    // tslint:disable-next-line max-line-length
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-openKeyCursor-IDBRequest-any-range-IDBCursorDirection-direction
    FDBIndex.prototype.openKeyCursor = function (range, direction) {
        confirmActiveTransaction(this);
        if (range === null) {
            range = undefined;
        }
        if (range !== undefined && !(range instanceof FDBKeyRange_1.default)) {
            range = FDBKeyRange_1.default.only(valueToKey_1.default(range));
        }
        var request = new FDBRequest_1.default();
        request.source = this;
        request.transaction = this.objectStore.transaction;
        var cursor = new FDBCursor_1.default(this, range, direction, request, true);
        return this.objectStore.transaction._execRequestAsync({
            operation: cursor._iterate.bind(cursor),
            request: request,
            source: this,
        });
    };
    FDBIndex.prototype.get = function (key) {
        confirmActiveTransaction(this);
        if (!(key instanceof FDBKeyRange_1.default)) {
            key = valueToKey_1.default(key);
        }
        return this.objectStore.transaction._execRequestAsync({
            operation: this._rawIndex.getValue.bind(this._rawIndex, key),
            source: this,
        });
    };
    // http://w3c.github.io/IndexedDB/#dom-idbindex-getall
    FDBIndex.prototype.getAll = function (query, count) {
        if (arguments.length > 1 && count !== undefined) {
            count = enforceRange_1.default(count, "unsigned long");
        }
        confirmActiveTransaction(this);
        var range = valueToKeyRange_1.default(query);
        return this.objectStore.transaction._execRequestAsync({
            operation: this._rawIndex.getAllValues.bind(this._rawIndex, range, count),
            source: this,
        });
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-getKey-IDBRequest-any-key
    FDBIndex.prototype.getKey = function (key) {
        confirmActiveTransaction(this);
        if (!(key instanceof FDBKeyRange_1.default)) {
            key = valueToKey_1.default(key);
        }
        return this.objectStore.transaction._execRequestAsync({
            operation: this._rawIndex.getKey.bind(this._rawIndex, key),
            source: this,
        });
    };
    // http://w3c.github.io/IndexedDB/#dom-idbindex-getallkeys
    FDBIndex.prototype.getAllKeys = function (query, count) {
        if (arguments.length > 1 && count !== undefined) {
            count = enforceRange_1.default(count, "unsigned long");
        }
        confirmActiveTransaction(this);
        var range = valueToKeyRange_1.default(query);
        return this.objectStore.transaction._execRequestAsync({
            operation: this._rawIndex.getAllKeys.bind(this._rawIndex, range, count),
            source: this,
        });
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBIndex-count-IDBRequest-any-key
    FDBIndex.prototype.count = function (key) {
        var _this = this;
        confirmActiveTransaction(this);
        if (key === null) {
            key = undefined;
        }
        if (key !== undefined && !(key instanceof FDBKeyRange_1.default)) {
            key = FDBKeyRange_1.default.only(valueToKey_1.default(key));
        }
        return this.objectStore.transaction._execRequestAsync({
            operation: function () {
                var count = 0;
                var cursor = new FDBCursor_1.default(_this, key);
                while (cursor._iterate() !== null) {
                    count += 1;
                }
                return count;
            },
            source: this,
        });
    };
    FDBIndex.prototype.toString = function () {
        return "[object IDBIndex]";
    };
    return FDBIndex;
}());
exports.default = FDBIndex;

},{"./FDBCursor":466,"./FDBCursorWithValue":467,"./FDBKeyRange":471,"./FDBRequest":474,"./lib/enforceRange":487,"./lib/errors":488,"./lib/fakeDOMStringList":490,"./lib/valueToKey":493,"./lib/valueToKeyRange":494}],471:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var cmp_1 = require("./lib/cmp");
var errors_1 = require("./lib/errors");
var valueToKey_1 = require("./lib/valueToKey");
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#range-concept
var FDBKeyRange = /** @class */ (function () {
    function FDBKeyRange(lower, upper, lowerOpen, upperOpen) {
        this.lower = lower;
        this.upper = upper;
        this.lowerOpen = lowerOpen;
        this.upperOpen = upperOpen;
    }
    FDBKeyRange.only = function (value) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        value = valueToKey_1.default(value);
        return new FDBKeyRange(value, value, false, false);
    };
    FDBKeyRange.lowerBound = function (lower, open) {
        if (open === void 0) { open = false; }
        if (arguments.length === 0) {
            throw new TypeError();
        }
        lower = valueToKey_1.default(lower);
        return new FDBKeyRange(lower, undefined, open, true);
    };
    FDBKeyRange.upperBound = function (upper, open) {
        if (open === void 0) { open = false; }
        if (arguments.length === 0) {
            throw new TypeError();
        }
        upper = valueToKey_1.default(upper);
        return new FDBKeyRange(undefined, upper, true, open);
    };
    FDBKeyRange.bound = function (lower, upper, lowerOpen, upperOpen) {
        if (lowerOpen === void 0) { lowerOpen = false; }
        if (upperOpen === void 0) { upperOpen = false; }
        if (arguments.length < 2) {
            throw new TypeError();
        }
        var cmpResult = cmp_1.default(lower, upper);
        if (cmpResult === 1 || (cmpResult === 0 && (lowerOpen || upperOpen))) {
            throw new errors_1.DataError();
        }
        lower = valueToKey_1.default(lower);
        upper = valueToKey_1.default(upper);
        return new FDBKeyRange(lower, upper, lowerOpen, upperOpen);
    };
    // https://w3c.github.io/IndexedDB/#dom-idbkeyrange-includes
    FDBKeyRange.prototype.includes = function (key) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        key = valueToKey_1.default(key);
        if (this.lower !== undefined) {
            var cmpResult = cmp_1.default(this.lower, key);
            if (cmpResult === 1 || (cmpResult === 0 && this.lowerOpen)) {
                return false;
            }
        }
        if (this.upper !== undefined) {
            var cmpResult = cmp_1.default(this.upper, key);
            if (cmpResult === -1 || (cmpResult === 0 && this.upperOpen)) {
                return false;
            }
        }
        return true;
    };
    FDBKeyRange.prototype.toString = function () {
        return "[object IDBKeyRange]";
    };
    return FDBKeyRange;
}());
exports.default = FDBKeyRange;

},{"./lib/cmp":486,"./lib/errors":488,"./lib/valueToKey":493}],472:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FDBCursor_1 = require("./FDBCursor");
var FDBCursorWithValue_1 = require("./FDBCursorWithValue");
var FDBIndex_1 = require("./FDBIndex");
var FDBKeyRange_1 = require("./FDBKeyRange");
var FDBRequest_1 = require("./FDBRequest");
var canInjectKey_1 = require("./lib/canInjectKey");
var enforceRange_1 = require("./lib/enforceRange");
var errors_1 = require("./lib/errors");
var extractKey_1 = require("./lib/extractKey");
var fakeDOMStringList_1 = require("./lib/fakeDOMStringList");
var Index_1 = require("./lib/Index");
var structuredClone_1 = require("./lib/structuredClone");
var validateKeyPath_1 = require("./lib/validateKeyPath");
var valueToKey_1 = require("./lib/valueToKey");
var valueToKeyRange_1 = require("./lib/valueToKeyRange");
var confirmActiveTransaction = function (objectStore) {
    if (objectStore._rawObjectStore.deleted) {
        throw new errors_1.InvalidStateError();
    }
    if (objectStore.transaction._state !== "active") {
        throw new errors_1.TransactionInactiveError();
    }
};
var buildRecordAddPut = function (objectStore, value, key) {
    confirmActiveTransaction(objectStore);
    if (objectStore.transaction.mode === "readonly") {
        throw new errors_1.ReadOnlyError();
    }
    if (objectStore.keyPath !== null) {
        if (key !== undefined) {
            throw new errors_1.DataError();
        }
    }
    var clone = structuredClone_1.default(value);
    if (objectStore.keyPath !== null) {
        var tempKey = extractKey_1.default(objectStore.keyPath, clone);
        if (tempKey !== undefined) {
            valueToKey_1.default(tempKey);
        }
        else {
            if (!objectStore._rawObjectStore.keyGenerator) {
                throw new errors_1.DataError();
            }
            else if (!canInjectKey_1.default(objectStore.keyPath, clone)) {
                throw new errors_1.DataError();
            }
        }
    }
    if (objectStore.keyPath === null &&
        objectStore._rawObjectStore.keyGenerator === null &&
        key === undefined) {
        throw new errors_1.DataError();
    }
    if (key !== undefined) {
        key = valueToKey_1.default(key);
    }
    return {
        key: key,
        value: clone,
    };
};
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#object-store
var FDBObjectStore = /** @class */ (function () {
    function FDBObjectStore(transaction, rawObjectStore) {
        this._indexesCache = new Map();
        this._rawObjectStore = rawObjectStore;
        this._name = rawObjectStore.name;
        this.keyPath = rawObjectStore.keyPath;
        this.autoIncrement = rawObjectStore.autoIncrement;
        this.transaction = transaction;
        this.indexNames = fakeDOMStringList_1.default(Array.from(rawObjectStore.rawIndexes.keys())).sort();
    }
    Object.defineProperty(FDBObjectStore.prototype, "name", {
        get: function () {
            return this._name;
        },
        // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-name
        set: function (name) {
            var _this = this;
            var transaction = this.transaction;
            if (!transaction.db._runningVersionchangeTransaction) {
                throw new errors_1.InvalidStateError();
            }
            confirmActiveTransaction(this);
            name = String(name);
            if (name === this._name) {
                return;
            }
            if (this._rawObjectStore.rawDatabase.rawObjectStores.has(name)) {
                throw new errors_1.ConstraintError();
            }
            var oldName = this._name;
            var oldObjectStoreNames = transaction.db.objectStoreNames.slice();
            this._name = name;
            this._rawObjectStore.name = name;
            this.transaction._objectStoresCache.delete(oldName);
            this.transaction._objectStoresCache.set(name, this);
            this._rawObjectStore.rawDatabase.rawObjectStores.delete(oldName);
            this._rawObjectStore.rawDatabase.rawObjectStores.set(name, this._rawObjectStore);
            transaction.db.objectStoreNames = fakeDOMStringList_1.default(Array.from(this._rawObjectStore.rawDatabase.rawObjectStores.keys()).filter(function (objectStoreName) {
                var objectStore = _this._rawObjectStore.rawDatabase.rawObjectStores.get(objectStoreName);
                return objectStore && !objectStore.deleted;
            })).sort();
            var oldScope = new Set(transaction._scope);
            var oldTransactionObjectStoreNames = transaction.objectStoreNames.slice();
            this.transaction._scope.delete(oldName);
            transaction._scope.add(name);
            transaction.objectStoreNames = fakeDOMStringList_1.default(Array.from(transaction._scope).sort());
            transaction._rollbackLog.push(function () {
                _this._name = oldName;
                _this._rawObjectStore.name = oldName;
                _this.transaction._objectStoresCache.delete(name);
                _this.transaction._objectStoresCache.set(oldName, _this);
                _this._rawObjectStore.rawDatabase.rawObjectStores.delete(name);
                _this._rawObjectStore.rawDatabase.rawObjectStores.set(oldName, _this._rawObjectStore);
                transaction.db.objectStoreNames = fakeDOMStringList_1.default(oldObjectStoreNames);
                transaction._scope = oldScope;
                transaction.objectStoreNames = fakeDOMStringList_1.default(oldTransactionObjectStoreNames);
            });
        },
        enumerable: true,
        configurable: true
    });
    FDBObjectStore.prototype.put = function (value, key) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        var record = buildRecordAddPut(this, value, key);
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, false, this.transaction._rollbackLog),
            source: this,
        });
    };
    FDBObjectStore.prototype.add = function (value, key) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        var record = buildRecordAddPut(this, value, key);
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.storeRecord.bind(this._rawObjectStore, record, true, this.transaction._rollbackLog),
            source: this,
        });
    };
    FDBObjectStore.prototype.delete = function (key) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        confirmActiveTransaction(this);
        if (this.transaction.mode === "readonly") {
            throw new errors_1.ReadOnlyError();
        }
        if (!(key instanceof FDBKeyRange_1.default)) {
            key = valueToKey_1.default(key);
        }
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.deleteRecord.bind(this._rawObjectStore, key, this.transaction._rollbackLog),
            source: this,
        });
    };
    FDBObjectStore.prototype.get = function (key) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        confirmActiveTransaction(this);
        if (!(key instanceof FDBKeyRange_1.default)) {
            key = valueToKey_1.default(key);
        }
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.getValue.bind(this._rawObjectStore, key),
            source: this,
        });
    };
    // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getall
    FDBObjectStore.prototype.getAll = function (query, count) {
        if (arguments.length > 1 && count !== undefined) {
            count = enforceRange_1.default(count, "unsigned long");
        }
        confirmActiveTransaction(this);
        var range = valueToKeyRange_1.default(query);
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.getAllValues.bind(this._rawObjectStore, range, count),
            source: this,
        });
    };
    // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getkey
    FDBObjectStore.prototype.getKey = function (key) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        confirmActiveTransaction(this);
        if (!(key instanceof FDBKeyRange_1.default)) {
            key = valueToKey_1.default(key);
        }
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.getKey.bind(this._rawObjectStore, key),
            source: this,
        });
    };
    // http://w3c.github.io/IndexedDB/#dom-idbobjectstore-getallkeys
    FDBObjectStore.prototype.getAllKeys = function (query, count) {
        if (arguments.length > 1 && count !== undefined) {
            count = enforceRange_1.default(count, "unsigned long");
        }
        confirmActiveTransaction(this);
        var range = valueToKeyRange_1.default(query);
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.getAllKeys.bind(this._rawObjectStore, range, count),
            source: this,
        });
    };
    FDBObjectStore.prototype.clear = function () {
        confirmActiveTransaction(this);
        if (this.transaction.mode === "readonly") {
            throw new errors_1.ReadOnlyError();
        }
        return this.transaction._execRequestAsync({
            operation: this._rawObjectStore.clear.bind(this._rawObjectStore, this.transaction._rollbackLog),
            source: this,
        });
    };
    FDBObjectStore.prototype.openCursor = function (range, direction) {
        confirmActiveTransaction(this);
        if (range === null) {
            range = undefined;
        }
        if (range !== undefined && !(range instanceof FDBKeyRange_1.default)) {
            range = FDBKeyRange_1.default.only(valueToKey_1.default(range));
        }
        var request = new FDBRequest_1.default();
        request.source = this;
        request.transaction = this.transaction;
        var cursor = new FDBCursorWithValue_1.default(this, range, direction, request);
        return this.transaction._execRequestAsync({
            operation: cursor._iterate.bind(cursor),
            request: request,
            source: this,
        });
    };
    FDBObjectStore.prototype.openKeyCursor = function (range, direction) {
        confirmActiveTransaction(this);
        if (range === null) {
            range = undefined;
        }
        if (range !== undefined && !(range instanceof FDBKeyRange_1.default)) {
            range = FDBKeyRange_1.default.only(valueToKey_1.default(range));
        }
        var request = new FDBRequest_1.default();
        request.source = this;
        request.transaction = this.transaction;
        var cursor = new FDBCursor_1.default(this, range, direction, request, true);
        return this.transaction._execRequestAsync({
            operation: cursor._iterate.bind(cursor),
            request: request,
            source: this,
        });
    };
    // tslint:disable-next-line max-line-length
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-createIndex-IDBIndex-DOMString-name-DOMString-sequence-DOMString--keyPath-IDBIndexParameters-optionalParameters
    FDBObjectStore.prototype.createIndex = function (name, keyPath, optionalParameters) {
        var _this = this;
        if (optionalParameters === void 0) { optionalParameters = {}; }
        if (arguments.length < 2) {
            throw new TypeError();
        }
        var multiEntry = optionalParameters.multiEntry !== undefined
            ? optionalParameters.multiEntry
            : false;
        var unique = optionalParameters.unique !== undefined
            ? optionalParameters.unique
            : false;
        if (this.transaction.mode !== "versionchange") {
            throw new errors_1.InvalidStateError();
        }
        confirmActiveTransaction(this);
        if (this.indexNames.indexOf(name) >= 0) {
            throw new errors_1.ConstraintError();
        }
        validateKeyPath_1.default(keyPath);
        if (Array.isArray(keyPath) && multiEntry) {
            throw new errors_1.InvalidAccessError();
        }
        // The index that is requested to be created can contain constraints on the data allowed in the index's
        // referenced object store, such as requiring uniqueness of the values referenced by the index's keyPath. If the
        // referenced object store already contains data which violates these constraints, this MUST NOT cause the
        // implementation of createIndex to throw an exception or affect what it returns. The implementation MUST still
        // create and return an IDBIndex object. Instead the implementation must queue up an operation to abort the
        // "versionchange" transaction which was used for the createIndex call.
        var indexNames = this.indexNames.slice();
        this.transaction._rollbackLog.push(function () {
            var index2 = _this._rawObjectStore.rawIndexes.get(name);
            if (index2) {
                index2.deleted = true;
            }
            _this.indexNames = fakeDOMStringList_1.default(indexNames);
            _this._rawObjectStore.rawIndexes.delete(name);
        });
        var index = new Index_1.default(this._rawObjectStore, name, keyPath, multiEntry, unique);
        this.indexNames.push(name);
        this.indexNames.sort();
        this._rawObjectStore.rawIndexes.set(name, index);
        index.initialize(this.transaction); // This is async by design
        return new FDBIndex_1.default(this, index);
    };
    // https://w3c.github.io/IndexedDB/#dom-idbobjectstore-index
    FDBObjectStore.prototype.index = function (name) {
        if (arguments.length === 0) {
            throw new TypeError();
        }
        if (this._rawObjectStore.deleted ||
            this.transaction._state === "finished") {
            throw new errors_1.InvalidStateError();
        }
        var index = this._indexesCache.get(name);
        if (index !== undefined) {
            return index;
        }
        var rawIndex = this._rawObjectStore.rawIndexes.get(name);
        if (this.indexNames.indexOf(name) < 0 || rawIndex === undefined) {
            throw new errors_1.NotFoundError();
        }
        var index2 = new FDBIndex_1.default(this, rawIndex);
        this._indexesCache.set(name, index2);
        return index2;
    };
    FDBObjectStore.prototype.deleteIndex = function (name) {
        var _this = this;
        if (arguments.length === 0) {
            throw new TypeError();
        }
        if (this.transaction.mode !== "versionchange") {
            throw new errors_1.InvalidStateError();
        }
        confirmActiveTransaction(this);
        var rawIndex = this._rawObjectStore.rawIndexes.get(name);
        if (rawIndex === undefined) {
            throw new errors_1.NotFoundError();
        }
        this.transaction._rollbackLog.push(function () {
            rawIndex.deleted = false;
            _this._rawObjectStore.rawIndexes.set(name, rawIndex);
            _this.indexNames.push(name);
            _this.indexNames.sort();
        });
        this.indexNames = fakeDOMStringList_1.default(this.indexNames.filter(function (indexName) {
            return indexName !== name;
        }));
        rawIndex.deleted = true; // Not sure if this is supposed to happen synchronously
        this.transaction._execRequestAsync({
            operation: function () {
                var rawIndex2 = _this._rawObjectStore.rawIndexes.get(name);
                // Hack in case another index is given this name before this async request is processed. It'd be better
                // to have a real unique ID for each index.
                if (rawIndex === rawIndex2) {
                    _this._rawObjectStore.rawIndexes.delete(name);
                }
            },
            source: this,
        });
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#widl-IDBObjectStore-count-IDBRequest-any-key
    FDBObjectStore.prototype.count = function (key) {
        var _this = this;
        confirmActiveTransaction(this);
        if (key === null) {
            key = undefined;
        }
        if (key !== undefined && !(key instanceof FDBKeyRange_1.default)) {
            key = FDBKeyRange_1.default.only(valueToKey_1.default(key));
        }
        return this.transaction._execRequestAsync({
            operation: function () {
                var count = 0;
                var cursor = new FDBCursor_1.default(_this, key);
                while (cursor._iterate() !== null) {
                    count += 1;
                }
                return count;
            },
            source: this,
        });
    };
    FDBObjectStore.prototype.toString = function () {
        return "[object IDBObjectStore]";
    };
    return FDBObjectStore;
}());
exports.default = FDBObjectStore;

},{"./FDBCursor":466,"./FDBCursorWithValue":467,"./FDBIndex":470,"./FDBKeyRange":471,"./FDBRequest":474,"./lib/Index":481,"./lib/canInjectKey":485,"./lib/enforceRange":487,"./lib/errors":488,"./lib/extractKey":489,"./lib/fakeDOMStringList":490,"./lib/structuredClone":491,"./lib/validateKeyPath":492,"./lib/valueToKey":493,"./lib/valueToKeyRange":494}],473:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var FDBRequest_1 = require("./FDBRequest");
var FDBOpenDBRequest = /** @class */ (function (_super) {
    __extends(FDBOpenDBRequest, _super);
    function FDBOpenDBRequest() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onupgradeneeded = null;
        _this.onblocked = null;
        return _this;
    }
    FDBOpenDBRequest.prototype.toString = function () {
        return "[object IDBOpenDBRequest]";
    };
    return FDBOpenDBRequest;
}(FDBRequest_1.default));
exports.default = FDBOpenDBRequest;

},{"./FDBRequest":474}],474:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./lib/errors");
var FakeEventTarget_1 = require("./lib/FakeEventTarget");
var FDBRequest = /** @class */ (function (_super) {
    __extends(FDBRequest, _super);
    function FDBRequest() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._result = null;
        _this._error = null;
        _this.source = null;
        _this.transaction = null;
        _this.readyState = "pending";
        _this.onsuccess = null;
        _this.onerror = null;
        return _this;
    }
    Object.defineProperty(FDBRequest.prototype, "error", {
        get: function () {
            if (this.readyState === "pending") {
                throw new errors_1.InvalidStateError();
            }
            return this._error;
        },
        set: function (value) {
            this._error = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FDBRequest.prototype, "result", {
        get: function () {
            if (this.readyState === "pending") {
                throw new errors_1.InvalidStateError();
            }
            return this._result;
        },
        set: function (value) {
            this._result = value;
        },
        enumerable: true,
        configurable: true
    });
    FDBRequest.prototype.toString = function () {
        return "[object IDBRequest]";
    };
    return FDBRequest;
}(FakeEventTarget_1.default));
exports.default = FDBRequest;

},{"./lib/FakeEventTarget":480,"./lib/errors":488}],475:[function(require,module,exports){
(function (setImmediate){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var FDBObjectStore_1 = require("./FDBObjectStore");
var FDBRequest_1 = require("./FDBRequest");
var errors_1 = require("./lib/errors");
var fakeDOMStringList_1 = require("./lib/fakeDOMStringList");
var FakeEvent_1 = require("./lib/FakeEvent");
var FakeEventTarget_1 = require("./lib/FakeEventTarget");
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#transaction
var FDBTransaction = /** @class */ (function (_super) {
    __extends(FDBTransaction, _super);
    function FDBTransaction(storeNames, mode, db) {
        var _this = _super.call(this) || this;
        _this._state = "active";
        _this._started = false;
        _this._rollbackLog = [];
        _this._objectStoresCache = new Map();
        _this.error = null;
        _this.onabort = null;
        _this.oncomplete = null;
        _this.onerror = null;
        _this._requests = [];
        _this._scope = new Set(storeNames);
        _this.mode = mode;
        _this.db = db;
        _this.objectStoreNames = fakeDOMStringList_1.default(Array.from(_this._scope).sort());
        return _this;
    }
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-aborting-a-transaction
    FDBTransaction.prototype._abort = function (errName) {
        var _this = this;
        var e_1, _a, e_2, _b;
        try {
            for (var _c = __values(this._rollbackLog.reverse()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var f = _d.value;
                f();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (errName !== null) {
            var e = new Error();
            e.name = errName;
            this.error = e;
        }
        try {
            // Should this directly remove from _requests?
            for (var _e = __values(this._requests), _f = _e.next(); !_f.done; _f = _e.next()) {
                var request = _f.value.request;
                if (request.readyState !== "done") {
                    request.readyState = "done"; // This will cancel execution of this request's operation
                    if (request.source) {
                        request.result = undefined;
                        request.error = new errors_1.AbortError();
                        var event_1 = new FakeEvent_1.default("error", {
                            bubbles: true,
                            cancelable: true,
                        });
                        event_1.eventPath = [this.db, this];
                        request.dispatchEvent(event_1);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
        setImmediate(function () {
            var event = new FakeEvent_1.default("abort", {
                bubbles: true,
                cancelable: false,
            });
            event.eventPath = [_this.db];
            _this.dispatchEvent(event);
        });
        this._state = "finished";
    };
    FDBTransaction.prototype.abort = function () {
        if (this._state === "committing" || this._state === "finished") {
            throw new errors_1.InvalidStateError();
        }
        this._state = "active";
        this._abort(null);
    };
    // http://w3c.github.io/IndexedDB/#dom-idbtransaction-objectstore
    FDBTransaction.prototype.objectStore = function (name) {
        if (this._state !== "active") {
            throw new errors_1.InvalidStateError();
        }
        var objectStore = this._objectStoresCache.get(name);
        if (objectStore !== undefined) {
            return objectStore;
        }
        var rawObjectStore = this.db._rawDatabase.rawObjectStores.get(name);
        if (!this._scope.has(name) || rawObjectStore === undefined) {
            throw new errors_1.NotFoundError();
        }
        var objectStore2 = new FDBObjectStore_1.default(this, rawObjectStore);
        this._objectStoresCache.set(name, objectStore2);
        return objectStore2;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-asynchronously-executing-a-request
    FDBTransaction.prototype._execRequestAsync = function (obj) {
        var source = obj.source;
        var operation = obj.operation;
        var request = obj.hasOwnProperty("request") ? obj.request : null;
        if (this._state !== "active") {
            throw new errors_1.TransactionInactiveError();
        }
        // Request should only be passed for cursors
        if (!request) {
            if (!source) {
                // Special requests like indexes that just need to run some code
                request = new FDBRequest_1.default();
            }
            else {
                request = new FDBRequest_1.default();
                request.source = source;
                request.transaction = source.transaction;
            }
        }
        this._requests.push({
            operation: operation,
            request: request,
        });
        return request;
    };
    FDBTransaction.prototype._start = function () {
        this._started = true;
        // Remove from request queue - cursor ones will be added back if necessary by cursor.continue and such
        var operation;
        var request;
        while (this._requests.length > 0) {
            var r = this._requests.shift();
            // This should only be false if transaction was aborted
            if (r && r.request.readyState !== "done") {
                request = r.request;
                operation = r.operation;
                break;
            }
        }
        if (request && operation) {
            if (!request.source) {
                // Special requests like indexes that just need to run some code, with error handling already built into
                // operation
                operation();
            }
            else {
                var defaultAction = void 0;
                var event_2;
                try {
                    var result = operation();
                    request.readyState = "done";
                    request.result = result;
                    request.error = undefined;
                    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-fire-a-success-event
                    if (this._state === "inactive") {
                        this._state = "active";
                    }
                    event_2 = new FakeEvent_1.default("success", {
                        bubbles: false,
                        cancelable: false,
                    });
                }
                catch (err) {
                    request.readyState = "done";
                    request.result = undefined;
                    request.error = err;
                    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-fire-an-error-event
                    if (this._state === "inactive") {
                        this._state = "active";
                    }
                    event_2 = new FakeEvent_1.default("error", {
                        bubbles: true,
                        cancelable: true,
                    });
                    defaultAction = this._abort.bind(this, err.name);
                }
                try {
                    event_2.eventPath = [this.db, this];
                    request.dispatchEvent(event_2);
                }
                catch (err) {
                    if (this._state !== "committing") {
                        this._abort("AbortError");
                    }
                    throw err;
                }
                // Default action of event
                if (!event_2.canceled) {
                    if (defaultAction) {
                        defaultAction();
                    }
                }
            }
            // On to the next one
            if (this._requests.length > 0) {
                this._start();
            }
            else {
                // Give it another chance for new handlers to be set before finishing
                setImmediate(this._start.bind(this));
            }
            return;
        }
        // Check if transaction complete event needs to be fired
        if (this._state !== "finished") {
            // Either aborted or committed already
            this._state = "finished";
            if (!this.error) {
                var event_3 = new FakeEvent_1.default("complete");
                this.dispatchEvent(event_3);
            }
        }
    };
    FDBTransaction.prototype.commit = function () {
        if (this._state !== "active") {
            throw new errors_1.InvalidStateError();
        }
        this._state = "committing";
    };
    FDBTransaction.prototype.toString = function () {
        return "[object IDBRequest]";
    };
    return FDBTransaction;
}(FakeEventTarget_1.default));
exports.default = FDBTransaction;

}).call(this,require("timers").setImmediate)
},{"./FDBObjectStore":472,"./FDBRequest":474,"./lib/FakeEvent":479,"./lib/FakeEventTarget":480,"./lib/errors":488,"./lib/fakeDOMStringList":490,"timers":602}],476:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var FakeEvent_1 = require("./lib/FakeEvent");
var FDBVersionChangeEvent = /** @class */ (function (_super) {
    __extends(FDBVersionChangeEvent, _super);
    function FDBVersionChangeEvent(type, parameters) {
        if (parameters === void 0) { parameters = {}; }
        var _this = _super.call(this, type) || this;
        _this.newVersion =
            parameters.newVersion !== undefined ? parameters.newVersion : null;
        _this.oldVersion =
            parameters.oldVersion !== undefined ? parameters.oldVersion : 0;
        return _this;
    }
    FDBVersionChangeEvent.prototype.toString = function () {
        return "[object IDBVersionChangeEvent]";
    };
    return FDBVersionChangeEvent;
}(FakeEvent_1.default));
exports.default = FDBVersionChangeEvent;

},{"./lib/FakeEvent":479}],477:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FDBFactory_1 = require("./FDBFactory");
var fakeIndexedDB = new FDBFactory_1.default();
exports.default = fakeIndexedDB;

},{"./FDBFactory":469}],478:[function(require,module,exports){
(function (setImmediate){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-database
var Database = /** @class */ (function () {
    function Database(name, version) {
        this.deletePending = false;
        this.transactions = [];
        this.rawObjectStores = new Map();
        this.connections = [];
        this.name = name;
        this.version = version;
        this.processTransactions = this.processTransactions.bind(this);
    }
    Database.prototype.processTransactions = function () {
        var _this = this;
        setImmediate(function () {
            var anyRunning = _this.transactions.some(function (transaction) {
                return (transaction._started && transaction._state !== "finished");
            });
            if (!anyRunning) {
                var next = _this.transactions.find(function (transaction) {
                    return (!transaction._started &&
                        transaction._state !== "finished");
                });
                if (next) {
                    next._start();
                    next.addEventListener("complete", _this.processTransactions);
                    next.addEventListener("abort", _this.processTransactions);
                }
            }
        });
    };
    return Database;
}());
exports.default = Database;

}).call(this,require("timers").setImmediate)
},{"timers":602}],479:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Event = /** @class */ (function () {
    function Event(type, eventInitDict) {
        if (eventInitDict === void 0) { eventInitDict = {}; }
        this.eventPath = [];
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        // Flags
        this.propagationStopped = false;
        this.immediatePropagationStopped = false;
        this.canceled = false;
        this.initialized = true;
        this.dispatched = false;
        this.target = null;
        this.currentTarget = null;
        this.eventPhase = 0;
        this.defaultPrevented = false;
        this.isTrusted = false;
        this.timeStamp = Date.now();
        this.type = type;
        this.bubbles =
            eventInitDict.bubbles !== undefined ? eventInitDict.bubbles : false;
        this.cancelable =
            eventInitDict.cancelable !== undefined
                ? eventInitDict.cancelable
                : false;
    }
    Event.prototype.preventDefault = function () {
        if (this.cancelable) {
            this.canceled = true;
        }
    };
    Event.prototype.stopPropagation = function () {
        this.propagationStopped = true;
    };
    Event.prototype.stopImmediatePropagation = function () {
        this.propagationStopped = true;
        this.immediatePropagationStopped = true;
    };
    return Event;
}());
exports.default = Event;

},{}],480:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var stopped = function (event, listener) {
    return (event.immediatePropagationStopped ||
        (event.eventPhase === event.CAPTURING_PHASE &&
            listener.capture === false) ||
        (event.eventPhase === event.BUBBLING_PHASE && listener.capture === true));
};
// http://www.w3.org/TR/dom/#concept-event-listener-invoke
var invokeEventListeners = function (event, obj) {
    var e_1, _a;
    event.currentTarget = obj;
    try {
        // The callback might cause obj.listeners to mutate as we traverse it.
        // Take a copy of the array so that nothing sneaks in and we don't lose
        // our place.
        for (var _b = __values(obj.listeners.slice()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var listener = _c.value;
            if (event.type !== listener.type || stopped(event, listener)) {
                continue;
            }
            // @ts-ignore
            listener.callback.call(event.currentTarget, event);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    var typeToProp = {
        abort: "onabort",
        blocked: "onblocked",
        complete: "oncomplete",
        error: "onerror",
        success: "onsuccess",
        upgradeneeded: "onupgradeneeded",
        versionchange: "onversionchange",
    };
    var prop = typeToProp[event.type];
    if (prop === undefined) {
        throw new Error("Unknown event type: \"" + event.type + "\"");
    }
    var callback = event.currentTarget[prop];
    if (callback) {
        var listener = {
            callback: callback,
            capture: false,
            type: event.type,
        };
        if (!stopped(event, listener)) {
            // @ts-ignore
            listener.callback.call(event.currentTarget, event);
        }
    }
};
var FakeEventTarget = /** @class */ (function () {
    function FakeEventTarget() {
        this.listeners = [];
    }
    FakeEventTarget.prototype.addEventListener = function (type, callback, capture) {
        if (capture === void 0) { capture = false; }
        this.listeners.push({
            callback: callback,
            capture: capture,
            type: type,
        });
    };
    FakeEventTarget.prototype.removeEventListener = function (type, callback, capture) {
        if (capture === void 0) { capture = false; }
        var i = this.listeners.findIndex(function (listener) {
            return (listener.type === type &&
                listener.callback === callback &&
                listener.capture === capture);
        });
        this.listeners.splice(i, 1);
    };
    // http://www.w3.org/TR/dom/#dispatching-events
    FakeEventTarget.prototype.dispatchEvent = function (event) {
        var e_2, _a, e_3, _b;
        if (event.dispatched || !event.initialized) {
            throw new errors_1.InvalidStateError("The object is in an invalid state.");
        }
        event.isTrusted = false;
        event.dispatched = true;
        event.target = this;
        // NOT SURE WHEN THIS SHOULD BE SET        event.eventPath = [];
        event.eventPhase = event.CAPTURING_PHASE;
        try {
            for (var _c = __values(event.eventPath), _d = _c.next(); !_d.done; _d = _c.next()) {
                var obj = _d.value;
                if (!event.propagationStopped) {
                    invokeEventListeners(event, obj);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        event.eventPhase = event.AT_TARGET;
        if (!event.propagationStopped) {
            invokeEventListeners(event, event.target);
        }
        if (event.bubbles) {
            event.eventPath.reverse();
            event.eventPhase = event.BUBBLING_PHASE;
            try {
                for (var _e = __values(event.eventPath), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var obj = _f.value;
                    if (!event.propagationStopped) {
                        invokeEventListeners(event, obj);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        event.dispatched = false;
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        if (event.canceled) {
            return false;
        }
        return true;
    };
    return FakeEventTarget;
}());
exports.default = FakeEventTarget;

},{"./errors":488}],481:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var extractKey_1 = require("./extractKey");
var RecordStore_1 = require("./RecordStore");
var structuredClone_1 = require("./structuredClone");
var valueToKey_1 = require("./valueToKey");
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-index
var Index = /** @class */ (function () {
    function Index(rawObjectStore, name, keyPath, multiEntry, unique) {
        this.deleted = false;
        // Initialized should be used to decide whether to throw an error or abort the versionchange transaction when there is a
        // constraint
        this.initialized = false;
        this.records = new RecordStore_1.default();
        this.rawObjectStore = rawObjectStore;
        this.name = name;
        this.keyPath = keyPath;
        this.multiEntry = multiEntry;
        this.unique = unique;
    }
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-index
    Index.prototype.getKey = function (key) {
        var record = this.records.get(key);
        return record !== undefined ? record.value : undefined;
    };
    // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
    Index.prototype.getAllKeys = function (range, count) {
        var e_1, _a;
        if (count === undefined || count === 0) {
            count = Infinity;
        }
        var records = [];
        try {
            for (var _b = __values(this.records.values(range)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var record = _c.value;
                records.push(structuredClone_1.default(record.value));
                if (records.length >= count) {
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return records;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#index-referenced-value-retrieval-operation
    Index.prototype.getValue = function (key) {
        var record = this.records.get(key);
        return record !== undefined
            ? this.rawObjectStore.getValue(record.value)
            : undefined;
    };
    // http://w3c.github.io/IndexedDB/#retrieve-multiple-referenced-values-from-an-index
    Index.prototype.getAllValues = function (range, count) {
        var e_2, _a;
        if (count === undefined || count === 0) {
            count = Infinity;
        }
        var records = [];
        try {
            for (var _b = __values(this.records.values(range)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var record = _c.value;
                records.push(this.rawObjectStore.getValue(record.value));
                if (records.length >= count) {
                    break;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return records;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store (step 7)
    Index.prototype.storeRecord = function (newRecord) {
        var e_3, _a, e_4, _b, e_5, _c;
        var indexKey;
        try {
            indexKey = extractKey_1.default(this.keyPath, newRecord.value);
        }
        catch (err) {
            if (err.name === "DataError") {
                // Invalid key is not an actual error, just means we do not store an entry in this index
                return;
            }
            throw err;
        }
        if (!this.multiEntry || !Array.isArray(indexKey)) {
            try {
                valueToKey_1.default(indexKey);
            }
            catch (e) {
                return;
            }
        }
        else {
            // remove any elements from index key that are not valid keys and remove any duplicate elements from index
            // key such that only one instance of the duplicate value remains.
            var keep = [];
            try {
                for (var indexKey_1 = __values(indexKey), indexKey_1_1 = indexKey_1.next(); !indexKey_1_1.done; indexKey_1_1 = indexKey_1.next()) {
                    var part = indexKey_1_1.value;
                    if (keep.indexOf(part) < 0) {
                        try {
                            keep.push(valueToKey_1.default(part));
                        }
                        catch (err) {
                            /* Do nothing */
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (indexKey_1_1 && !indexKey_1_1.done && (_a = indexKey_1.return)) _a.call(indexKey_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            indexKey = keep;
        }
        if (!this.multiEntry || !Array.isArray(indexKey)) {
            if (this.unique) {
                var existingRecord = this.records.get(indexKey);
                if (existingRecord) {
                    throw new errors_1.ConstraintError();
                }
            }
        }
        else {
            if (this.unique) {
                try {
                    for (var indexKey_2 = __values(indexKey), indexKey_2_1 = indexKey_2.next(); !indexKey_2_1.done; indexKey_2_1 = indexKey_2.next()) {
                        var individualIndexKey = indexKey_2_1.value;
                        var existingRecord = this.records.get(individualIndexKey);
                        if (existingRecord) {
                            throw new errors_1.ConstraintError();
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (indexKey_2_1 && !indexKey_2_1.done && (_b = indexKey_2.return)) _b.call(indexKey_2);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        if (!this.multiEntry || !Array.isArray(indexKey)) {
            this.records.add({
                key: indexKey,
                value: newRecord.key,
            });
        }
        else {
            try {
                for (var indexKey_3 = __values(indexKey), indexKey_3_1 = indexKey_3.next(); !indexKey_3_1.done; indexKey_3_1 = indexKey_3.next()) {
                    var individualIndexKey = indexKey_3_1.value;
                    this.records.add({
                        key: individualIndexKey,
                        value: newRecord.key,
                    });
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (indexKey_3_1 && !indexKey_3_1.done && (_c = indexKey_3.return)) _c.call(indexKey_3);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    };
    Index.prototype.initialize = function (transaction) {
        var _this = this;
        if (this.initialized) {
            throw new Error("Index already initialized");
        }
        transaction._execRequestAsync({
            operation: function () {
                var e_6, _a;
                try {
                    try {
                        // Create index based on current value of objectstore
                        for (var _b = __values(_this.rawObjectStore.records.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var record = _c.value;
                            _this.storeRecord(record);
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                    _this.initialized = true;
                }
                catch (err) {
                    // console.error(err);
                    transaction._abort(err.name);
                }
            },
            source: null,
        });
    };
    return Index;
}());
exports.default = Index;

},{"./RecordStore":484,"./errors":488,"./extractKey":489,"./structuredClone":491,"./valueToKey":493}],482:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var MAX_KEY = 9007199254740992;
var KeyGenerator = /** @class */ (function () {
    function KeyGenerator() {
        // This is kind of wrong. Should start at 1 and increment only after record is saved
        this.num = 0;
    }
    KeyGenerator.prototype.next = function () {
        if (this.num >= MAX_KEY) {
            throw new errors_1.ConstraintError();
        }
        this.num += 1;
        return this.num;
    };
    // https://w3c.github.io/IndexedDB/#possibly-update-the-key-generator
    KeyGenerator.prototype.setIfLarger = function (num) {
        var value = Math.floor(Math.min(num, MAX_KEY)) - 1;
        if (value >= this.num) {
            this.num = value + 1;
        }
    };
    return KeyGenerator;
}());
exports.default = KeyGenerator;

},{"./errors":488}],483:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var extractKey_1 = require("./extractKey");
var KeyGenerator_1 = require("./KeyGenerator");
var RecordStore_1 = require("./RecordStore");
var structuredClone_1 = require("./structuredClone");
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-object-store
var ObjectStore = /** @class */ (function () {
    function ObjectStore(rawDatabase, name, keyPath, autoIncrement) {
        this.deleted = false;
        this.records = new RecordStore_1.default();
        this.rawIndexes = new Map();
        this.rawDatabase = rawDatabase;
        this.keyGenerator = autoIncrement === true ? new KeyGenerator_1.default() : null;
        this.deleted = false;
        this.name = name;
        this.keyPath = keyPath;
        this.autoIncrement = autoIncrement;
    }
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
    ObjectStore.prototype.getKey = function (key) {
        var record = this.records.get(key);
        return record !== undefined ? structuredClone_1.default(record.key) : undefined;
    };
    // http://w3c.github.io/IndexedDB/#retrieve-multiple-keys-from-an-object-store
    ObjectStore.prototype.getAllKeys = function (range, count) {
        var e_1, _a;
        if (count === undefined || count === 0) {
            count = Infinity;
        }
        var records = [];
        try {
            for (var _b = __values(this.records.values(range)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var record = _c.value;
                records.push(structuredClone_1.default(record.key));
                if (records.length >= count) {
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return records;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-retrieving-a-value-from-an-object-store
    ObjectStore.prototype.getValue = function (key) {
        var record = this.records.get(key);
        return record !== undefined ? structuredClone_1.default(record.value) : undefined;
    };
    // http://w3c.github.io/IndexedDB/#retrieve-multiple-values-from-an-object-store
    ObjectStore.prototype.getAllValues = function (range, count) {
        var e_2, _a;
        if (count === undefined || count === 0) {
            count = Infinity;
        }
        var records = [];
        try {
            for (var _b = __values(this.records.values(range)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var record = _c.value;
                records.push(structuredClone_1.default(record.value));
                if (records.length >= count) {
                    break;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return records;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-storing-a-record-into-an-object-store
    ObjectStore.prototype.storeRecord = function (newRecord, noOverwrite, rollbackLog) {
        var _this = this;
        var e_3, _a;
        if (this.keyPath !== null) {
            var key = extractKey_1.default(this.keyPath, newRecord.value);
            if (key !== undefined) {
                newRecord.key = key;
            }
        }
        if (this.keyGenerator !== null && newRecord.key === undefined) {
            if (rollbackLog) {
                var keyGeneratorBefore_1 = this.keyGenerator.num;
                rollbackLog.push(function () {
                    if (_this.keyGenerator) {
                        _this.keyGenerator.num = keyGeneratorBefore_1;
                    }
                });
            }
            newRecord.key = this.keyGenerator.next();
            // Set in value if keyPath defiend but led to no key
            // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-to-assign-a-key-to-a-value-using-a-key-path
            if (this.keyPath !== null) {
                if (Array.isArray(this.keyPath)) {
                    throw new Error("Cannot have an array key path in an object store with a key generator");
                }
                var remainingKeyPath = this.keyPath;
                var object = newRecord.value;
                var identifier = void 0;
                var i = 0; // Just to run the loop at least once
                while (i >= 0) {
                    if (typeof object !== "object") {
                        throw new errors_1.DataError();
                    }
                    i = remainingKeyPath.indexOf(".");
                    if (i >= 0) {
                        identifier = remainingKeyPath.slice(0, i);
                        remainingKeyPath = remainingKeyPath.slice(i + 1);
                        if (!object.hasOwnProperty(identifier)) {
                            object[identifier] = {};
                        }
                        object = object[identifier];
                    }
                }
                identifier = remainingKeyPath;
                object[identifier] = newRecord.key;
            }
        }
        else if (this.keyGenerator !== null &&
            typeof newRecord.key === "number") {
            this.keyGenerator.setIfLarger(newRecord.key);
        }
        var existingRecord = this.records.get(newRecord.key);
        if (existingRecord) {
            if (noOverwrite) {
                throw new errors_1.ConstraintError();
            }
            this.deleteRecord(newRecord.key, rollbackLog);
        }
        this.records.add(newRecord);
        try {
            // Update indexes
            for (var _b = __values(this.rawIndexes.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var rawIndex = _c.value;
                if (rawIndex.initialized) {
                    rawIndex.storeRecord(newRecord);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (rollbackLog) {
            rollbackLog.push(function () {
                _this.deleteRecord(newRecord.key);
            });
        }
        return newRecord.key;
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-deleting-records-from-an-object-store
    ObjectStore.prototype.deleteRecord = function (key, rollbackLog) {
        var _this = this;
        var e_4, _a, e_5, _b;
        var deletedRecords = this.records.delete(key);
        if (rollbackLog) {
            var _loop_1 = function (record) {
                rollbackLog.push(function () {
                    _this.storeRecord(record, true);
                });
            };
            try {
                for (var deletedRecords_1 = __values(deletedRecords), deletedRecords_1_1 = deletedRecords_1.next(); !deletedRecords_1_1.done; deletedRecords_1_1 = deletedRecords_1.next()) {
                    var record = deletedRecords_1_1.value;
                    _loop_1(record);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (deletedRecords_1_1 && !deletedRecords_1_1.done && (_a = deletedRecords_1.return)) _a.call(deletedRecords_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        try {
            for (var _c = __values(this.rawIndexes.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var rawIndex = _d.value;
                rawIndex.records.deleteByValue(key);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    // http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-clearing-an-object-store
    ObjectStore.prototype.clear = function (rollbackLog) {
        var _this = this;
        var e_6, _a, e_7, _b;
        var deletedRecords = this.records.clear();
        if (rollbackLog) {
            var _loop_2 = function (record) {
                rollbackLog.push(function () {
                    _this.storeRecord(record, true);
                });
            };
            try {
                for (var deletedRecords_2 = __values(deletedRecords), deletedRecords_2_1 = deletedRecords_2.next(); !deletedRecords_2_1.done; deletedRecords_2_1 = deletedRecords_2.next()) {
                    var record = deletedRecords_2_1.value;
                    _loop_2(record);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (deletedRecords_2_1 && !deletedRecords_2_1.done && (_a = deletedRecords_2.return)) _a.call(deletedRecords_2);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        try {
            for (var _c = __values(this.rawIndexes.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var rawIndex = _d.value;
                rawIndex.records.clear();
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    return ObjectStore;
}());
exports.default = ObjectStore;

},{"./KeyGenerator":482,"./RecordStore":484,"./errors":488,"./extractKey":489,"./structuredClone":491}],484:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FDBKeyRange_1 = require("../FDBKeyRange");
var cmp_1 = require("./cmp");
var RecordStore = /** @class */ (function () {
    function RecordStore() {
        this.records = [];
    }
    RecordStore.prototype.get = function (key) {
        if (key instanceof FDBKeyRange_1.default) {
            return this.records.find(function (record) {
                return key.includes(record.key);
            });
        }
        return this.records.find(function (record) {
            return cmp_1.default(record.key, key) === 0;
        });
    };
    RecordStore.prototype.add = function (newRecord) {
        // Find where to put it so it's sorted by key
        var i;
        if (this.records.length === 0) {
            i = 0;
        }
        else {
            i = this.records.findIndex(function (record) {
                // cmp will only return 0 for an index. For an object store, any matching key has already been deleted,
                // but we still need to look for cmp = 1 to find where to insert.
                return cmp_1.default(record.key, newRecord.key) >= 0;
            });
            if (i === -1) {
                // If no matching key, add to end
                i = this.records.length;
            }
            else {
                // If matching key, advance to appropriate position based on value (used in indexes)
                while (i < this.records.length &&
                    cmp_1.default(this.records[i].key, newRecord.key) === 0) {
                    if (cmp_1.default(this.records[i].value, newRecord.value) !== -1) {
                        // Record value >= newRecord value, so insert here
                        break;
                    }
                    i += 1; // Look at next record
                }
            }
        }
        this.records.splice(i, 0, newRecord);
    };
    RecordStore.prototype.delete = function (key) {
        var range = key instanceof FDBKeyRange_1.default ? key : FDBKeyRange_1.default.only(key);
        var deletedRecords = [];
        this.records = this.records.filter(function (record) {
            var shouldDelete = range.includes(record.key);
            if (shouldDelete) {
                deletedRecords.push(record);
            }
            return !shouldDelete;
        });
        return deletedRecords;
    };
    RecordStore.prototype.deleteByValue = function (key) {
        var range = key instanceof FDBKeyRange_1.default ? key : FDBKeyRange_1.default.only(key);
        var deletedRecords = [];
        this.records = this.records.filter(function (record) {
            var shouldDelete = range.includes(record.value);
            if (shouldDelete) {
                deletedRecords.push(record);
            }
            return !shouldDelete;
        });
        return deletedRecords;
    };
    RecordStore.prototype.clear = function () {
        var deletedRecords = this.records.slice();
        this.records = [];
        return deletedRecords;
    };
    RecordStore.prototype.values = function (range, direction) {
        var _this = this;
        if (direction === void 0) { direction = "next"; }
        var _a;
        return _a = {},
            _a[Symbol.iterator] = function () {
                var i;
                if (direction === "next") {
                    i = 0;
                    if (range !== undefined && range.lower !== undefined) {
                        while (_this.records[i] !== undefined) {
                            var cmpResult = cmp_1.default(_this.records[i].key, range.lower);
                            if (cmpResult === 1 ||
                                (cmpResult === 0 && !range.lowerOpen)) {
                                break;
                            }
                            i += 1;
                        }
                    }
                }
                else {
                    i = _this.records.length - 1;
                    if (range !== undefined && range.upper !== undefined) {
                        while (_this.records[i] !== undefined) {
                            var cmpResult = cmp_1.default(_this.records[i].key, range.upper);
                            if (cmpResult === -1 ||
                                (cmpResult === 0 && !range.upperOpen)) {
                                break;
                            }
                            i -= 1;
                        }
                    }
                }
                return {
                    next: function () {
                        var done;
                        var value;
                        if (direction === "next") {
                            value = _this.records[i];
                            done = i >= _this.records.length;
                            i += 1;
                            if (!done &&
                                range !== undefined &&
                                range.upper !== undefined) {
                                var cmpResult = cmp_1.default(value.key, range.upper);
                                done =
                                    cmpResult === 1 ||
                                        (cmpResult === 0 && range.upperOpen);
                                if (done) {
                                    value = undefined;
                                }
                            }
                        }
                        else {
                            value = _this.records[i];
                            done = i < 0;
                            i -= 1;
                            if (!done &&
                                range !== undefined &&
                                range.lower !== undefined) {
                                var cmpResult = cmp_1.default(value.key, range.lower);
                                done =
                                    cmpResult === -1 ||
                                        (cmpResult === 0 && range.lowerOpen);
                                if (done) {
                                    value = undefined;
                                }
                            }
                        }
                        // The weird "as IteratorResult<Record>" is needed because of
                        // https://github.com/Microsoft/TypeScript/issues/11375 and
                        // https://github.com/Microsoft/TypeScript/issues/2983
                        // tslint:disable-next-line no-object-literal-type-assertion
                        return {
                            done: done,
                            value: value,
                        };
                    },
                };
            },
            _a;
    };
    return RecordStore;
}());
exports.default = RecordStore;

},{"../FDBKeyRange":471,"./cmp":486}],485:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// http://w3c.github.io/IndexedDB/#check-that-a-key-could-be-injected-into-a-value
var canInjectKey = function (keyPath, value) {
    var e_1, _a;
    if (Array.isArray(keyPath)) {
        // tslint:disable-next-line max-line-length
        throw new Error("The key paths used in this section are always strings and never sequences, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.");
    }
    var identifiers = keyPath.split(".");
    if (identifiers.length === 0) {
        throw new Error("Assert: identifiers is not empty");
    }
    identifiers.pop();
    try {
        for (var identifiers_1 = __values(identifiers), identifiers_1_1 = identifiers_1.next(); !identifiers_1_1.done; identifiers_1_1 = identifiers_1.next()) {
            var identifier = identifiers_1_1.value;
            if (typeof value !== "object" && !Array.isArray(value)) {
                return false;
            }
            var hop = value.hasOwnProperty(identifier);
            if (!hop) {
                return true;
            }
            value = value[identifier];
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (identifiers_1_1 && !identifiers_1_1.done && (_a = identifiers_1.return)) _a.call(identifiers_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return typeof value === "object" || Array.isArray(value);
};
exports.default = canInjectKey;

},{}],486:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var valueToKey_1 = require("./valueToKey");
var getType = function (x) {
    if (typeof x === "number") {
        return "Number";
    }
    if (x instanceof Date) {
        return "Date";
    }
    if (Array.isArray(x)) {
        return "Array";
    }
    if (typeof x === "string") {
        return "String";
    }
    if (x instanceof ArrayBuffer) {
        return "Binary";
    }
    throw new errors_1.DataError();
};
// https://w3c.github.io/IndexedDB/#compare-two-keys
var cmp = function (first, second) {
    if (second === undefined) {
        throw new TypeError();
    }
    first = valueToKey_1.default(first);
    second = valueToKey_1.default(second);
    var t1 = getType(first);
    var t2 = getType(second);
    if (t1 !== t2) {
        if (t1 === "Array") {
            return 1;
        }
        if (t1 === "Binary" &&
            (t2 === "String" || t2 === "Date" || t2 === "Number")) {
            return 1;
        }
        if (t1 === "String" && (t2 === "Date" || t2 === "Number")) {
            return 1;
        }
        if (t1 === "Date" && t2 === "Number") {
            return 1;
        }
        return -1;
    }
    if (t1 === "Binary") {
        first = new Uint8Array(first);
        second = new Uint8Array(second);
    }
    if (t1 === "Array" || t1 === "Binary") {
        var length_1 = Math.min(first.length, second.length);
        for (var i = 0; i < length_1; i++) {
            var result = cmp(first[i], second[i]);
            if (result !== 0) {
                return result;
            }
        }
        if (first.length > second.length) {
            return 1;
        }
        if (first.length < second.length) {
            return -1;
        }
        return 0;
    }
    if (t1 === "Date") {
        if (first.getTime() === second.getTime()) {
            return 0;
        }
    }
    else {
        if (first === second) {
            return 0;
        }
    }
    return first > second ? 1 : -1;
};
exports.default = cmp;

},{"./errors":488,"./valueToKey":493}],487:[function(require,module,exports){
"use strict";
// https://heycam.github.io/webidl/#EnforceRange
Object.defineProperty(exports, "__esModule", { value: true });
var enforceRange = function (num, type) {
    var min = 0;
    var max = type === "unsigned long" ? 4294967295 : 9007199254740991;
    if (isNaN(num) || num < min || num > max) {
        throw new TypeError();
    }
    if (num >= 0) {
        return Math.floor(num);
    }
};
exports.default = enforceRange;

},{}],488:[function(require,module,exports){
"use strict";
/* tslint:disable: max-classes-per-file max-line-length */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var messages = {
    AbortError: "A request was aborted, for example through a call to IDBTransaction.abort.",
    ConstraintError: "A mutation operation in the transaction failed because a constraint was not satisfied. For example, an object such as an object store or index already exists and a request attempted to create a new one.",
    DataCloneError: "The data being stored could not be cloned by the internal structured cloning algorithm.",
    DataError: "Data provided to an operation does not meet requirements.",
    InvalidAccessError: "An invalid operation was performed on an object. For example transaction creation attempt was made, but an empty scope was provided.",
    InvalidStateError: "An operation was called on an object on which it is not allowed or at a time when it is not allowed. Also occurs if a request is made on a source object that has been deleted or removed. Use TransactionInactiveError or ReadOnlyError when possible, as they are more specific variations of InvalidStateError.",
    NotFoundError: "The operation failed because the requested database object could not be found. For example, an object store did not exist but was being opened.",
    ReadOnlyError: 'The mutating operation was attempted in a "readonly" transaction.',
    TransactionInactiveError: "A request was placed against a transaction which is currently not active, or which is finished.",
    VersionError: "An attempt was made to open a database using a lower version than the existing version.",
};
var AbortError = /** @class */ (function (_super) {
    __extends(AbortError, _super);
    function AbortError(message) {
        if (message === void 0) { message = messages.AbortError; }
        var _this = _super.call(this) || this;
        _this.name = "AbortError";
        _this.message = message;
        return _this;
    }
    return AbortError;
}(Error));
exports.AbortError = AbortError;
var ConstraintError = /** @class */ (function (_super) {
    __extends(ConstraintError, _super);
    function ConstraintError(message) {
        if (message === void 0) { message = messages.ConstraintError; }
        var _this = _super.call(this) || this;
        _this.name = "ConstraintError";
        _this.message = message;
        return _this;
    }
    return ConstraintError;
}(Error));
exports.ConstraintError = ConstraintError;
var DataCloneError = /** @class */ (function (_super) {
    __extends(DataCloneError, _super);
    function DataCloneError(message) {
        if (message === void 0) { message = messages.DataCloneError; }
        var _this = _super.call(this) || this;
        _this.name = "DataCloneError";
        _this.message = message;
        return _this;
    }
    return DataCloneError;
}(Error));
exports.DataCloneError = DataCloneError;
var DataError = /** @class */ (function (_super) {
    __extends(DataError, _super);
    function DataError(message) {
        if (message === void 0) { message = messages.DataError; }
        var _this = _super.call(this) || this;
        _this.name = "DataError";
        _this.message = message;
        return _this;
    }
    return DataError;
}(Error));
exports.DataError = DataError;
var InvalidAccessError = /** @class */ (function (_super) {
    __extends(InvalidAccessError, _super);
    function InvalidAccessError(message) {
        if (message === void 0) { message = messages.InvalidAccessError; }
        var _this = _super.call(this) || this;
        _this.name = "InvalidAccessError";
        _this.message = message;
        return _this;
    }
    return InvalidAccessError;
}(Error));
exports.InvalidAccessError = InvalidAccessError;
var InvalidStateError = /** @class */ (function (_super) {
    __extends(InvalidStateError, _super);
    function InvalidStateError(message) {
        if (message === void 0) { message = messages.InvalidStateError; }
        var _this = _super.call(this) || this;
        _this.name = "InvalidStateError";
        _this.message = message;
        return _this;
    }
    return InvalidStateError;
}(Error));
exports.InvalidStateError = InvalidStateError;
var NotFoundError = /** @class */ (function (_super) {
    __extends(NotFoundError, _super);
    function NotFoundError(message) {
        if (message === void 0) { message = messages.NotFoundError; }
        var _this = _super.call(this) || this;
        _this.name = "NotFoundError";
        _this.message = message;
        return _this;
    }
    return NotFoundError;
}(Error));
exports.NotFoundError = NotFoundError;
var ReadOnlyError = /** @class */ (function (_super) {
    __extends(ReadOnlyError, _super);
    function ReadOnlyError(message) {
        if (message === void 0) { message = messages.ReadOnlyError; }
        var _this = _super.call(this) || this;
        _this.name = "ReadOnlyError";
        _this.message = message;
        return _this;
    }
    return ReadOnlyError;
}(Error));
exports.ReadOnlyError = ReadOnlyError;
var TransactionInactiveError = /** @class */ (function (_super) {
    __extends(TransactionInactiveError, _super);
    function TransactionInactiveError(message) {
        if (message === void 0) { message = messages.TransactionInactiveError; }
        var _this = _super.call(this) || this;
        _this.name = "TransactionInactiveError";
        _this.message = message;
        return _this;
    }
    return TransactionInactiveError;
}(Error));
exports.TransactionInactiveError = TransactionInactiveError;
var VersionError = /** @class */ (function (_super) {
    __extends(VersionError, _super);
    function VersionError(message) {
        if (message === void 0) { message = messages.VersionError; }
        var _this = _super.call(this) || this;
        _this.name = "VersionError";
        _this.message = message;
        return _this;
    }
    return VersionError;
}(Error));
exports.VersionError = VersionError;

},{}],489:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var valueToKey_1 = require("./valueToKey");
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-steps-for-extracting-a-key-from-a-value-using-a-key-path
var extractKey = function (keyPath, value) {
    var e_1, _a;
    if (Array.isArray(keyPath)) {
        var result = [];
        try {
            for (var keyPath_1 = __values(keyPath), keyPath_1_1 = keyPath_1.next(); !keyPath_1_1.done; keyPath_1_1 = keyPath_1.next()) {
                var item = keyPath_1_1.value;
                // This doesn't make sense to me based on the spec, but it is needed to pass the W3C KeyPath tests (see same
                // comment in validateKeyPath)
                if (item !== undefined &&
                    item !== null &&
                    typeof item !== "string" &&
                    item.toString) {
                    item = item.toString();
                }
                result.push(valueToKey_1.default(extractKey(item, value)));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keyPath_1_1 && !keyPath_1_1.done && (_a = keyPath_1.return)) _a.call(keyPath_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    }
    if (keyPath === "") {
        return value;
    }
    var remainingKeyPath = keyPath;
    var object = value;
    while (remainingKeyPath !== null) {
        var identifier = void 0;
        var i = remainingKeyPath.indexOf(".");
        if (i >= 0) {
            identifier = remainingKeyPath.slice(0, i);
            remainingKeyPath = remainingKeyPath.slice(i + 1);
        }
        else {
            identifier = remainingKeyPath;
            remainingKeyPath = null;
        }
        if (!object.hasOwnProperty(identifier)) {
            return;
        }
        object = object[identifier];
    }
    return object;
};
exports.default = extractKey;

},{"./valueToKey":493}],490:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Would be nicer to sublcass Array, but I'd have to sacrifice Node 4 support to do that.
var fakeDOMStringList = function (arr) {
    var arr2 = arr.slice();
    Object.defineProperty(arr2, "contains", {
        // tslint:disable-next-line object-literal-shorthand
        value: function (value) { return arr2.indexOf(value) >= 0; },
    });
    Object.defineProperty(arr2, "item", {
        // tslint:disable-next-line object-literal-shorthand
        value: function (i) { return arr2[i]; },
    });
    return arr2;
};
exports.default = fakeDOMStringList;

},{}],491:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var realisticStructuredClone = require("realistic-structured-clone"); // tslint:disable-line no-var-requires
var errors_1 = require("./errors");
var structuredClone = function (input) {
    try {
        return realisticStructuredClone(input);
    }
    catch (err) {
        throw new errors_1.DataCloneError();
    }
};
exports.default = structuredClone;

},{"./errors":488,"realistic-structured-clone":588}],492:[function(require,module,exports){
"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// http://www.w3.org/TR/2015/REC-IndexedDB-20150108/#dfn-valid-key-path
var validateKeyPath = function (keyPath, parent) {
    var e_1, _a, e_2, _b;
    // This doesn't make sense to me based on the spec, but it is needed to pass the W3C KeyPath tests (see same
    // comment in extractKey)
    if (keyPath !== undefined &&
        keyPath !== null &&
        typeof keyPath !== "string" &&
        keyPath.toString &&
        (parent === "array" || !Array.isArray(keyPath))) {
        keyPath = keyPath.toString();
    }
    if (typeof keyPath === "string") {
        if (keyPath === "" && parent !== "string") {
            return;
        }
        try {
            // https://mathiasbynens.be/demo/javascript-identifier-regex for ECMAScript 5.1 / Unicode v7.0.0, with
            // reserved words at beginning removed
            // tslint:disable-next-line max-line-length
            var validIdentifierRegex = /^(?:[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])(?:[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC])*$/;
            if (keyPath.length >= 1 && validIdentifierRegex.test(keyPath)) {
                return;
            }
        }
        catch (err) {
            throw new SyntaxError(err.message);
        }
        if (keyPath.indexOf(" ") >= 0) {
            throw new SyntaxError("The keypath argument contains an invalid key path (no spaces allowed).");
        }
    }
    if (Array.isArray(keyPath) && keyPath.length > 0) {
        if (parent) {
            // No nested arrays
            throw new SyntaxError("The keypath argument contains an invalid key path (nested arrays).");
        }
        try {
            for (var keyPath_1 = __values(keyPath), keyPath_1_1 = keyPath_1.next(); !keyPath_1_1.done; keyPath_1_1 = keyPath_1.next()) {
                var part = keyPath_1_1.value;
                validateKeyPath(part, "array");
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keyPath_1_1 && !keyPath_1_1.done && (_a = keyPath_1.return)) _a.call(keyPath_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return;
    }
    else if (typeof keyPath === "string" && keyPath.indexOf(".") >= 0) {
        keyPath = keyPath.split(".");
        try {
            for (var keyPath_2 = __values(keyPath), keyPath_2_1 = keyPath_2.next(); !keyPath_2_1.done; keyPath_2_1 = keyPath_2.next()) {
                var part = keyPath_2_1.value;
                validateKeyPath(part, "string");
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (keyPath_2_1 && !keyPath_2_1.done && (_b = keyPath_2.return)) _b.call(keyPath_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return;
    }
    throw new SyntaxError();
};
exports.default = validateKeyPath;

},{}],493:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
// https://w3c.github.io/IndexedDB/#convert-a-value-to-a-input
var valueToKey = function (input, seen) {
    if (typeof input === "number") {
        if (isNaN(input)) {
            throw new errors_1.DataError();
        }
        return input;
    }
    else if (input instanceof Date) {
        var ms = input.valueOf();
        if (isNaN(ms)) {
            throw new errors_1.DataError();
        }
        return new Date(ms);
    }
    else if (typeof input === "string") {
        return input;
    }
    else if (input instanceof ArrayBuffer ||
        (typeof ArrayBuffer !== "undefined" &&
            ArrayBuffer.isView &&
            ArrayBuffer.isView(input))) {
        if (input instanceof ArrayBuffer) {
            return new Uint8Array(input).buffer;
        }
        return new Uint8Array(input.buffer).buffer;
    }
    else if (Array.isArray(input)) {
        if (seen === undefined) {
            seen = new Set();
        }
        else if (seen.has(input)) {
            throw new errors_1.DataError();
        }
        seen.add(input);
        var keys = [];
        for (var i = 0; i < input.length; i++) {
            var hop = input.hasOwnProperty(i);
            if (!hop) {
                throw new errors_1.DataError();
            }
            var entry = input[i];
            var key = valueToKey(entry, seen);
            keys.push(key);
        }
        return keys;
    }
    else {
        throw new errors_1.DataError();
    }
};
exports.default = valueToKey;

},{"./errors":488}],494:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FDBKeyRange_1 = require("../FDBKeyRange");
var errors_1 = require("./errors");
var valueToKey_1 = require("./valueToKey");
// http://w3c.github.io/IndexedDB/#convert-a-value-to-a-key-range
var valueToKeyRange = function (value, nullDisallowedFlag) {
    if (nullDisallowedFlag === void 0) { nullDisallowedFlag = false; }
    if (value instanceof FDBKeyRange_1.default) {
        return value;
    }
    if (value === null || value === undefined) {
        if (nullDisallowedFlag) {
            throw new errors_1.DataError();
        }
        return new FDBKeyRange_1.default(undefined, undefined, false, false);
    }
    var key = valueToKey_1.default(value);
    return FDBKeyRange_1.default.only(key);
};
exports.default = valueToKeyRange;

},{"../FDBKeyRange":471,"./errors":488,"./valueToKey":493}],495:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":510,"safe-buffer":590,"stream":600}],496:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":497,"./hash/hmac":498,"./hash/ripemd":499,"./hash/sha":500,"./hash/utils":507}],497:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":507,"minimalistic-assert":550}],498:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":507,"minimalistic-assert":550}],499:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":497,"./utils":507}],500:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":501,"./sha/224":502,"./sha/256":503,"./sha/384":504,"./sha/512":505}],501:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":497,"../utils":507,"./common":506}],502:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":507,"./256":503}],503:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":497,"../utils":507,"./common":506,"minimalistic-assert":550}],504:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":507,"./512":505}],505:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":497,"../utils":507,"minimalistic-assert":550}],506:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":507}],507:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":510,"minimalistic-assert":550}],508:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":496,"minimalistic-assert":550,"minimalistic-crypto-utils":551}],509:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],510:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],511:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],512:[function(require,module,exports){
module.exports      = isTypedArray
isTypedArray.strict = isStrictTypedArray
isTypedArray.loose  = isLooseTypedArray

var toString = Object.prototype.toString
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
}

function isTypedArray(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

},{}],513:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],514:[function(require,module,exports){
var createError = require('errno').create
var LevelUPError = createError('LevelUPError')
var NotFoundError = createError('NotFoundError', LevelUPError)

NotFoundError.prototype.notFound = true
NotFoundError.prototype.status = 404

module.exports = {
  LevelUPError: LevelUPError,
  InitializationError: createError('InitializationError', LevelUPError),
  OpenError: createError('OpenError', LevelUPError),
  ReadError: createError('ReadError', LevelUPError),
  WriteError: createError('WriteError', LevelUPError),
  NotFoundError: NotFoundError,
  EncodingError: createError('EncodingError', LevelUPError)
}

},{"errno":462}],515:[function(require,module,exports){
var inherits = require('inherits')
var Readable = require('readable-stream').Readable
var extend = require('xtend')

module.exports = ReadStream
inherits(ReadStream, Readable)

function ReadStream (iterator, options) {
  if (!(this instanceof ReadStream)) return new ReadStream(iterator, options)
  options = options || {}
  Readable.call(this, extend(options, {
    objectMode: true
  }))
  this._iterator = iterator
  this._options = options
  this.on('end', this.destroy.bind(this, null, null))
}

ReadStream.prototype._read = function () {
  var self = this
  var options = this._options
  if (this.destroyed) return

  this._iterator.next(function (err, key, value) {
    if (self.destroyed) return
    if (err) return self.destroy(err)

    if (key === undefined && value === undefined) {
      self.push(null)
    } else if (options.keys !== false && options.values === false) {
      self.push(key)
    } else if (options.keys === false && options.values !== false) {
      self.push(value)
    } else {
      self.push({ key: key, value: value })
    }
  })
}

ReadStream.prototype._destroy = function (err, callback) {
  this._iterator.end(function (err2) {
    callback(err || err2)
  })
}

},{"inherits":510,"readable-stream":530,"xtend":609}],516:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],517:[function(require,module,exports){
(function (process){
'use strict'

var experimentalWarnings = new Set();

function emitExperimentalWarning(feature) {
  if (experimentalWarnings.has(feature)) return;
  var msg = feature + ' is an experimental feature. This feature could ' +
       'change at any time';
  experimentalWarnings.add(feature);
  process.emitWarning(msg, 'ExperimentalWarning');
}

function noop() {}

module.exports.emitExperimentalWarning = process.emitWarning
  ? emitExperimentalWarning
  : noop;

}).call(this,require('_process'))
},{"_process":565}],518:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this,require('_process'))
},{"./_stream_readable":520,"./_stream_writable":522,"_process":565,"inherits":510}],519:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":521,"inherits":510}],520:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

var _require2 = require('../experimentalWarning'),
    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;

require('inherits')(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    emitExperimentalWarning('Readable[Symbol.asyncIterator]');

    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":516,"../experimentalWarning":517,"./_stream_duplex":518,"./internal/streams/async_iterator":523,"./internal/streams/buffer_list":524,"./internal/streams/destroy":525,"./internal/streams/state":528,"./internal/streams/stream":529,"_process":565,"buffer":98,"events":463,"inherits":510,"string_decoder/":601,"util":68}],521:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":516,"./_stream_duplex":518,"inherits":510}],522:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    stream.emit('error', er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":516,"./_stream_duplex":518,"./internal/streams/destroy":525,"./internal/streams/state":528,"./internal/streams/stream":529,"_process":565,"buffer":98,"inherits":510,"util-deprecate":604}],523:[function(require,module,exports){
(function (process){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this,require('_process'))
},{"./end-of-stream":526,"_process":565}],524:[function(require,module,exports){
'use strict';

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  var _proto = BufferList.prototype;

  _proto.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  _proto.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  _proto.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  _proto.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  _proto.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  _proto.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  } // Consumes a specified amount of bytes or characters from the buffered data.
  ;

  _proto.consume = function consume(n, hasStrings) {
    var ret;

    if (n < this.head.data.length) {
      // `slice` is the same for buffers and strings.
      ret = this.head.data.slice(0, n);
      this.head.data = this.head.data.slice(n);
    } else if (n === this.head.data.length) {
      // First chunk is a perfect match.
      ret = this.shift();
    } else {
      // Result spans more than one buffer.
      ret = hasStrings ? this._getString(n) : this._getBuffer(n);
    }

    return ret;
  };

  _proto.first = function first() {
    return this.head.data;
  } // Consumes a specified amount of characters from the buffered data.
  ;

  _proto._getString = function _getString(n) {
    var p = this.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;

    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;

      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = str.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Consumes a specified amount of bytes from the buffered data.
  ;

  _proto._getBuffer = function _getBuffer(n) {
    var ret = Buffer.allocUnsafe(n);
    var p = this.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;

    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;

      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) this.head = p.next;else this.head = this.tail = null;
        } else {
          this.head = p;
          p.data = buf.slice(nb);
        }

        break;
      }

      ++c;
    }

    this.length -= c;
    return ret;
  } // Make sure the linked list only shows the minimal necessary information.
  ;

  _proto[custom] = function (_, options) {
    return inspect(this, _objectSpread({}, options, {
      // Only inspect one level.
      depth: 0,
      // It should not recurse.
      customInspect: false
    }));
  };

  return BufferList;
}();
},{"buffer":98,"util":68}],525:[function(require,module,exports){
(function (process){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      process.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      process.nextTick(emitErrorAndCloseNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
}).call(this,require('_process'))
},{"_process":565}],526:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":516}],527:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":516,"./end-of-stream":526}],528:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":516}],529:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":463}],530:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":518,"./lib/_stream_passthrough.js":519,"./lib/_stream_readable.js":520,"./lib/_stream_transform.js":521,"./lib/_stream_writable.js":522,"./lib/internal/streams/end-of-stream.js":526,"./lib/internal/streams/pipeline.js":527}],531:[function(require,module,exports){
(function (Buffer){
/* global indexedDB */

'use strict'

module.exports = Level

var AbstractLevelDOWN = require('abstract-leveldown').AbstractLevelDOWN
var inherits = require('inherits')
var Iterator = require('./iterator')
var mixedToBuffer = require('./util/mixed-to-buffer')
var setImmediate = require('./util/immediate')
var support = require('./util/support')

var DEFAULT_PREFIX = 'level-js-'

function Level (location, opts) {
  if (!(this instanceof Level)) return new Level(location, opts)
  AbstractLevelDOWN.call(this)
  opts = opts || {}

  if (typeof location !== 'string') {
    throw new Error('constructor requires a location string argument')
  }

  this.location = location
  this.prefix = opts.prefix || DEFAULT_PREFIX
  this.version = parseInt(opts.version || 1, 10)
}

inherits(Level, AbstractLevelDOWN)

// Detect binary and array key support (IndexedDB Second Edition)
Level.binaryKeys = support.binaryKeys(indexedDB)
Level.arrayKeys = support.arrayKeys(indexedDB)

Level.prototype._open = function (options, callback) {
  var req = indexedDB.open(this.prefix + this.location, this.version)
  var self = this

  req.onerror = function () {
    callback(req.error || new Error('unknown error'))
  }

  req.onsuccess = function () {
    self.db = req.result
    callback()
  }

  req.onupgradeneeded = function (ev) {
    var db = ev.target.result

    if (!db.objectStoreNames.contains(self.location)) {
      db.createObjectStore(self.location)
    }
  }
}

Level.prototype.store = function (mode) {
  var transaction = this.db.transaction([this.location], mode)
  return transaction.objectStore(this.location)
}

Level.prototype.await = function (request, callback) {
  var transaction = request.transaction

  // Take advantage of the fact that a non-canceled request error aborts
  // the transaction. I.e. no need to listen for "request.onerror".
  transaction.onabort = function () {
    callback(transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    callback(null, request.result)
  }
}

Level.prototype._get = function (key, options, callback) {
  var store = this.store('readonly')

  try {
    var req = store.get(key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, function (err, value) {
    if (err) return callback(err)

    if (value === undefined) {
      // 'NotFound' error, consistent with LevelDOWN API
      return callback(new Error('NotFound'))
    }

    if (options.asBuffer) {
      value = mixedToBuffer(value)
    }

    callback(null, value)
  })
}

Level.prototype._del = function (key, options, callback) {
  var store = this.store('readwrite')

  try {
    var req = store.delete(key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, callback)
}

Level.prototype._put = function (key, value, options, callback) {
  var store = this.store('readwrite')

  try {
    // Will throw a DataError or DataCloneError if the environment
    // does not support serializing the key or value respectively.
    var req = store.put(value, key)
  } catch (err) {
    return setImmediate(function () {
      callback(err)
    })
  }

  this.await(req, callback)
}

// Valid key types in IndexedDB Second Edition:
//
// - Number, except NaN. Includes Infinity and -Infinity
// - Date, except invalid (NaN)
// - String
// - ArrayBuffer or a view thereof (typed arrays). In level-js we also support
//   Buffer (which is an Uint8Array) (and the primary binary type of Level).
// - Array, except cyclical and empty (e.g. Array(10)). Elements must be valid
//   types themselves.
Level.prototype._serializeKey = function (key) {
  if (Buffer.isBuffer(key)) {
    return Level.binaryKeys ? key : key.toString()
  } else if (Array.isArray(key)) {
    return Level.arrayKeys ? key.map(this._serializeKey, this) : String(key)
  } else {
    return key
  }
}

Level.prototype._serializeValue = function (value) {
  return value
}

Level.prototype._iterator = function (options) {
  return new Iterator(this, this.location, options)
}

Level.prototype._batch = function (operations, options, callback) {
  if (operations.length === 0) return setImmediate(callback)

  var store = this.store('readwrite')
  var transaction = store.transaction
  var index = 0
  var error

  transaction.onabort = function () {
    callback(error || transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    callback()
  }

  // Wait for a request to complete before making the next, saving CPU.
  function loop () {
    var op = operations[index++]
    var key = op.key

    try {
      var req = op.type === 'del' ? store.delete(key) : store.put(op.value, key)
    } catch (err) {
      error = err
      transaction.abort()
      return
    }

    if (index < operations.length) {
      req.onsuccess = loop
    }
  }

  loop()
}

Level.prototype._close = function (callback) {
  this.db.close()
  setImmediate(callback)
}

Level.destroy = function (location, prefix, callback) {
  if (typeof prefix === 'function') {
    callback = prefix
    prefix = DEFAULT_PREFIX
  }
  var request = indexedDB.deleteDatabase(prefix + location)
  request.onsuccess = function () {
    callback()
  }
  request.onerror = function (err) {
    callback(err)
  }
}

}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":511,"./iterator":532,"./util/immediate":539,"./util/mixed-to-buffer":540,"./util/support":541,"abstract-leveldown":44,"inherits":510}],532:[function(require,module,exports){
/* global IDBKeyRange */

'use strict'

var inherits = require('inherits')
var AbstractIterator = require('abstract-leveldown').AbstractIterator
var ltgt = require('ltgt')
var mixedToBuffer = require('./util/mixed-to-buffer')
var setImmediate = require('./util/immediate')
var noop = function () {}

module.exports = Iterator

function Iterator (db, location, options) {
  AbstractIterator.call(this, db)

  this._limit = options.limit
  this._count = 0
  this._callback = null
  this._cache = []
  this._completed = false
  this._aborted = false
  this._error = null
  this._transaction = null

  this._keyAsBuffer = options.keyAsBuffer
  this._valueAsBuffer = options.valueAsBuffer

  if (this._limit === 0) {
    this._completed = true
    return
  }

  try {
    var keyRange = this.createKeyRange(options)
  } catch (e) {
    // The lower key is greater than the upper key.
    // IndexedDB throws an error, but we'll just return 0 results.
    this._completed = true
    return
  }

  this.createIterator(location, keyRange, options.reverse)
}

inherits(Iterator, AbstractIterator)

Iterator.prototype.createKeyRange = function (options) {
  var lower = ltgt.lowerBound(options)
  var upper = ltgt.upperBound(options)
  var lowerOpen = ltgt.lowerBoundExclusive(options)
  var upperOpen = ltgt.upperBoundExclusive(options)

  if (lower !== undefined && upper !== undefined) {
    return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)
  } else if (lower !== undefined) {
    return IDBKeyRange.lowerBound(lower, lowerOpen)
  } else if (upper !== undefined) {
    return IDBKeyRange.upperBound(upper, upperOpen)
  } else {
    return null
  }
}

Iterator.prototype.createIterator = function (location, keyRange, reverse) {
  var self = this
  var transaction = this.db.db.transaction([location], 'readonly')
  var store = transaction.objectStore(location)
  var req = store.openCursor(keyRange, reverse ? 'prev' : 'next')

  req.onsuccess = function (ev) {
    var cursor = ev.target.result
    if (cursor) self.onItem(cursor)
  }

  this._transaction = transaction

  // If an error occurs (on the request), the transaction will abort.
  transaction.onabort = function () {
    self.onAbort(self._transaction.error || new Error('aborted by user'))
  }

  transaction.oncomplete = function () {
    self.onComplete()
  }
}

Iterator.prototype.onItem = function (cursor) {
  this._cache.push(cursor.key, cursor.value)

  if (this._limit <= 0 || ++this._count < this._limit) {
    cursor['continue']()
  }

  this.maybeNext()
}

Iterator.prototype.onAbort = function (err) {
  this._aborted = true
  this._error = err
  this.maybeNext()
}

Iterator.prototype.onComplete = function () {
  this._completed = true
  this.maybeNext()
}

Iterator.prototype.maybeNext = function () {
  if (this._callback) {
    this._next(this._callback)
    this._callback = null
  }
}

Iterator.prototype._next = function (callback) {
  if (this._aborted) {
    // The error should be picked up by either next() or end().
    var err = this._error
    this._error = null

    setImmediate(function () {
      callback(err)
    })
  } else if (this._cache.length > 0) {
    var key = this._cache.shift()
    var value = this._cache.shift()

    if (this._keyAsBuffer) key = mixedToBuffer(key)
    if (this._valueAsBuffer) value = mixedToBuffer(value)

    setImmediate(function () {
      callback(null, key, value)
    })
  } else if (this._completed) {
    setImmediate(callback)
  } else {
    this._callback = callback
  }
}

Iterator.prototype._end = function (callback) {
  if (this._aborted || this._completed) {
    var err = this._error

    setImmediate(function () {
      callback(err)
    })

    return
  }

  // Don't advance the cursor anymore, and the transaction will complete
  // on its own in the next tick. This approach is much cleaner than calling
  // transaction.abort() with its unpredictable event order.
  this.onItem = noop
  this.onAbort = callback
  this.onComplete = callback
}

},{"./util/immediate":539,"./util/mixed-to-buffer":540,"abstract-leveldown":44,"inherits":510,"ltgt":546}],533:[function(require,module,exports){
'use strict';
var types = [
  require('./nextTick'),
  require('./mutation.js'),
  require('./messageChannel'),
  require('./stateChange'),
  require('./timeout')
];
var draining;
var currentQueue;
var queueIndex = -1;
var queue = [];
var scheduled = false;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    nextTick();
  }
}

//named nextTick for less confusing stack traces
function nextTick() {
  if (draining) {
    return;
  }
  scheduled = false;
  draining = true;
  var len = queue.length;
  var timeout = setTimeout(cleanUpNextTick);
  while (len) {
    currentQueue = queue;
    queue = [];
    while (currentQueue && ++queueIndex < len) {
      currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  queueIndex = -1;
  draining = false;
  clearTimeout(timeout);
}
var scheduleDrain;
var i = -1;
var len = types.length;
while (++i < len) {
  if (types[i] && types[i].test && types[i].test()) {
    scheduleDrain = types[i].install(nextTick);
    break;
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  var fun = this.fun;
  var array = this.array;
  switch (array.length) {
  case 0:
    return fun();
  case 1:
    return fun(array[0]);
  case 2:
    return fun(array[0], array[1]);
  case 3:
    return fun(array[0], array[1], array[2]);
  default:
    return fun.apply(null, array);
  }

};
module.exports = immediate;
function immediate(task) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(task, args));
  if (!scheduled && !draining) {
    scheduled = true;
    scheduleDrain();
  }
}

},{"./messageChannel":534,"./mutation.js":535,"./nextTick":536,"./stateChange":537,"./timeout":538}],534:[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  if (global.setImmediate) {
    // we can only get here in IE10
    // which doesn't handel postMessage well
    return false;
  }
  return typeof global.MessageChannel !== 'undefined';
};

exports.install = function (func) {
  var channel = new global.MessageChannel();
  channel.port1.onmessage = func;
  return function () {
    channel.port2.postMessage(0);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],535:[function(require,module,exports){
(function (global){
'use strict';
//based off rsvp https://github.com/tildeio/rsvp.js
//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE
//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js

var Mutation = global.MutationObserver || global.WebKitMutationObserver;

exports.test = function () {
  return Mutation;
};

exports.install = function (handle) {
  var called = 0;
  var observer = new Mutation(handle);
  var element = global.document.createTextNode('');
  observer.observe(element, {
    characterData: true
  });
  return function () {
    element.data = (called = ++called % 2);
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],536:[function(require,module,exports){
(function (process){
'use strict';
exports.test = function () {
  // Don't get fooled by e.g. browserify environments.
  return (typeof process !== 'undefined') && !process.browser;
};

exports.install = function (func) {
  return function () {
    process.nextTick(func);
  };
};

}).call(this,require('_process'))
},{"_process":565}],537:[function(require,module,exports){
(function (global){
'use strict';

exports.test = function () {
  return 'document' in global && 'onreadystatechange' in global.document.createElement('script');
};

exports.install = function (handle) {
  return function () {

    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
    var scriptEl = global.document.createElement('script');
    scriptEl.onreadystatechange = function () {
      handle();

      scriptEl.onreadystatechange = null;
      scriptEl.parentNode.removeChild(scriptEl);
      scriptEl = null;
    };
    global.document.documentElement.appendChild(scriptEl);

    return handle;
  };
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],538:[function(require,module,exports){
'use strict';
exports.test = function () {
  return true;
};

exports.install = function (t) {
  return function () {
    setTimeout(t, 0);
  };
};
},{}],539:[function(require,module,exports){
module.exports = require('immediate')

},{"immediate":533}],540:[function(require,module,exports){
(function (Buffer){
'use strict'

var toBuffer = require('typedarray-to-buffer')

module.exports = function (value) {
  if (value instanceof Uint8Array) return toBuffer(value)
  else if (value instanceof ArrayBuffer) return Buffer.from(value)
  else return Buffer.from(String(value))
}

}).call(this,require("buffer").Buffer)
},{"buffer":98,"typedarray-to-buffer":603}],541:[function(require,module,exports){
'use strict'

exports.test = function (key) {
  return function test (impl) {
    try {
      impl.cmp(key, 0)
      return true
    } catch (err) {
      return false
    }
  }
}

exports.binaryKeys = exports.test(new Uint8Array(0))
exports.arrayKeys = exports.test([1])

},{}],542:[function(require,module,exports){
var WriteError = require('level-errors').WriteError
var promisify = require('./promisify')
var getCallback = require('./common').getCallback
var getOptions = require('./common').getOptions

function Batch (levelup) {
  this._levelup = levelup
  this.batch = levelup.db.batch()
  this.ops = []
  this.length = 0
}

Batch.prototype.put = function (key, value) {
  try {
    this.batch.put(key, value)
  } catch (e) {
    throw new WriteError(e)
  }

  this.ops.push({ type: 'put', key: key, value: value })
  this.length++

  return this
}

Batch.prototype.del = function (key) {
  try {
    this.batch.del(key)
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops.push({ type: 'del', key: key })
  this.length++

  return this
}

Batch.prototype.clear = function () {
  try {
    this.batch.clear()
  } catch (err) {
    throw new WriteError(err)
  }

  this.ops = []
  this.length = 0

  return this
}

Batch.prototype.write = function (options, callback) {
  var levelup = this._levelup
  var ops = this.ops
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  options = getOptions(options)

  try {
    this.batch.write(options, function (err) {
      if (err) { return callback(new WriteError(err)) }
      levelup.emit('batch', ops)
      callback()
    })
  } catch (err) {
    throw new WriteError(err)
  }

  return promise
}

module.exports = Batch

},{"./common":543,"./promisify":545,"level-errors":514}],543:[function(require,module,exports){
exports.getCallback = function (options, callback) {
  return typeof options === 'function' ? options : callback
}

exports.getOptions = function (options) {
  return typeof options === 'object' && options !== null ? options : {}
}

},{}],544:[function(require,module,exports){
(function (process){
var EventEmitter = require('events').EventEmitter
var inherits = require('util').inherits
var extend = require('xtend')
var DeferredLevelDOWN = require('deferred-leveldown')
var IteratorStream = require('level-iterator-stream')
var Batch = require('./batch')
var errors = require('level-errors')
var assert = require('assert')
var promisify = require('./promisify')
var getCallback = require('./common').getCallback
var getOptions = require('./common').getOptions

var WriteError = errors.WriteError
var ReadError = errors.ReadError
var NotFoundError = errors.NotFoundError
var OpenError = errors.OpenError
var InitializationError = errors.InitializationError

// Possible AbstractLevelDOWN#status values:
//  - 'new'     - newly created, not opened or closed
//  - 'opening' - waiting for the database to be opened, post open()
//  - 'open'    - successfully opened the database, available for use
//  - 'closing' - waiting for the database to be closed, post close()
//  - 'closed'  - database has been successfully closed, should not be
//                 used except for another open() operation

function LevelUP (db, options, callback) {
  if (!(this instanceof LevelUP)) {
    return new LevelUP(db, options, callback)
  }

  var error

  EventEmitter.call(this)
  this.setMaxListeners(Infinity)

  if (typeof options === 'function') {
    callback = options
    options = {}
  }

  options = options || {}

  if (!db || typeof db !== 'object') {
    error = new InitializationError('First argument must be an abstract-leveldown compliant store')
    if (typeof callback === 'function') {
      return process.nextTick(callback, error)
    }
    throw error
  }

  assert.strictEqual(typeof db.status, 'string', '.status required, old abstract-leveldown')

  this.options = getOptions(options)
  this._db = db
  this.db = new DeferredLevelDOWN(db)
  this.open(callback)
}

LevelUP.prototype.emit = EventEmitter.prototype.emit
LevelUP.prototype.once = EventEmitter.prototype.once
inherits(LevelUP, EventEmitter)

LevelUP.prototype.open = function (opts, callback) {
  var self = this
  var promise

  if (typeof opts === 'function') {
    callback = opts
    opts = null
  }

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (!opts) {
    opts = this.options
  }

  if (this.isOpen()) {
    process.nextTick(callback, null, self)
    return promise
  }

  if (this._isOpening()) {
    this.once('open', function () { callback(null, self) })
    return promise
  }

  this.emit('opening')

  this.db.open(opts, function (err) {
    if (err) {
      return callback(new OpenError(err))
    }
    self.db = self._db
    callback(null, self)
    self.emit('open')
    self.emit('ready')
  })

  return promise
}

LevelUP.prototype.close = function (callback) {
  var self = this
  var promise

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (this.isOpen()) {
    this.db.close(function () {
      self.emit('closed')
      callback.apply(null, arguments)
    })
    this.emit('closing')
    this.db = new DeferredLevelDOWN(this._db)
  } else if (this.isClosed()) {
    process.nextTick(callback)
  } else if (this.db.status === 'closing') {
    this.once('closed', callback)
  } else if (this._isOpening()) {
    this.once('open', function () {
      self.close(callback)
    })
  }

  return promise
}

LevelUP.prototype.isOpen = function () {
  return this.db.status === 'open'
}

LevelUP.prototype._isOpening = function () {
  return this.db.status === 'opening'
}

LevelUP.prototype.isClosed = function () {
  return (/^clos|new/).test(this.db.status)
}

LevelUP.prototype.get = function (key, options, callback) {
  if (key === null || key === undefined) {
    throw new ReadError('get() requires a key argument')
  }

  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.get(key, options, function (err, value) {
    if (err) {
      if ((/notfound/i).test(err) || err.notFound) {
        err = new NotFoundError('Key not found in database [' + key + ']', err)
      } else {
        err = new ReadError(err)
      }
      return callback(err)
    }
    callback(null, value)
  })

  return promise
}

LevelUP.prototype.put = function (key, value, options, callback) {
  if (key === null || key === undefined) {
    throw new WriteError('put() requires a key argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.put(key, value, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('put', key, value)
    callback()
  })

  return promise
}

LevelUP.prototype.del = function (key, options, callback) {
  if (key === null || key === undefined) {
    throw new WriteError('del() requires a key argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.del(key, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('del', key)
    callback()
  })

  return promise
}

LevelUP.prototype.batch = function (arr, options, callback) {
  if (!arguments.length) {
    return new Batch(this)
  }

  if (!Array.isArray(arr)) {
    throw new WriteError('batch() requires an array argument')
  }

  var self = this
  var promise

  callback = getCallback(options, callback)

  if (!callback) {
    callback = promisify()
    promise = callback.promise
  }

  if (maybeError(this, callback)) { return promise }

  options = getOptions(options)

  this.db.batch(arr, options, function (err) {
    if (err) {
      return callback(new WriteError(err))
    }
    self.emit('batch', arr)
    callback()
  })

  return promise
}

LevelUP.prototype.iterator = function (options) {
  return this.db.iterator(options)
}

LevelUP.prototype.readStream =
LevelUP.prototype.createReadStream = function (options) {
  options = extend({ keys: true, values: true }, options)
  if (typeof options.limit !== 'number') { options.limit = -1 }
  return new IteratorStream(this.db.iterator(options), options)
}

LevelUP.prototype.keyStream =
LevelUP.prototype.createKeyStream = function (options) {
  return this.createReadStream(extend(options, { keys: true, values: false }))
}

LevelUP.prototype.valueStream =
LevelUP.prototype.createValueStream = function (options) {
  return this.createReadStream(extend(options, { keys: false, values: true }))
}

LevelUP.prototype.toString = function () {
  return 'LevelUP'
}

function maybeError (db, callback) {
  if (!db._isOpening() && !db.isOpen()) {
    process.nextTick(callback, new ReadError('Database is not open'))
    return true
  }
}

LevelUP.errors = errors
module.exports = LevelUP.default = LevelUP

}).call(this,require('_process'))
},{"./batch":542,"./common":543,"./promisify":545,"_process":565,"assert":60,"deferred-leveldown":434,"events":463,"level-errors":514,"level-iterator-stream":515,"util":607,"xtend":609}],545:[function(require,module,exports){
function promisify () {
  var callback
  var promise = new Promise(function (resolve, reject) {
    callback = function callback (err, value) {
      if (err) reject(err)
      else resolve(value)
    }
  })
  callback.promise = promise
  return callback
}

module.exports = promisify

},{}],546:[function(require,module,exports){
(function (Buffer){

exports.compare = function (a, b) {

  if(Buffer.isBuffer(a)) {
    var l = Math.min(a.length, b.length)
    for(var i = 0; i < l; i++) {
      var cmp = a[i] - b[i]
      if(cmp) return cmp
    }
    return a.length - b.length
  }

  return a < b ? -1 : a > b ? 1 : 0
}

// to be compatible with the current abstract-leveldown tests
// nullish or empty strings.
// I could use !!val but I want to permit numbers and booleans,
// if possible.

function isDef (val) {
  return val !== undefined && val !== ''
}

function has (range, name) {
  return Object.hasOwnProperty.call(range, name)
}

function hasKey(range, name) {
  return Object.hasOwnProperty.call(range, name) && name
}

var lowerBoundKey = exports.lowerBoundKey = function (range) {
    return (
       hasKey(range, 'gt')
    || hasKey(range, 'gte')
    || hasKey(range, 'min')
    || (range.reverse ? hasKey(range, 'end') : hasKey(range, 'start'))
    || undefined
    )
}

var lowerBound = exports.lowerBound = function (range, def) {
  var k = lowerBoundKey(range)
  return k ? range[k] : def
}

var lowerBoundInclusive = exports.lowerBoundInclusive = function (range) {
  return has(range, 'gt') ? false : true
}

var upperBoundInclusive = exports.upperBoundInclusive =
  function (range) {
    return (has(range, 'lt') /*&& !range.maxEx*/) ? false : true
  }

var lowerBoundExclusive = exports.lowerBoundExclusive =
  function (range) {
    return !lowerBoundInclusive(range)
  }

var upperBoundExclusive = exports.upperBoundExclusive =
  function (range) {
    return !upperBoundInclusive(range)
  }

var upperBoundKey = exports.upperBoundKey = function (range) {
    return (
       hasKey(range, 'lt')
    || hasKey(range, 'lte')
    || hasKey(range, 'max')
    || (range.reverse ? hasKey(range, 'start') : hasKey(range, 'end'))
    || undefined
    )
}

var upperBound = exports.upperBound = function (range, def) {
  var k = upperBoundKey(range)
  return k ? range[k] : def
}

exports.start = function (range, def) {
  return range.reverse ? upperBound(range, def) : lowerBound(range, def)
}
exports.end = function (range, def) {
  return range.reverse ? lowerBound(range, def) : upperBound(range, def)
}
exports.startInclusive = function (range) {
  return (
    range.reverse
  ? upperBoundInclusive(range)
  : lowerBoundInclusive(range)
  )
}
exports.endInclusive = function (range) {
  return (
    range.reverse
  ? lowerBoundInclusive(range)
  : upperBoundInclusive(range)
  )
}

function id (e) { return e }

exports.toLtgt = function (range, _range, map, lower, upper) {
  _range = _range || {}
  map = map || id
  var defaults = arguments.length > 3
  var lb = exports.lowerBoundKey(range)
  var ub = exports.upperBoundKey(range)
  if(lb) {
    if(lb === 'gt') _range.gt = map(range.gt, false)
    else            _range.gte = map(range[lb], false)
  }
  else if(defaults)
    _range.gte = map(lower, false)

  if(ub) {
    if(ub === 'lt') _range.lt = map(range.lt, true)
    else            _range.lte = map(range[ub], true)
  }
  else if(defaults)
    _range.lte = map(upper, true)

  if(range.reverse != null)
    _range.reverse = !!range.reverse

  //if range was used mutably
  //(in level-sublevel it's part of an options object
  //that has more properties on it.)
  if(has(_range, 'max'))   delete _range.max
  if(has(_range, 'min'))   delete _range.min
  if(has(_range, 'start')) delete _range.start
  if(has(_range, 'end'))   delete _range.end

  return _range
}

exports.contains = function (range, key, compare) {
  compare = compare || exports.compare

  var lb = lowerBound(range)
  if(isDef(lb)) {
    var cmp = compare(key, lb)
    if(cmp < 0 || (cmp === 0 && lowerBoundExclusive(range)))
      return false
  }

  var ub = upperBound(range)
  if(isDef(ub)) {
    var cmp = compare(key, ub)
    if(cmp > 0 || (cmp === 0) && upperBoundExclusive(range))
      return false
  }

  return true
}

exports.filter = function (range, compare) {
  return function (key) {
    return exports.contains(range, key, compare)
  }
}



}).call(this,{"isBuffer":require("../is-buffer/index.js")})
},{"../is-buffer/index.js":511}],547:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":495,"inherits":510,"safe-buffer":590}],548:[function(require,module,exports){
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function concat(array1, array2) {
        const length = array1.length;
        const result = new Uint8Array(length * 2);
        result.set(array1);
        result.set(array2, length);
        return result;
    }
    function areArraysEqual(array1, array2) {
        if (array1 === array2) {
            return true;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        const length = array1.length;
        for (let index = 0; index < length; ++index) {
            if (array1[index] !== array2[index]) {
                return false;
            }
        }
        return true;
    }
    class Tree {
        constructor(items, hashFunction) {
            this.tree = [];
            this.items = items;
            this.buildTree(items, hashFunction);
        }
        static checkProof(root, proof, targetItem, hashFunction) {
            if (areArraysEqual(root, targetItem) && proof.length === 0) {
                return true;
            }
            const itemLength = targetItem.length;
            if (proof.length % (itemLength + 1)) {
                return false;
            }
            const proofStep = itemLength + 1;
            const length = proof.length;
            for (let i = 0; i < length; i += proofStep) {
                const item = proof.subarray(i + 1, i + proofStep);
                targetItem = hashFunction(proof[i] ? concat(item, targetItem) : concat(targetItem, item));
            }
            return areArraysEqual(root, targetItem);
        }
        getProof(targetItem) {
            const items = this.items;
            const length = items.length;
            for (let i = 0; i < length; ++i) {
                if (areArraysEqual(items[i], targetItem)) {
                    return this.getProofFor(i);
                }
            }
            throw new Error('Item not found');
        }
        getRoot() {
            return this.tree[this.tree.length - 1][0];
        }
        buildTree(items, hashFunction) {
            this.tree.push(items);
            if (items.length === 1) {
                return;
            }
            const newItems = [];
            const length = items.length;
            for (let index = 0; index < length; index += 2) {
                const item1 = items[index];
                const item2 = items[index + 1] || item1;
                newItems.push(hashFunction(concat(item1, item2)));
            }
            this.buildTree(newItems, hashFunction);
        }
        getProofFor(itemIndex) {
            const proof = [];
            const tree = this.tree;
            const levels = tree.length - 1;
            let currentLevel = 0;
            let right = itemIndex % 2;
            let nextStepOffset = (itemIndex - right) / 2;
            let index = nextStepOffset;
            // Last level is the root itself, hence we exclude it
            while (currentLevel < levels) {
                const treeLevel = tree[currentLevel];
                // if current element is to the right - take left element, otherwise try to take right one and fallback to left if not present (unbalanced tree)
                const otherItem = right
                    ? treeLevel[index]
                    : (treeLevel[index + 1] || treeLevel[index]);
                proof.push(right, ...otherItem);
                right = index % 2;
                nextStepOffset = (index - right) / 2;
                index = nextStepOffset;
                ++currentLevel;
            }
            return Uint8Array.from(proof);
        }
    }
    exports.Tree = Tree;
});

},{}],549:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":66,"brorand":67}],550:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],551:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],552:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],553:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],554:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
'use strict'

var asn1 = require('asn1.js')

exports.certificate = require('./certificate')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

},{"./certificate":555,"asn1.js":46}],555:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict'

var asn = require('asn1.js')

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate

},{"asn1.js":46}],556:[function(require,module,exports){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
var Buffer = require('safe-buffer').Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = new Buffer(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

},{"browserify-aes":71,"evp_bytestokey":464,"safe-buffer":590}],557:[function(require,module,exports){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
var Buffer = require('safe-buffer').Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

},{"./aesid.json":553,"./asn1":554,"./fixProc":556,"browserify-aes":71,"pbkdf2":559,"safe-buffer":590}],558:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":565}],559:[function(require,module,exports){
exports.pbkdf2 = require('./lib/async')
exports.pbkdf2Sync = require('./lib/sync')

},{"./lib/async":560,"./lib/sync":563}],560:[function(require,module,exports){
(function (process,global){
var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var sync = require('./sync')
var Buffer = require('safe-buffer').Buffer

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  'sha': 'SHA-1',
  'sha-1': 'SHA-1',
  'sha1': 'SHA-1',
  'sha256': 'SHA-256',
  'sha-256': 'SHA-256',
  'sha384': 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  'sha512': 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}

function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, {name: 'PBKDF2'}, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    process.nextTick(function () {
      callback(null, out)
    })
  }, function (e) {
    process.nextTick(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    return process.nextTick(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
  }

  checkParameters(password, salt, iterations, keylen)
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":561,"./precondition":562,"./sync":563,"_process":565,"safe-buffer":590}],561:[function(require,module,exports){
(function (process){
var defaultEncoding
/* istanbul ignore next */
if (process.browser) {
  defaultEncoding = 'utf-8'
} else {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
}
module.exports = defaultEncoding

}).call(this,require('_process'))
},{"_process":565}],562:[function(require,module,exports){
(function (Buffer){
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

function checkBuffer (buf, name) {
  if (typeof buf !== 'string' && !Buffer.isBuffer(buf)) {
    throw new TypeError(name + ' must be a buffer or string')
  }
}

module.exports = function (password, salt, iterations, keylen) {
  checkBuffer(password, 'Password')
  checkBuffer(salt, 'Salt')

  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":511}],563:[function(require,module,exports){
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var Buffer = require('safe-buffer').Buffer
var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(password, salt, iterations, keylen)

  if (!Buffer.isBuffer(password)) password = Buffer.from(password, defaultEncoding)
  if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, defaultEncoding)

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2

},{"./default-encoding":561,"./precondition":562,"create-hash/md5":429,"ripemd160":589,"safe-buffer":590,"sha.js":593}],564:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))
},{"_process":565}],565:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],566:[function(require,module,exports){
/*!
  * prr
  * (c) 2013 Rod Vagg <rod@vagg.org>
  * https://github.com/rvagg/prr
  * License: MIT
  */

(function (name, context, definition) {
  if (typeof module != 'undefined' && module.exports)
    module.exports = definition()
  else
    context[name] = definition()
})('prr', this, function() {

  var setProperty = typeof Object.defineProperty == 'function'
      ? function (obj, key, options) {
          Object.defineProperty(obj, key, options)
          return obj
        }
      : function (obj, key, options) { // < es5
          obj[key] = options.value
          return obj
        }

    , makeOptions = function (value, options) {
        var oo = typeof options == 'object'
          , os = !oo && typeof options == 'string'
          , op = function (p) {
              return oo
                ? !!options[p]
                : os
                  ? options.indexOf(p[0]) > -1
                  : false
            }

        return {
            enumerable   : op('enumerable')
          , configurable : op('configurable')
          , writable     : op('writable')
          , value        : value
        }
      }

    , prr = function (obj, key, value, options) {
        var k

        options = makeOptions(value, options)

        if (typeof key == 'object') {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k]
              setProperty(obj, k, options)
            }
          }
          return obj
        }

        return setProperty(obj, key, options)
      }

  return prr
})
},{}],567:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

},{"./privateDecrypt":569,"./publicEncrypt":570}],568:[function(require,module,exports){
var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

},{"create-hash":428,"safe-buffer":590}],569:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

},{"./mgf":568,"./withPublic":571,"./xor":572,"bn.js":66,"browserify-rsa":89,"create-hash":428,"parse-asn1":557,"safe-buffer":590}],570:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

},{"./mgf":568,"./withPublic":571,"./xor":572,"bn.js":66,"browserify-rsa":89,"create-hash":428,"parse-asn1":557,"randombytes":573,"safe-buffer":590}],571:[function(require,module,exports){
var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

},{"bn.js":66,"safe-buffer":590}],572:[function(require,module,exports){
module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

},{}],573:[function(require,module,exports){
(function (process,global){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":565,"safe-buffer":590}],574:[function(require,module,exports){
(function (process,global){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":565,"randombytes":573,"safe-buffer":590}],575:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":576}],576:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":578,"./_stream_writable":580,"core-util-is":426,"inherits":510,"process-nextick-args":564}],577:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":579,"core-util-is":426,"inherits":510}],578:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":576,"./internal/streams/BufferList":581,"./internal/streams/destroy":582,"./internal/streams/stream":583,"_process":565,"core-util-is":426,"events":463,"inherits":510,"isarray":513,"process-nextick-args":564,"safe-buffer":590,"string_decoder/":601,"util":68}],579:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":576,"core-util-is":426,"inherits":510}],580:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":576,"./internal/streams/destroy":582,"./internal/streams/stream":583,"_process":565,"core-util-is":426,"inherits":510,"process-nextick-args":564,"safe-buffer":590,"timers":602,"util-deprecate":604}],581:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":590,"util":68}],582:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":564}],583:[function(require,module,exports){
arguments[4][529][0].apply(exports,arguments)
},{"dup":529,"events":463}],584:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":585}],585:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":576,"./lib/_stream_passthrough.js":577,"./lib/_stream_readable.js":578,"./lib/_stream_transform.js":579,"./lib/_stream_writable.js":580}],586:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":585}],587:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":580}],588:[function(require,module,exports){
(function (global,Buffer){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.realisticStructuredClone = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(_dereq_,module,exports){
'use strict';

_dereq_('core-js/fn/array/includes');
_dereq_('core-js/fn/object/values');
var DOMException = _dereq_('domexception');
var Typeson = _dereq_('typeson');
var structuredCloningThrowing = _dereq_('typeson-registry/dist/presets/structured-cloning-throwing');

// http://stackoverflow.com/a/33268326/786644 - works in browser, worker, and Node.js
var globalVar = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' ? self : typeof global !== 'undefined' ? global : Function('return this;')();

if (!globalVar.DOMException) {
    globalVar.DOMException = DOMException;
}

var TSON = new Typeson().register(structuredCloningThrowing);

function realisticStructuredClone(obj) {
    return TSON.revive(TSON.encapsulate(obj));
}

module.exports = realisticStructuredClone;

},{"core-js/fn/array/includes":2,"core-js/fn/object/values":3,"domexception":44,"typeson":47,"typeson-registry/dist/presets/structured-cloning-throwing":46}],2:[function(_dereq_,module,exports){
'use strict';

_dereq_('../../modules/es7.array.includes');
module.exports = _dereq_('../../modules/_core').Array.includes;

},{"../../modules/_core":9,"../../modules/es7.array.includes":39}],3:[function(_dereq_,module,exports){
'use strict';

_dereq_('../../modules/es7.object.values');
module.exports = _dereq_('../../modules/_core').Object.values;

},{"../../modules/_core":9,"../../modules/es7.object.values":40}],4:[function(_dereq_,module,exports){
'use strict';

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],5:[function(_dereq_,module,exports){
'use strict';

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _dereq_('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _dereq_('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":19,"./_wks":38}],6:[function(_dereq_,module,exports){
'use strict';

var isObject = _dereq_('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":22}],7:[function(_dereq_,module,exports){
'use strict';

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = _dereq_('./_to-iobject');
var toLength = _dereq_('./_to-length');
var toAbsoluteIndex = _dereq_('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":32,"./_to-iobject":34,"./_to-length":35}],8:[function(_dereq_,module,exports){
"use strict";

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],9:[function(_dereq_,module,exports){
'use strict';

var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],10:[function(_dereq_,module,exports){
'use strict';

// optional / simple context binding
var aFunction = _dereq_('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":4}],11:[function(_dereq_,module,exports){
"use strict";

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],12:[function(_dereq_,module,exports){
'use strict';

// Thank's IE8 for his funny defineProperty
module.exports = !_dereq_('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_fails":16}],13:[function(_dereq_,module,exports){
'use strict';

var isObject = _dereq_('./_is-object');
var document = _dereq_('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":17,"./_is-object":22}],14:[function(_dereq_,module,exports){
'use strict';

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

},{}],15:[function(_dereq_,module,exports){
'use strict';

var global = _dereq_('./_global');
var core = _dereq_('./_core');
var hide = _dereq_('./_hide');
var redefine = _dereq_('./_redefine');
var ctx = _dereq_('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":9,"./_ctx":10,"./_global":17,"./_hide":19,"./_redefine":29}],16:[function(_dereq_,module,exports){
"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],17:[function(_dereq_,module,exports){
'use strict';

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
// eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],18:[function(_dereq_,module,exports){
"use strict";

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],19:[function(_dereq_,module,exports){
'use strict';

var dP = _dereq_('./_object-dp');
var createDesc = _dereq_('./_property-desc');
module.exports = _dereq_('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":12,"./_object-dp":23,"./_property-desc":28}],20:[function(_dereq_,module,exports){
'use strict';

module.exports = !_dereq_('./_descriptors') && !_dereq_('./_fails')(function () {
  return Object.defineProperty(_dereq_('./_dom-create')('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

},{"./_descriptors":12,"./_dom-create":13,"./_fails":16}],21:[function(_dereq_,module,exports){
'use strict';

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = _dereq_('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":8}],22:[function(_dereq_,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function (it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

},{}],23:[function(_dereq_,module,exports){
'use strict';

var anObject = _dereq_('./_an-object');
var IE8_DOM_DEFINE = _dereq_('./_ie8-dom-define');
var toPrimitive = _dereq_('./_to-primitive');
var dP = Object.defineProperty;

exports.f = _dereq_('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":6,"./_descriptors":12,"./_ie8-dom-define":20,"./_to-primitive":36}],24:[function(_dereq_,module,exports){
'use strict';

var has = _dereq_('./_has');
var toIObject = _dereq_('./_to-iobject');
var arrayIndexOf = _dereq_('./_array-includes')(false);
var IE_PROTO = _dereq_('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

},{"./_array-includes":7,"./_has":18,"./_shared-key":30,"./_to-iobject":34}],25:[function(_dereq_,module,exports){
'use strict';

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = _dereq_('./_object-keys-internal');
var enumBugKeys = _dereq_('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":14,"./_object-keys-internal":24}],26:[function(_dereq_,module,exports){
"use strict";

exports.f = {}.propertyIsEnumerable;

},{}],27:[function(_dereq_,module,exports){
'use strict';

var getKeys = _dereq_('./_object-keys');
var toIObject = _dereq_('./_to-iobject');
var isEnum = _dereq_('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      if (isEnum.call(O, key = keys[i++])) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }return result;
  };
};

},{"./_object-keys":25,"./_object-pie":26,"./_to-iobject":34}],28:[function(_dereq_,module,exports){
"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],29:[function(_dereq_,module,exports){
'use strict';

var global = _dereq_('./_global');
var hide = _dereq_('./_hide');
var has = _dereq_('./_has');
var SRC = _dereq_('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

_dereq_('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":9,"./_global":17,"./_has":18,"./_hide":19,"./_uid":37}],30:[function(_dereq_,module,exports){
'use strict';

var shared = _dereq_('./_shared')('keys');
var uid = _dereq_('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":31,"./_uid":37}],31:[function(_dereq_,module,exports){
'use strict';

var global = _dereq_('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":17}],32:[function(_dereq_,module,exports){
'use strict';

var toInteger = _dereq_('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":33}],33:[function(_dereq_,module,exports){
"use strict";

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],34:[function(_dereq_,module,exports){
'use strict';

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = _dereq_('./_iobject');
var defined = _dereq_('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":11,"./_iobject":21}],35:[function(_dereq_,module,exports){
'use strict';

// 7.1.15 ToLength
var toInteger = _dereq_('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":33}],36:[function(_dereq_,module,exports){
'use strict';

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = _dereq_('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":22}],37:[function(_dereq_,module,exports){
'use strict';

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],38:[function(_dereq_,module,exports){
'use strict';

var store = _dereq_('./_shared')('wks');
var uid = _dereq_('./_uid');
var _Symbol = _dereq_('./_global').Symbol;
var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":17,"./_shared":31,"./_uid":37}],39:[function(_dereq_,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes

var $export = _dereq_('./_export');
var $includes = _dereq_('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

_dereq_('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":5,"./_array-includes":7,"./_export":15}],40:[function(_dereq_,module,exports){
'use strict';

// https://github.com/tc39/proposal-object-values-entries
var $export = _dereq_('./_export');
var $values = _dereq_('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":15,"./_object-to-array":27}],41:[function(_dereq_,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var legacyErrorCodes = _dereq_("./legacy-error-codes.json");
var idlUtils = _dereq_("./utils.js");

exports.implementation = function () {
  function DOMExceptionImpl(_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        message = _ref2[0],
        name = _ref2[1];

    _classCallCheck(this, DOMExceptionImpl);

    this.name = name;
    this.message = message;
  }

  _createClass(DOMExceptionImpl, [{
    key: "code",
    get: function get() {
      return legacyErrorCodes[this.name] || 0;
    }
  }]);

  return DOMExceptionImpl;
}();

// A proprietary V8 extension that causes the stack property to appear.
exports.init = function (impl) {
  if (Error.captureStackTrace) {
    var wrapper = idlUtils.wrapperForImpl(impl);
    Error.captureStackTrace(wrapper, wrapper.constructor);
  }
};

},{"./legacy-error-codes.json":43,"./utils.js":45}],42:[function(_dereq_,module,exports){
"use strict";

var conversions = _dereq_("webidl-conversions");
var utils = _dereq_("./utils.js");

var impl = utils.implSymbol;

function DOMException() {
  var args = [];
  for (var i = 0; i < arguments.length && i < 2; ++i) {
    args[i] = arguments[i];
  }

  if (args[0] !== undefined) {
    args[0] = conversions["DOMString"](args[0], { context: "Failed to construct 'DOMException': parameter 1" });
  } else {
    args[0] = "";
  }

  if (args[1] !== undefined) {
    args[1] = conversions["DOMString"](args[1], { context: "Failed to construct 'DOMException': parameter 2" });
  } else {
    args[1] = "Error";
  }

  iface.setup(this, args);
}

Object.defineProperty(DOMException, "prototype", {
  value: DOMException.prototype,
  writable: false,
  enumerable: false,
  configurable: false
});

Object.defineProperty(DOMException.prototype, "name", {
  get: function get() {
    return this[impl]["name"];
  },


  enumerable: true,
  configurable: true
});

Object.defineProperty(DOMException.prototype, "message", {
  get: function get() {
    return this[impl]["message"];
  },


  enumerable: true,
  configurable: true
});

Object.defineProperty(DOMException.prototype, "code", {
  get: function get() {
    return this[impl]["code"];
  },


  enumerable: true,
  configurable: true
});

Object.defineProperty(DOMException, "INDEX_SIZE_ERR", {
  value: 1,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "INDEX_SIZE_ERR", {
  value: 1,
  enumerable: true
});

Object.defineProperty(DOMException, "DOMSTRING_SIZE_ERR", {
  value: 2,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "DOMSTRING_SIZE_ERR", {
  value: 2,
  enumerable: true
});

Object.defineProperty(DOMException, "HIERARCHY_REQUEST_ERR", {
  value: 3,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "HIERARCHY_REQUEST_ERR", {
  value: 3,
  enumerable: true
});

Object.defineProperty(DOMException, "WRONG_DOCUMENT_ERR", {
  value: 4,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "WRONG_DOCUMENT_ERR", {
  value: 4,
  enumerable: true
});

Object.defineProperty(DOMException, "INVALID_CHARACTER_ERR", {
  value: 5,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "INVALID_CHARACTER_ERR", {
  value: 5,
  enumerable: true
});

Object.defineProperty(DOMException, "NO_DATA_ALLOWED_ERR", {
  value: 6,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "NO_DATA_ALLOWED_ERR", {
  value: 6,
  enumerable: true
});

Object.defineProperty(DOMException, "NO_MODIFICATION_ALLOWED_ERR", {
  value: 7,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "NO_MODIFICATION_ALLOWED_ERR", {
  value: 7,
  enumerable: true
});

Object.defineProperty(DOMException, "NOT_FOUND_ERR", {
  value: 8,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "NOT_FOUND_ERR", {
  value: 8,
  enumerable: true
});

Object.defineProperty(DOMException, "NOT_SUPPORTED_ERR", {
  value: 9,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "NOT_SUPPORTED_ERR", {
  value: 9,
  enumerable: true
});

Object.defineProperty(DOMException, "INUSE_ATTRIBUTE_ERR", {
  value: 10,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "INUSE_ATTRIBUTE_ERR", {
  value: 10,
  enumerable: true
});

Object.defineProperty(DOMException, "INVALID_STATE_ERR", {
  value: 11,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "INVALID_STATE_ERR", {
  value: 11,
  enumerable: true
});

Object.defineProperty(DOMException, "SYNTAX_ERR", {
  value: 12,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "SYNTAX_ERR", {
  value: 12,
  enumerable: true
});

Object.defineProperty(DOMException, "INVALID_MODIFICATION_ERR", {
  value: 13,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "INVALID_MODIFICATION_ERR", {
  value: 13,
  enumerable: true
});

Object.defineProperty(DOMException, "NAMESPACE_ERR", {
  value: 14,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "NAMESPACE_ERR", {
  value: 14,
  enumerable: true
});

Object.defineProperty(DOMException, "INVALID_ACCESS_ERR", {
  value: 15,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "INVALID_ACCESS_ERR", {
  value: 15,
  enumerable: true
});

Object.defineProperty(DOMException, "VALIDATION_ERR", {
  value: 16,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "VALIDATION_ERR", {
  value: 16,
  enumerable: true
});

Object.defineProperty(DOMException, "TYPE_MISMATCH_ERR", {
  value: 17,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "TYPE_MISMATCH_ERR", {
  value: 17,
  enumerable: true
});

Object.defineProperty(DOMException, "SECURITY_ERR", {
  value: 18,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "SECURITY_ERR", {
  value: 18,
  enumerable: true
});

Object.defineProperty(DOMException, "NETWORK_ERR", {
  value: 19,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "NETWORK_ERR", {
  value: 19,
  enumerable: true
});

Object.defineProperty(DOMException, "ABORT_ERR", {
  value: 20,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "ABORT_ERR", {
  value: 20,
  enumerable: true
});

Object.defineProperty(DOMException, "URL_MISMATCH_ERR", {
  value: 21,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "URL_MISMATCH_ERR", {
  value: 21,
  enumerable: true
});

Object.defineProperty(DOMException, "QUOTA_EXCEEDED_ERR", {
  value: 22,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "QUOTA_EXCEEDED_ERR", {
  value: 22,
  enumerable: true
});

Object.defineProperty(DOMException, "TIMEOUT_ERR", {
  value: 23,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "TIMEOUT_ERR", {
  value: 23,
  enumerable: true
});

Object.defineProperty(DOMException, "INVALID_NODE_TYPE_ERR", {
  value: 24,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "INVALID_NODE_TYPE_ERR", {
  value: 24,
  enumerable: true
});

Object.defineProperty(DOMException, "DATA_CLONE_ERR", {
  value: 25,
  enumerable: true
});
Object.defineProperty(DOMException.prototype, "DATA_CLONE_ERR", {
  value: 25,
  enumerable: true
});

Object.defineProperty(DOMException.prototype, Symbol.toStringTag, {
  value: "DOMException",
  writable: false,
  enumerable: false,
  configurable: true
});

var iface = {
  mixedInto: [],
  is: function is(obj) {
    if (obj) {
      if (obj[impl] instanceof Impl.implementation) {
        return true;
      }
      for (var i = 0; i < module.exports.mixedInto.length; ++i) {
        if (obj instanceof module.exports.mixedInto[i]) {
          return true;
        }
      }
    }
    return false;
  },
  isImpl: function isImpl(obj) {
    if (obj) {
      if (obj instanceof Impl.implementation) {
        return true;
      }

      var wrapper = utils.wrapperForImpl(obj);
      for (var i = 0; i < module.exports.mixedInto.length; ++i) {
        if (wrapper instanceof module.exports.mixedInto[i]) {
          return true;
        }
      }
    }
    return false;
  },
  convert: function convert(obj) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$context = _ref.context,
        context = _ref$context === undefined ? "The provided value" : _ref$context;

    if (module.exports.is(obj)) {
      return utils.implForWrapper(obj);
    }
    throw new TypeError(context + " is not of type 'DOMException'.");
  },
  create: function create(constructorArgs, privateData) {
    var obj = Object.create(DOMException.prototype);
    this.setup(obj, constructorArgs, privateData);
    return obj;
  },
  createImpl: function createImpl(constructorArgs, privateData) {
    var obj = Object.create(DOMException.prototype);
    this.setup(obj, constructorArgs, privateData);
    return utils.implForWrapper(obj);
  },
  _internalSetup: function _internalSetup(obj) {},
  setup: function setup(obj, constructorArgs, privateData) {
    if (!privateData) privateData = {};

    privateData.wrapper = obj;

    this._internalSetup(obj);
    Object.defineProperty(obj, impl, {
      value: new Impl.implementation(constructorArgs, privateData),
      writable: false,
      enumerable: false,
      configurable: true
    });
    obj[impl][utils.wrapperSymbol] = obj;
    if (Impl.init) {
      Impl.init(obj[impl], privateData);
    }
  },

  interface: DOMException,
  expose: {
    Window: { DOMException: DOMException },
    Worker: { DOMException: DOMException }
  }
}; // iface
module.exports = iface;

var Impl = _dereq_(".//DOMException-impl.js");

},{".//DOMException-impl.js":41,"./utils.js":45,"webidl-conversions":48}],43:[function(_dereq_,module,exports){
module.exports={
  "IndexSizeError": 1,
  "DOMStringSizeError": 2,
  "HierarchyRequestError": 3,
  "WrongDocumentError": 4,
  "InvalidCharacterError": 5,
  "NoDataAllowedError": 6,
  "NoModificationAllowedError": 7,
  "NotFoundError": 8,
  "NotSupportedError": 9,
  "InUseAttributeError": 10,
  "InvalidStateError": 11,
  "SyntaxError": 12,
  "InvalidModificationError": 13,
  "NamespaceError": 14,
  "InvalidAccessError": 15,
  "ValidationError": 16,
  "TypeMismatchError": 17,
  "SecurityError": 18,
  "NetworkError": 19,
  "AbortError": 20,
  "URLMismatchError": 21,
  "QuotaExceededError": 22,
  "TimeoutError": 23,
  "InvalidNodeTypeError": 24,
  "DataCloneError": 25
}

},{}],44:[function(_dereq_,module,exports){
"use strict";

module.exports = _dereq_("./DOMException").interface;

Object.setPrototypeOf(module.exports.prototype, Error.prototype);

},{"./DOMException":42}],45:[function(_dereq_,module,exports){
"use strict";

// Returns "Type(value) is Object" in ES terminology.

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(value) {
  return (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && value !== null || typeof value === "function";
}

function getReferenceToBytes(bufferSource) {
  // Node.js' Buffer does not allow subclassing for now, so we can get away with a prototype object check for perf.
  if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {
    return bufferSource;
  }
  if (bufferSource instanceof ArrayBuffer) {
    return Buffer.from(bufferSource);
  }
  return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);
}

function getCopyToBytes(bufferSource) {
  return Buffer.from(getReferenceToBytes(bufferSource));
}

function mixin(target, source) {
  var keys = Object.getOwnPropertyNames(source);
  for (var i = 0; i < keys.length; ++i) {
    if (keys[i] in target) {
      continue;
    }

    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
  }
}

var wrapperSymbol = Symbol("wrapper");
var implSymbol = Symbol("impl");
var sameObjectCaches = Symbol("SameObject caches");

function getSameObject(wrapper, prop, creator) {
  if (!wrapper[sameObjectCaches]) {
    wrapper[sameObjectCaches] = Object.create(null);
  }

  if (prop in wrapper[sameObjectCaches]) {
    return wrapper[sameObjectCaches][prop];
  }

  wrapper[sameObjectCaches][prop] = creator();
  return wrapper[sameObjectCaches][prop];
}

function wrapperForImpl(impl) {
  return impl ? impl[wrapperSymbol] : null;
}

function implForWrapper(wrapper) {
  return wrapper ? wrapper[implSymbol] : null;
}

function tryWrapperForImpl(impl) {
  var wrapper = wrapperForImpl(impl);
  return wrapper ? wrapper : impl;
}

function tryImplForWrapper(wrapper) {
  var impl = implForWrapper(wrapper);
  return impl ? impl : wrapper;
}

var iterInternalSymbol = Symbol("internal");
var IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));

module.exports = exports = {
  isObject: isObject,
  getReferenceToBytes: getReferenceToBytes,
  getCopyToBytes: getCopyToBytes,
  mixin: mixin,
  wrapperSymbol: wrapperSymbol,
  implSymbol: implSymbol,
  getSameObject: getSameObject,
  wrapperForImpl: wrapperForImpl,
  implForWrapper: implForWrapper,
  tryWrapperForImpl: tryWrapperForImpl,
  tryImplForWrapper: tryImplForWrapper,
  iterInternalSymbol: iterInternalSymbol,
  IteratorPrototype: IteratorPrototype
};

},{}],46:[function(_dereq_,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e.Typeson = e.Typeson || {}, e.Typeson.presets = e.Typeson.presets || {}, e.Typeson.presets.structuredCloningThrowing = t());
}(undefined, function () {
  "use strict";
  var e = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
    return typeof e === "undefined" ? "undefined" : _typeof(e);
  } : function (e) {
    return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof(e);
  },
      t = function () {
    return function (e, t) {
      if (Array.isArray(e)) return e;if (Symbol.iterator in Object(e)) return function sliceIterator(e, t) {
        var n = [],
            r = !0,
            i = !1,
            o = void 0;try {
          for (var s, a = e[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0) {}
        } catch (e) {
          i = !0, o = e;
        } finally {
          try {
            !r && a.return && a.return();
          } finally {
            if (i) throw o;
          }
        }return n;
      }(e, t);throw new TypeError("Invalid attempt to destructure non-iterable instance");
    };
  }(),
      n = function n(e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = Array(e.length); t < e.length; t++) {
        n[t] = e[t];
      }return n;
    }return Array.from(e);
  },
      r = Object.keys,
      i = Array.isArray,
      o = {}.toString,
      s = Object.getPrototypeOf,
      a = {}.hasOwnProperty,
      c = a.toString,
      u = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];function isThenable(e, t) {
    return Typeson.isObject(e) && "function" == typeof e.then && (!t || "function" == typeof e.catch);
  }function toStringTag(e) {
    return o.call(e).slice(8, -1);
  }function hasConstructorOf(t, n) {
    if (!t || "object" !== (void 0 === t ? "undefined" : e(t))) return !1;var r = s(t);if (!r) return !1;var i = a.call(r, "constructor") && r.constructor;return "function" != typeof i ? null === n : "function" == typeof i && null !== n && c.call(i) === c.call(n);
  }function isPlainObject(e) {
    return !(!e || "Object" !== toStringTag(e)) && (!s(e) || hasConstructorOf(e, Object));
  }function isObject(t) {
    return t && "object" === (void 0 === t ? "undefined" : e(t));
  }function Typeson(o) {
    var s = [],
        a = [],
        c = {},
        f = this.types = {},
        p = this.stringify = function (e, t, n, r) {
      r = Object.assign({}, o, r, { stringification: !0 });var s = y(e, null, r);return i(s) ? JSON.stringify(s[0], t, n) : s.then(function (e) {
        return JSON.stringify(e, t, n);
      });
    };this.stringifySync = function (e, t, n, r) {
      return p(e, t, n, Object.assign({}, { throwOnBadSyncType: !0 }, r, { sync: !0 }));
    }, this.stringifyAsync = function (e, t, n, r) {
      return p(e, t, n, Object.assign({}, { throwOnBadSyncType: !0 }, r, { sync: !1 }));
    };var l = this.parse = function (e, t, n) {
      return n = Object.assign({}, o, n, { parse: !0 }), v(JSON.parse(e, t), n);
    };this.parseSync = function (e, t, n) {
      return l(e, t, Object.assign({}, { throwOnBadSyncType: !0 }, n, { sync: !0 }));
    }, this.parseAsync = function (e, t, n) {
      return l(e, t, Object.assign({}, { throwOnBadSyncType: !0 }, n, { sync: !1 }));
    }, this.specialTypeNames = function (e, t) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};return n.returnTypeNames = !0, this.encapsulate(e, t, n);
    }, this.rootTypeName = function (e, t) {
      var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};return n.iterateNone = !0, this.encapsulate(e, t, n);
    };var y = this.encapsulate = function (f, p, l) {
      var y = (l = Object.assign({ sync: !0 }, o, l)).sync,
          v = {},
          d = [],
          h = [],
          b = [],
          g = !(l && "cyclic" in l) || l.cyclic,
          m = l.encapsulateObserver,
          T = _encapsulate("", f, g, p || {}, b);function finish(e) {
        var t = Object.values(v);if (l.iterateNone) return t.length ? t[0] : Typeson.getJSONType(e);if (t.length) {
          if (l.returnTypeNames) return [].concat(n(new Set(t)));e && isPlainObject(e) && !e.hasOwnProperty("$types") ? e.$types = v : e = { $: e, $types: { $: v } };
        } else isObject(e) && e.hasOwnProperty("$types") && (e = { $: e, $types: !0 });return !l.returnTypeNames && e;
      }return b.length ? y && l.throwOnBadSyncType ? function () {
        throw new TypeError("Sync method requested but async result obtained");
      }() : Promise.resolve(function checkPromises(e, n) {
        return Promise.all(n.map(function (e) {
          return e[1].p;
        })).then(function (r) {
          return Promise.all(r.map(function (r) {
            var i = [],
                o = n.splice(0, 1)[0],
                s = t(o, 7),
                a = s[0],
                c = s[2],
                u = s[3],
                f = s[4],
                p = s[5],
                l = s[6],
                y = _encapsulate(a, r, c, u, i, !0, l),
                v = hasConstructorOf(y, TypesonPromise);return a && v ? y.p.then(function (t) {
              return f[p] = t, checkPromises(e, i);
            }) : (a ? f[p] = y : e = v ? y.p : y, checkPromises(e, i));
          }));
        }).then(function () {
          return e;
        });
      }(T, b)).then(finish) : !y && l.throwOnBadSyncType ? function () {
        throw new TypeError("Async method requested but sync result obtained");
      }() : l.stringification && y ? [finish(T)] : y ? finish(T) : Promise.resolve(finish(T));function _adaptBuiltinStateObjectProperties(e, t, n) {
        Object.assign(e, t);var r = u.map(function (t) {
          var n = e[t];return delete e[t], n;
        });n(), u.forEach(function (t, n) {
          e[t] = r[n];
        });
      }function _encapsulate(t, n, o, a, c, u, f) {
        var p = void 0,
            y = {},
            b = void 0 === n ? "undefined" : e(n),
            g = m ? function (e) {
          var r = f || a.type || Typeson.getJSONType(n);m(Object.assign(e || y, { keypath: t, value: n, cyclic: o, stateObj: a, promisesData: c, resolvingTypesonPromise: u, awaitingTypesonPromise: hasConstructorOf(n, TypesonPromise) }, void 0 !== r ? { type: r } : {}));
        } : null;if (b in { string: 1, boolean: 1, number: 1, undefined: 1 }) return void 0 === n || "number" === b && (isNaN(n) || n === -1 / 0 || n === 1 / 0) ? (p = replace(t, n, a, c, !1, u, g)) !== n && (y = { replaced: p }) : p = n, g && g(), p;if (null === n) return g && g(), n;if (o && !a.iterateIn && !a.iterateUnsetNumeric) {
          var T = d.indexOf(n);if (!(T < 0)) return v[t] = "#", g && g({ cyclicKeypath: h[T] }), "#" + h[T];!0 === o && (d.push(n), h.push(t));
        }var O = isPlainObject(n),
            w = i(n),
            S = (O || w) && (!s.length || a.replaced) || a.iterateIn ? n : replace(t, n, a, c, O || w, null, g),
            P = void 0;if (S !== n ? (p = S, y = { replaced: S }) : w || "array" === a.iterateIn ? (P = new Array(n.length), y = { clone: P }) : O || "object" === a.iterateIn ? y = { clone: P = {} } : "" === t && hasConstructorOf(n, TypesonPromise) ? (c.push([t, n, o, a, void 0, void 0, a.type]), p = n) : p = n, g && g(), l.iterateNone) return P || p;if (!P) return p;if (a.iterateIn) {
          var j = function _loop(e) {
            var r = { ownKeys: n.hasOwnProperty(e) };_adaptBuiltinStateObjectProperties(a, r, function () {
              var r = t + (t ? "." : "") + escapeKeyPathComponent(e),
                  i = _encapsulate(r, n[e], !!o, a, c, u);hasConstructorOf(i, TypesonPromise) ? c.push([r, i, !!o, a, P, e, a.type]) : void 0 !== i && (P[e] = i);
            });
          };for (var A in n) {
            j(A);
          }g && g({ endIterateIn: !0, end: !0 });
        } else r(n).forEach(function (e) {
          var r = t + (t ? "." : "") + escapeKeyPathComponent(e);_adaptBuiltinStateObjectProperties(a, { ownKeys: !0 }, function () {
            var t = _encapsulate(r, n[e], !!o, a, c, u);hasConstructorOf(t, TypesonPromise) ? c.push([r, t, !!o, a, P, e, a.type]) : void 0 !== t && (P[e] = t);
          });
        }), g && g({ endIterateOwn: !0, end: !0 });if (a.iterateUnsetNumeric) {
          for (var C = n.length, N = function _loop2(e) {
            if (!(e in n)) {
              var r = t + (t ? "." : "") + e;_adaptBuiltinStateObjectProperties(a, { ownKeys: !1 }, function () {
                var t = _encapsulate(r, void 0, !!o, a, c, u);hasConstructorOf(t, TypesonPromise) ? c.push([r, t, !!o, a, P, e, a.type]) : void 0 !== t && (P[e] = t);
              });
            }
          }, B = 0; B < C; B++) {
            N(B);
          }g && g({ endIterateUnsetNumeric: !0, end: !0 });
        }return P;
      }function replace(e, t, n, r, i, o, u) {
        for (var f = i ? s : a, p = f.length; p--;) {
          var l = f[p];if (l.test(t, n)) {
            var d = l.type;if (c[d]) {
              var h = v[e];v[e] = h ? [d].concat(h) : d;
            }return Object.assign(n, { type: d, replaced: !0 }), !y && l.replaceAsync || l.replace ? (u && u({ replacing: !0 }), _encapsulate(e, l[y || !l.replaceAsync ? "replace" : "replaceAsync"](t, n), g && "readonly", n, r, o, d)) : (u && u({ typeDetected: !0 }), _encapsulate(e, t, g && "readonly", n, r, o, d));
          }
        }return t;
      }
    };this.encapsulateSync = function (e, t, n) {
      return y(e, t, Object.assign({}, { throwOnBadSyncType: !0 }, n, { sync: !0 }));
    }, this.encapsulateAsync = function (e, t, n) {
      return y(e, t, Object.assign({}, { throwOnBadSyncType: !0 }, n, { sync: !1 }));
    };var v = this.revive = function (e, n) {
      var s = (n = Object.assign({ sync: !0 }, o, n)).sync,
          a = e && e.$types,
          u = !0;if (!a) return e;if (!0 === a) return e.$;a.$ && isPlainObject(a.$) && (e = e.$, a = a.$, u = !1);var f = [],
          p = {},
          l = function _revive(e, n, o, s, l, y) {
        if (u && "$types" === e) return;var v = a[e];if (i(n) || isPlainObject(n)) {
          var d = i(n) ? new Array(n.length) : {};for (r(n).forEach(function (t) {
            var r = _revive(e + (e ? "." : "") + escapeKeyPathComponent(t), n[t], o || d, s, d, t);hasConstructorOf(r, Undefined) ? d[t] = void 0 : void 0 !== r && (d[t] = r);
          }), n = d; f.length;) {
            var h = t(f[0], 4),
                b = h[0],
                g = h[1],
                m = h[2],
                T = h[3],
                O = getByKeyPath(b, g);if (hasConstructorOf(O, Undefined)) m[T] = void 0;else {
              if (void 0 === O) break;m[T] = O;
            }f.splice(0, 1);
          }
        }if (!v) return n;if ("#" === v) {
          var w = getByKeyPath(o, n.substr(1));return void 0 === w && f.push([o, n.substr(1), l, y]), w;
        }var S = s.sync;return [].concat(v).reduce(function (e, t) {
          var n = c[t];if (!n) throw new Error("Unregistered type: " + t);return n[S && n.revive ? "revive" : !S && n.reviveAsync ? "reviveAsync" : "revive"](e, p);
        }, n);
      }("", e, null, n);return isThenable(l = hasConstructorOf(l, Undefined) ? void 0 : l) ? s && n.throwOnBadSyncType ? function () {
        throw new TypeError("Sync method requested but async result obtained");
      }() : l : !s && n.throwOnBadSyncType ? function () {
        throw new TypeError("Async method requested but sync result obtained");
      }() : s ? l : Promise.resolve(l);
    };this.reviveSync = function (e, t) {
      return v(e, Object.assign({}, { throwOnBadSyncType: !0 }, t, { sync: !0 }));
    }, this.reviveAsync = function (e, t) {
      return v(e, Object.assign({}, { throwOnBadSyncType: !0 }, t, { sync: !1 }));
    }, this.register = function (e, t) {
      return t = t || {}, [].concat(e).forEach(function R(e) {
        if (i(e)) return e.map(R);e && r(e).forEach(function (n) {
          if ("#" === n) throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");if (Typeson.JSON_TYPES.includes(n)) throw new TypeError("Plain JSON object types are reserved as type names");var r = e[n],
              o = r.testPlainObjects ? s : a,
              u = o.filter(function (e) {
            return e.type === n;
          });if (u.length && (o.splice(o.indexOf(u[0]), 1), delete c[n], delete f[n]), r) {
            if ("function" == typeof r) {
              var p = r;r = { test: function test(e) {
                  return e && e.constructor === p;
                }, replace: function replace(e) {
                  return assign({}, e);
                }, revive: function revive(e) {
                  return assign(Object.create(p.prototype), e);
                } };
            } else i(r) && (r = { test: r[0], replace: r[1], revive: r[2] });var l = { type: n, test: r.test.bind(r) };r.replace && (l.replace = r.replace.bind(r)), r.replaceAsync && (l.replaceAsync = r.replaceAsync.bind(r));var y = "number" == typeof t.fallback ? t.fallback : t.fallback ? 0 : 1 / 0;if (r.testPlainObjects ? s.splice(y, 0, l) : a.splice(y, 0, l), r.revive || r.reviveAsync) {
              var v = {};r.revive && (v.revive = r.revive.bind(r)), r.reviveAsync && (v.reviveAsync = r.reviveAsync.bind(r)), c[n] = v;
            }f[n] = r;
          }
        });
      }), this;
    };
  }function assign(e, t) {
    return r(t).map(function (n) {
      e[n] = t[n];
    }), e;
  }function escapeKeyPathComponent(e) {
    return e.replace(/~/g, "~0").replace(/\./g, "~1");
  }function unescapeKeyPathComponent(e) {
    return e.replace(/~1/g, ".").replace(/~0/g, "~");
  }function getByKeyPath(e, t) {
    if ("" === t) return e;var n = t.indexOf(".");if (n > -1) {
      var r = e[unescapeKeyPathComponent(t.substr(0, n))];return void 0 === r ? void 0 : getByKeyPath(r, t.substr(n + 1));
    }return e[unescapeKeyPathComponent(t)];
  }function Undefined() {}function TypesonPromise(e) {
    this.p = new Promise(e);
  }TypesonPromise.prototype.then = function (e, t) {
    var n = this;return new TypesonPromise(function (r, i) {
      n.p.then(function (t) {
        r(e ? e(t) : t);
      }, function (e) {
        n.p.catch(function (e) {
          return t ? t(e) : Promise.reject(e);
        }).then(r, i);
      });
    });
  }, TypesonPromise.prototype.catch = function (e) {
    return this.then(null, e);
  }, TypesonPromise.resolve = function (e) {
    return new TypesonPromise(function (t) {
      t(e);
    });
  }, TypesonPromise.reject = function (e) {
    return new TypesonPromise(function (t, n) {
      n(e);
    });
  }, ["all", "race"].map(function (e) {
    TypesonPromise[e] = function (t) {
      return new TypesonPromise(function (n, r) {
        Promise[e](t.map(function (e) {
          return e.p;
        })).then(n, r);
      });
    };
  }), Typeson.Undefined = Undefined, Typeson.Promise = TypesonPromise, Typeson.isThenable = isThenable, Typeson.toStringTag = toStringTag, Typeson.hasConstructorOf = hasConstructorOf, Typeson.isObject = isObject, Typeson.isPlainObject = isPlainObject, Typeson.isUserObject = function isUserObject(e) {
    if (!e || "Object" !== toStringTag(e)) return !1;var t = s(e);return !t || hasConstructorOf(e, Object) || isUserObject(t);
  }, Typeson.escapeKeyPathComponent = escapeKeyPathComponent, Typeson.unescapeKeyPathComponent = unescapeKeyPathComponent, Typeson.getByKeyPath = getByKeyPath, Typeson.getJSONType = function (t) {
    return null === t ? "null" : i(t) ? "array" : void 0 === t ? "undefined" : e(t);
  }, Typeson.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"];for (var f = { userObject: { test: function test(e, t) {
        return Typeson.isUserObject(e);
      }, replace: function replace(e) {
        return Object.assign({}, e);
      }, revive: function revive(e) {
        return e;
      } } }, p = [[{ sparseArrays: { testPlainObjects: !0, test: function test(e) {
        return Array.isArray(e);
      }, replace: function replace(e, t) {
        return t.iterateUnsetNumeric = !0, e;
      } } }, { sparseUndefined: { test: function test(e, t) {
        return void 0 === e && !1 === t.ownKeys;
      }, replace: function replace(e) {
        return null;
      }, revive: function revive(e) {} } }], { undef: { test: function test(e, t) {
        return void 0 === e && (t.ownKeys || !("ownKeys" in t));
      }, replace: function replace(e) {
        return null;
      }, revive: function revive(e) {
        return new Typeson.Undefined();
      } } }], l = { StringObject: { test: function test(t) {
        return "String" === Typeson.toStringTag(t) && "object" === (void 0 === t ? "undefined" : e(t));
      }, replace: function replace(e) {
        return String(e);
      }, revive: function revive(e) {
        return new String(e);
      } }, BooleanObject: { test: function test(t) {
        return "Boolean" === Typeson.toStringTag(t) && "object" === (void 0 === t ? "undefined" : e(t));
      }, replace: function replace(e) {
        return Boolean(e);
      }, revive: function revive(e) {
        return new Boolean(e);
      } }, NumberObject: { test: function test(t) {
        return "Number" === Typeson.toStringTag(t) && "object" === (void 0 === t ? "undefined" : e(t));
      }, replace: function replace(e) {
        return Number(e);
      }, revive: function revive(e) {
        return new Number(e);
      } } }, y = [{ nan: { test: function test(e) {
        return "number" == typeof e && isNaN(e);
      }, replace: function replace(e) {
        return "NaN";
      }, revive: function revive(e) {
        return NaN;
      } } }, { infinity: { test: function test(e) {
        return e === 1 / 0;
      }, replace: function replace(e) {
        return "Infinity";
      }, revive: function revive(e) {
        return 1 / 0;
      } } }, { negativeInfinity: { test: function test(e) {
        return e === -1 / 0;
      }, replace: function replace(e) {
        return "-Infinity";
      }, revive: function revive(e) {
        return -1 / 0;
      } } }], v = { date: { test: function test(e) {
        return "Date" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        var t = e.getTime();return isNaN(t) ? "NaN" : t;
      }, revive: function revive(e) {
        return "NaN" === e ? new Date(NaN) : new Date(e);
      } } }, d = { regexp: { test: function test(e) {
        return "RegExp" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        return { source: e.source, flags: (e.global ? "g" : "") + (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.sticky ? "y" : "") + (e.unicode ? "u" : "") };
      }, revive: function revive(e) {
        var t = e.source,
            n = e.flags;return new RegExp(t, n);
      } } }, h = { map: { test: function test(e) {
        return "Map" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        return Array.from(e.entries());
      }, revive: function revive(e) {
        return new Map(e);
      } } }, b = { set: { test: function test(e) {
        return "Set" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        return Array.from(e.values());
      }, revive: function revive(e) {
        return new Set(e);
      } } }, g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", m = new Uint8Array(256), T = 0; T < g.length; T++) {
    m[g.charCodeAt(T)] = T;
  }var O = function encode(e, t, n) {
    for (var r = new Uint8Array(e, t, n), i = r.length, o = "", s = 0; s < i; s += 3) {
      o += g[r[s] >> 2], o += g[(3 & r[s]) << 4 | r[s + 1] >> 4], o += g[(15 & r[s + 1]) << 2 | r[s + 2] >> 6], o += g[63 & r[s + 2]];
    }return i % 3 == 2 ? o = o.substring(0, o.length - 1) + "=" : i % 3 == 1 && (o = o.substring(0, o.length - 2) + "=="), o;
  },
      w = function decode(e) {
    var t = e.length,
        n = .75 * e.length,
        r = 0,
        i = void 0,
        o = void 0,
        s = void 0,
        a = void 0;"=" === e[e.length - 1] && (n--, "=" === e[e.length - 2] && n--);for (var c = new ArrayBuffer(n), u = new Uint8Array(c), f = 0; f < t; f += 4) {
      i = m[e.charCodeAt(f)], o = m[e.charCodeAt(f + 1)], s = m[e.charCodeAt(f + 2)], a = m[e.charCodeAt(f + 3)], u[r++] = i << 2 | o >> 4, u[r++] = (15 & o) << 4 | s >> 2, u[r++] = (3 & s) << 6 | 63 & a;
    }return c;
  },
      S = { arraybuffer: { test: function test(e) {
        return "ArrayBuffer" === Typeson.toStringTag(e);
      }, replace: function replace(e, t) {
        t.buffers || (t.buffers = []);var n = t.buffers.indexOf(e);return n > -1 ? { index: n } : (t.buffers.push(e), O(e));
      }, revive: function revive(t, n) {
        if (n.buffers || (n.buffers = []), "object" === (void 0 === t ? "undefined" : e(t))) return n.buffers[t.index];var r = w(t);return n.buffers.push(r), r;
      } } },
      P = "undefined" == typeof self ? global : self,
      j = {};["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"].forEach(function (e) {
    var t = e,
        n = P[t];n && (j[e.toLowerCase()] = { test: function test(e) {
        return Typeson.toStringTag(e) === t;
      }, replace: function replace(e, t) {
        var n = e.buffer,
            r = e.byteOffset,
            i = e.length;t.buffers || (t.buffers = []);var o = t.buffers.indexOf(n);return o > -1 ? { index: o, byteOffset: r, length: i } : (t.buffers.push(n), { encoded: O(n), byteOffset: r, length: i });
      }, revive: function revive(e, t) {
        t.buffers || (t.buffers = []);var r = e.byteOffset,
            i = e.length,
            o = e.encoded,
            s = e.index,
            a = void 0;return "index" in e ? a = t.buffers[s] : (a = w(o), t.buffers.push(a)), new n(a, r, i);
      } });
  });var A = { dataview: { test: function test(e) {
        return "DataView" === Typeson.toStringTag(e);
      }, replace: function replace(e, t) {
        var n = e.buffer,
            r = e.byteOffset,
            i = e.byteLength;t.buffers || (t.buffers = []);var o = t.buffers.indexOf(n);return o > -1 ? { index: o, byteOffset: r, byteLength: i } : (t.buffers.push(n), { encoded: O(n), byteOffset: r, byteLength: i });
      }, revive: function revive(e, t) {
        t.buffers || (t.buffers = []);var n = e.byteOffset,
            r = e.byteLength,
            i = e.encoded,
            o = e.index,
            s = void 0;return "index" in e ? s = t.buffers[o] : (s = w(i), t.buffers.push(s)), new DataView(s, n, r);
      } } },
      C = { IntlCollator: { test: function test(e) {
        return Typeson.hasConstructorOf(e, Intl.Collator);
      }, replace: function replace(e) {
        return e.resolvedOptions();
      }, revive: function revive(e) {
        return new Intl.Collator(e.locale, e);
      } }, IntlDateTimeFormat: { test: function test(e) {
        return Typeson.hasConstructorOf(e, Intl.DateTimeFormat);
      }, replace: function replace(e) {
        return e.resolvedOptions();
      }, revive: function revive(e) {
        return new Intl.DateTimeFormat(e.locale, e);
      } }, IntlNumberFormat: { test: function test(e) {
        return Typeson.hasConstructorOf(e, Intl.NumberFormat);
      }, replace: function replace(e) {
        return e.resolvedOptions();
      }, revive: function revive(e) {
        return new Intl.NumberFormat(e.locale, e);
      } } },
      N = { file: { test: function test(e) {
        return "File" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        var t = new XMLHttpRequest();if (t.open("GET", URL.createObjectURL(e), !1), 200 !== t.status && 0 !== t.status) throw new Error("Bad Blob access: " + t.status);return t.send(), { type: e.type, stringContents: t.responseText, name: e.name, lastModified: e.lastModified };
      }, revive: function revive(e) {
        var t = e.name,
            n = e.type,
            r = e.stringContents,
            i = e.lastModified;return new File([r], t, { type: n, lastModified: i });
      }, replaceAsync: function replaceAsync(e) {
        return new Typeson.Promise(function (t, n) {
          if (e.isClosed) n(new Error("The File is closed"));else {
            var r = new FileReader();r.addEventListener("load", function () {
              t({ type: e.type, stringContents: r.result, name: e.name, lastModified: e.lastModified });
            }), r.addEventListener("error", function () {
              n(r.error);
            }), r.readAsText(e);
          }
        });
      } } };return [f, p, l, y, v, d, { imagedata: { test: function test(e) {
        return "ImageData" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        return { array: Array.from(e.data), width: e.width, height: e.height };
      }, revive: function revive(e) {
        return new ImageData(new Uint8ClampedArray(e.array), e.width, e.height);
      } } }, { imagebitmap: { test: function test(e) {
        return "ImageBitmap" === Typeson.toStringTag(e) || e && e.dataset && "ImageBitmap" === e.dataset.toStringTag;
      }, replace: function replace(e) {
        var t = document.createElement("canvas");return t.getContext("2d").drawImage(e, 0, 0), t.toDataURL();
      }, revive: function revive(e) {
        var t = document.createElement("canvas"),
            n = t.getContext("2d"),
            r = document.createElement("img");return r.onload = function () {
          n.drawImage(r, 0, 0);
        }, r.src = e, t;
      }, reviveAsync: function reviveAsync(e) {
        var t = document.createElement("canvas"),
            n = t.getContext("2d"),
            r = document.createElement("img");return r.onload = function () {
          n.drawImage(r, 0, 0);
        }, r.src = e, createImageBitmap(t);
      } } }, N, { file: N.file, filelist: { test: function test(e) {
        return "FileList" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        for (var t = [], n = 0; n < e.length; n++) {
          t[n] = e.item(n);
        }return t;
      }, revive: function revive(e) {
        function FileList() {
          this._files = arguments[0], this.length = this._files.length;
        }return FileList.prototype.item = function (e) {
          return this._files[e];
        }, FileList.prototype[Symbol.toStringTag] = "FileList", new FileList(e);
      } } }, { blob: { test: function test(e) {
        return "Blob" === Typeson.toStringTag(e);
      }, replace: function replace(e) {
        var t = new XMLHttpRequest();if (t.open("GET", URL.createObjectURL(e), !1), 200 !== t.status && 0 !== t.status) throw new Error("Bad Blob access: " + t.status);return t.send(), { type: e.type, stringContents: t.responseText };
      }, revive: function revive(e) {
        var t = e.type,
            n = e.stringContents;return new Blob([n], { type: t });
      }, replaceAsync: function replaceAsync(e) {
        return new Typeson.Promise(function (t, n) {
          if (e.isClosed) n(new Error("The Blob is closed"));else {
            var r = new FileReader();r.addEventListener("load", function () {
              t({ type: e.type, stringContents: r.result });
            }), r.addEventListener("error", function () {
              n(r.error);
            }), r.readAsText(e);
          }
        });
      } } }].concat("function" == typeof Map ? h : [], "function" == typeof Set ? b : [], "function" == typeof ArrayBuffer ? S : [], "function" == typeof Uint8Array ? j : [], "function" == typeof DataView ? A : [], "undefined" != typeof Intl ? C : []).concat({ checkDataCloneException: [function (t) {
      var n = {}.toString.call(t).slice(8, -1);if (["symbol", "function"].includes(void 0 === t ? "undefined" : e(t)) || ["Arguments", "Module", "Error", "Promise", "WeakMap", "WeakSet"].includes(n) || t === Object.prototype || ("Blob" === n || "File" === n) && t.isClosed || t && "object" === (void 0 === t ? "undefined" : e(t)) && "number" == typeof t.nodeType && "function" == typeof t.insertBefore) throw new DOMException("The object cannot be cloned.", "DataCloneError");return !1;
    }] });
});


},{}],47:[function(_dereq_,module,exports){
"use strict";

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = "function" == typeof Symbol && "symbol" == _typeof2(Symbol.iterator) ? function (e) {
  return typeof e === "undefined" ? "undefined" : _typeof2(e);
} : function (e) {
  return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e === "undefined" ? "undefined" : _typeof2(e);
},
    slicedToArray = function () {
  return function (e, n) {
    if (Array.isArray(e)) return e;if (Symbol.iterator in Object(e)) return function sliceIterator(e, n) {
      var t = [],
          r = !0,
          i = !1,
          o = void 0;try {
        for (var s, a = e[Symbol.iterator](); !(r = (s = a.next()).done) && (t.push(s.value), !n || t.length !== n); r = !0) {}
      } catch (e) {
        i = !0, o = e;
      } finally {
        try {
          !r && a.return && a.return();
        } finally {
          if (i) throw o;
        }
      }return t;
    }(e, n);throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
}(),
    toConsumableArray = function toConsumableArray(e) {
  if (Array.isArray(e)) {
    for (var n = 0, t = Array(e.length); n < e.length; n++) {
      t[n] = e[n];
    }return t;
  }return Array.from(e);
},
    keys = Object.keys,
    isArray = Array.isArray,
    toString = {}.toString,
    getProto = Object.getPrototypeOf,
    hasOwn = {}.hasOwnProperty,
    fnToString = hasOwn.toString,
    internalStateObjPropsToIgnore = ["type", "replaced", "iterateIn", "iterateUnsetNumeric"];function isThenable(e, n) {
  return Typeson.isObject(e) && "function" == typeof e.then && (!n || "function" == typeof e.catch);
}function toStringTag(e) {
  return toString.call(e).slice(8, -1);
}function hasConstructorOf(e, n) {
  if (!e || "object" !== (void 0 === e ? "undefined" : _typeof(e))) return !1;var t = getProto(e);if (!t) return !1;var r = hasOwn.call(t, "constructor") && t.constructor;return "function" != typeof r ? null === n : "function" == typeof r && null !== n && fnToString.call(r) === fnToString.call(n);
}function isPlainObject(e) {
  return !(!e || "Object" !== toStringTag(e)) && (!getProto(e) || hasConstructorOf(e, Object));
}function isUserObject(e) {
  if (!e || "Object" !== toStringTag(e)) return !1;var n = getProto(e);return !n || hasConstructorOf(e, Object) || isUserObject(n);
}function isObject(e) {
  return e && "object" === (void 0 === e ? "undefined" : _typeof(e));
}function Typeson(e) {
  var n = [],
      t = [],
      r = {},
      i = this.types = {},
      o = this.stringify = function (n, t, r, i) {
    i = Object.assign({}, e, i, { stringification: !0 });var o = a(n, null, i);return isArray(o) ? JSON.stringify(o[0], t, r) : o.then(function (e) {
      return JSON.stringify(e, t, r);
    });
  };this.stringifySync = function (e, n, t, r) {
    return o(e, n, t, Object.assign({}, { throwOnBadSyncType: !0 }, r, { sync: !0 }));
  }, this.stringifyAsync = function (e, n, t, r) {
    return o(e, n, t, Object.assign({}, { throwOnBadSyncType: !0 }, r, { sync: !1 }));
  };var s = this.parse = function (n, t, r) {
    return r = Object.assign({}, e, r, { parse: !0 }), c(JSON.parse(n, t), r);
  };this.parseSync = function (e, n, t) {
    return s(e, n, Object.assign({}, { throwOnBadSyncType: !0 }, t, { sync: !0 }));
  }, this.parseAsync = function (e, n, t) {
    return s(e, n, Object.assign({}, { throwOnBadSyncType: !0 }, t, { sync: !1 }));
  }, this.specialTypeNames = function (e, n) {
    var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};return t.returnTypeNames = !0, this.encapsulate(e, n, t);
  }, this.rootTypeName = function (e, n) {
    var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};return t.iterateNone = !0, this.encapsulate(e, n, t);
  };var a = this.encapsulate = function (i, o, s) {
    var a = (s = Object.assign({ sync: !0 }, e, s)).sync,
        c = {},
        u = [],
        y = [],
        p = [],
        f = !(s && "cyclic" in s) || s.cyclic,
        l = s.encapsulateObserver,
        h = _encapsulate("", i, f, o || {}, p);function finish(e) {
      var n = Object.values(c);if (s.iterateNone) return n.length ? n[0] : Typeson.getJSONType(e);if (n.length) {
        if (s.returnTypeNames) return [].concat(toConsumableArray(new Set(n)));e && isPlainObject(e) && !e.hasOwnProperty("$types") ? e.$types = c : e = { $: e, $types: { $: c } };
      } else isObject(e) && e.hasOwnProperty("$types") && (e = { $: e, $types: !0 });return !s.returnTypeNames && e;
    }return p.length ? a && s.throwOnBadSyncType ? function () {
      throw new TypeError("Sync method requested but async result obtained");
    }() : Promise.resolve(function checkPromises(e, n) {
      return Promise.all(n.map(function (e) {
        return e[1].p;
      })).then(function (t) {
        return Promise.all(t.map(function (t) {
          var r = [],
              i = n.splice(0, 1)[0],
              o = slicedToArray(i, 7),
              s = o[0],
              a = o[2],
              c = o[3],
              u = o[4],
              y = o[5],
              p = o[6],
              f = _encapsulate(s, t, a, c, r, !0, p),
              l = hasConstructorOf(f, TypesonPromise);return s && l ? f.p.then(function (n) {
            return u[y] = n, checkPromises(e, r);
          }) : (s ? u[y] = f : e = l ? f.p : f, checkPromises(e, r));
        }));
      }).then(function () {
        return e;
      });
    }(h, p)).then(finish) : !a && s.throwOnBadSyncType ? function () {
      throw new TypeError("Async method requested but sync result obtained");
    }() : s.stringification && a ? [finish(h)] : a ? finish(h) : Promise.resolve(finish(h));function _adaptBuiltinStateObjectProperties(e, n, t) {
      Object.assign(e, n);var r = internalStateObjPropsToIgnore.map(function (n) {
        var t = e[n];return delete e[n], t;
      });t(), internalStateObjPropsToIgnore.forEach(function (n, t) {
        e[n] = r[t];
      });
    }function _encapsulate(e, t, r, i, o, a, p) {
      var f = void 0,
          h = {},
          v = void 0 === t ? "undefined" : _typeof(t),
          d = l ? function (n) {
        var s = p || i.type || Typeson.getJSONType(t);l(Object.assign(n || h, { keypath: e, value: t, cyclic: r, stateObj: i, promisesData: o, resolvingTypesonPromise: a, awaitingTypesonPromise: hasConstructorOf(t, TypesonPromise) }, void 0 !== s ? { type: s } : {}));
      } : null;if (v in { string: 1, boolean: 1, number: 1, undefined: 1 }) return void 0 === t || "number" === v && (isNaN(t) || t === -1 / 0 || t === 1 / 0) ? (f = replace(e, t, i, o, !1, a, d)) !== t && (h = { replaced: f }) : f = t, d && d(), f;if (null === t) return d && d(), t;if (r && !i.iterateIn && !i.iterateUnsetNumeric) {
        var b = u.indexOf(t);if (!(b < 0)) return c[e] = "#", d && d({ cyclicKeypath: y[b] }), "#" + y[b];!0 === r && (u.push(t), y.push(e));
      }var O = isPlainObject(t),
          g = isArray(t),
          T = (O || g) && (!n.length || i.replaced) || i.iterateIn ? t : replace(e, t, i, o, O || g, null, d),
          m = void 0;if (T !== t ? (f = T, h = { replaced: T }) : g || "array" === i.iterateIn ? (m = new Array(t.length), h = { clone: m }) : O || "object" === i.iterateIn ? h = { clone: m = {} } : "" === e && hasConstructorOf(t, TypesonPromise) ? (o.push([e, t, r, i, void 0, void 0, i.type]), f = t) : f = t, d && d(), s.iterateNone) return m || f;if (!m) return f;if (i.iterateIn) {
        var P = function _loop(n) {
          var s = { ownKeys: t.hasOwnProperty(n) };_adaptBuiltinStateObjectProperties(i, s, function () {
            var s = e + (e ? "." : "") + escapeKeyPathComponent(n),
                c = _encapsulate(s, t[n], !!r, i, o, a);hasConstructorOf(c, TypesonPromise) ? o.push([s, c, !!r, i, m, n, i.type]) : void 0 !== c && (m[n] = c);
          });
        };for (var j in t) {
          P(j);
        }d && d({ endIterateIn: !0, end: !0 });
      } else keys(t).forEach(function (n) {
        var s = e + (e ? "." : "") + escapeKeyPathComponent(n);_adaptBuiltinStateObjectProperties(i, { ownKeys: !0 }, function () {
          var e = _encapsulate(s, t[n], !!r, i, o, a);hasConstructorOf(e, TypesonPromise) ? o.push([s, e, !!r, i, m, n, i.type]) : void 0 !== e && (m[n] = e);
        });
      }), d && d({ endIterateOwn: !0, end: !0 });if (i.iterateUnsetNumeric) {
        for (var S = t.length, w = function _loop2(n) {
          if (!(n in t)) {
            var s = e + (e ? "." : "") + n;_adaptBuiltinStateObjectProperties(i, { ownKeys: !1 }, function () {
              var e = _encapsulate(s, void 0, !!r, i, o, a);hasConstructorOf(e, TypesonPromise) ? o.push([s, e, !!r, i, m, n, i.type]) : void 0 !== e && (m[n] = e);
            });
          }
        }, A = 0; A < S; A++) {
          w(A);
        }d && d({ endIterateUnsetNumeric: !0, end: !0 });
      }return m;
    }function replace(e, i, o, s, u, y, p) {
      for (var l = u ? n : t, h = l.length; h--;) {
        var v = l[h];if (v.test(i, o)) {
          var d = v.type;if (r[d]) {
            var b = c[e];c[e] = b ? [d].concat(b) : d;
          }return Object.assign(o, { type: d, replaced: !0 }), !a && v.replaceAsync || v.replace ? (p && p({ replacing: !0 }), _encapsulate(e, v[a || !v.replaceAsync ? "replace" : "replaceAsync"](i, o), f && "readonly", o, s, y, d)) : (p && p({ typeDetected: !0 }), _encapsulate(e, i, f && "readonly", o, s, y, d));
        }
      }return i;
    }
  };this.encapsulateSync = function (e, n, t) {
    return a(e, n, Object.assign({}, { throwOnBadSyncType: !0 }, t, { sync: !0 }));
  }, this.encapsulateAsync = function (e, n, t) {
    return a(e, n, Object.assign({}, { throwOnBadSyncType: !0 }, t, { sync: !1 }));
  };var c = this.revive = function (n, t) {
    var i = (t = Object.assign({ sync: !0 }, e, t)).sync,
        o = n && n.$types,
        s = !0;if (!o) return n;if (!0 === o) return n.$;o.$ && isPlainObject(o.$) && (n = n.$, o = o.$, s = !1);var a = [],
        c = {},
        u = function _revive(e, n, t, i, u, y) {
      if (s && "$types" === e) return;var p = o[e];if (isArray(n) || isPlainObject(n)) {
        var f = isArray(n) ? new Array(n.length) : {};for (keys(n).forEach(function (r) {
          var o = _revive(e + (e ? "." : "") + escapeKeyPathComponent(r), n[r], t || f, i, f, r);hasConstructorOf(o, Undefined) ? f[r] = void 0 : void 0 !== o && (f[r] = o);
        }), n = f; a.length;) {
          var l = slicedToArray(a[0], 4),
              h = l[0],
              v = l[1],
              d = l[2],
              b = l[3],
              O = getByKeyPath(h, v);if (hasConstructorOf(O, Undefined)) d[b] = void 0;else {
            if (void 0 === O) break;d[b] = O;
          }a.splice(0, 1);
        }
      }if (!p) return n;if ("#" === p) {
        var g = getByKeyPath(t, n.substr(1));return void 0 === g && a.push([t, n.substr(1), u, y]), g;
      }var T = i.sync;return [].concat(p).reduce(function (e, n) {
        var t = r[n];if (!t) throw new Error("Unregistered type: " + n);return t[T && t.revive ? "revive" : !T && t.reviveAsync ? "reviveAsync" : "revive"](e, c);
      }, n);
    }("", n, null, t);return isThenable(u = hasConstructorOf(u, Undefined) ? void 0 : u) ? i && t.throwOnBadSyncType ? function () {
      throw new TypeError("Sync method requested but async result obtained");
    }() : u : !i && t.throwOnBadSyncType ? function () {
      throw new TypeError("Async method requested but sync result obtained");
    }() : i ? u : Promise.resolve(u);
  };this.reviveSync = function (e, n) {
    return c(e, Object.assign({}, { throwOnBadSyncType: !0 }, n, { sync: !0 }));
  }, this.reviveAsync = function (e, n) {
    return c(e, Object.assign({}, { throwOnBadSyncType: !0 }, n, { sync: !1 }));
  }, this.register = function (e, o) {
    return o = o || {}, [].concat(e).forEach(function R(e) {
      if (isArray(e)) return e.map(R);e && keys(e).forEach(function (s) {
        if ("#" === s) throw new TypeError("# cannot be used as a type name as it is reserved for cyclic objects");if (Typeson.JSON_TYPES.includes(s)) throw new TypeError("Plain JSON object types are reserved as type names");var a = e[s],
            c = a.testPlainObjects ? n : t,
            u = c.filter(function (e) {
          return e.type === s;
        });if (u.length && (c.splice(c.indexOf(u[0]), 1), delete r[s], delete i[s]), a) {
          if ("function" == typeof a) {
            var y = a;a = { test: function test(e) {
                return e && e.constructor === y;
              }, replace: function replace(e) {
                return assign({}, e);
              }, revive: function revive(e) {
                return assign(Object.create(y.prototype), e);
              } };
          } else isArray(a) && (a = { test: a[0], replace: a[1], revive: a[2] });var p = { type: s, test: a.test.bind(a) };a.replace && (p.replace = a.replace.bind(a)), a.replaceAsync && (p.replaceAsync = a.replaceAsync.bind(a));var f = "number" == typeof o.fallback ? o.fallback : o.fallback ? 0 : 1 / 0;if (a.testPlainObjects ? n.splice(f, 0, p) : t.splice(f, 0, p), a.revive || a.reviveAsync) {
            var l = {};a.revive && (l.revive = a.revive.bind(a)), a.reviveAsync && (l.reviveAsync = a.reviveAsync.bind(a)), r[s] = l;
          }i[s] = a;
        }
      });
    }), this;
  };
}function assign(e, n) {
  return keys(n).map(function (t) {
    e[t] = n[t];
  }), e;
}function escapeKeyPathComponent(e) {
  return e.replace(/~/g, "~0").replace(/\./g, "~1");
}function unescapeKeyPathComponent(e) {
  return e.replace(/~1/g, ".").replace(/~0/g, "~");
}function getByKeyPath(e, n) {
  if ("" === n) return e;var t = n.indexOf(".");if (t > -1) {
    var r = e[unescapeKeyPathComponent(n.substr(0, t))];return void 0 === r ? void 0 : getByKeyPath(r, n.substr(t + 1));
  }return e[unescapeKeyPathComponent(n)];
}function Undefined() {}function TypesonPromise(e) {
  this.p = new Promise(e);
}TypesonPromise.prototype.then = function (e, n) {
  var t = this;return new TypesonPromise(function (r, i) {
    t.p.then(function (n) {
      r(e ? e(n) : n);
    }, function (e) {
      t.p.catch(function (e) {
        return n ? n(e) : Promise.reject(e);
      }).then(r, i);
    });
  });
}, TypesonPromise.prototype.catch = function (e) {
  return this.then(null, e);
}, TypesonPromise.resolve = function (e) {
  return new TypesonPromise(function (n) {
    n(e);
  });
}, TypesonPromise.reject = function (e) {
  return new TypesonPromise(function (n, t) {
    t(e);
  });
}, ["all", "race"].map(function (e) {
  TypesonPromise[e] = function (n) {
    return new TypesonPromise(function (t, r) {
      Promise[e](n.map(function (e) {
        return e.p;
      })).then(t, r);
    });
  };
}), Typeson.Undefined = Undefined, Typeson.Promise = TypesonPromise, Typeson.isThenable = isThenable, Typeson.toStringTag = toStringTag, Typeson.hasConstructorOf = hasConstructorOf, Typeson.isObject = isObject, Typeson.isPlainObject = isPlainObject, Typeson.isUserObject = isUserObject, Typeson.escapeKeyPathComponent = escapeKeyPathComponent, Typeson.unescapeKeyPathComponent = unescapeKeyPathComponent, Typeson.getByKeyPath = getByKeyPath, Typeson.getJSONType = function (e) {
  return null === e ? "null" : isArray(e) ? "array" : void 0 === e ? "undefined" : _typeof(e);
}, Typeson.JSON_TYPES = ["null", "boolean", "number", "string", "array", "object"], module.exports = Typeson;

},{}],48:[function(_dereq_,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _(message, opts) {
    return (opts && opts.context ? opts.context : "Value") + " " + message + ".";
}

function type(V) {
    if (V === null) {
        return "Null";
    }
    switch (typeof V === "undefined" ? "undefined" : _typeof(V)) {
        case "undefined":
            return "Undefined";
        case "boolean":
            return "Boolean";
        case "number":
            return "Number";
        case "string":
            return "String";
        case "symbol":
            return "Symbol";
        case "object":
        // Falls through
        case "function":
        // Falls through
        default:
            // Per ES spec, typeof returns an implemention-defined value that is not any of the existing ones for
            // uncallable non-standard exotic objects. Yet Type() which the Web IDL spec depends on returns Object for
            // such cases. So treat the default case as an object.
            return "Object";
    }
}

// Round x to the nearest integer, choosing the even integer if it lies halfway between two.
function evenRound(x) {
    // There are four cases for numbers with fractional part being .5:
    //
    // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example
    //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0
    //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2
    //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0
    //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2
    // (where n is a non-negative integer)
    //
    // Branch here for cases 1 and 4
    if (x > 0 && x % 1 === +0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
        return censorNegativeZero(Math.floor(x));
    }

    return censorNegativeZero(Math.round(x));
}

function integerPart(n) {
    return censorNegativeZero(Math.trunc(n));
}

function sign(x) {
    return x < 0 ? -1 : 1;
}

function modulo(x, y) {
    // https://tc39.github.io/ecma262/#eqn-modulo
    // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos
    var signMightNotMatch = x % y;
    if (sign(y) !== sign(signMightNotMatch)) {
        return signMightNotMatch + y;
    }
    return signMightNotMatch;
}

function censorNegativeZero(x) {
    return x === 0 ? 0 : x;
}

function createIntegerConversion(bitLength, typeOpts) {
    var isSigned = !typeOpts.unsigned;

    var lowerBound = void 0;
    var upperBound = void 0;
    if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        lowerBound = !isSigned ? 0 : -Math.pow(2, 53) + 1;
    } else if (!isSigned) {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
    } else {
        lowerBound = -Math.pow(2, bitLength - 1);
        upperBound = Math.pow(2, bitLength - 1) - 1;
    }

    var twoToTheBitLength = Math.pow(2, bitLength);
    var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);

    return function (V, opts) {
        if (opts === undefined) {
            opts = {};
        }

        var x = +V;
        x = censorNegativeZero(x); // Spec discussion ongoing: https://github.com/heycam/webidl/issues/306

        if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
                throw new TypeError(_("is not a finite number", opts));
            }

            x = integerPart(x);

            if (x < lowerBound || x > upperBound) {
                throw new TypeError(_("is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive", opts));
            }

            return x;
        }

        if (!Number.isNaN(x) && opts.clamp) {
            x = Math.min(Math.max(x, lowerBound), upperBound);
            x = evenRound(x);
            return x;
        }

        if (!Number.isFinite(x) || x === 0) {
            return 0;
        }
        x = integerPart(x);

        // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if
        // possible. Hopefully it's an optimization for the non-64-bitLength cases too.
        if (x >= lowerBound && x <= upperBound) {
            return x;
        }

        // These will not work great for bitLength of 64, but oh well. See the README for more details.
        x = modulo(x, twoToTheBitLength);
        if (isSigned && x >= twoToOneLessThanTheBitLength) {
            return x - twoToTheBitLength;
        }
        return x;
    };
}

exports.any = function (V) {
    return V;
};

exports.void = function () {
    return undefined;
};

exports.boolean = function (val) {
    return !!val;
};

exports.byte = createIntegerConversion(8, { unsigned: false });
exports.octet = createIntegerConversion(8, { unsigned: true });

exports.short = createIntegerConversion(16, { unsigned: false });
exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });

exports.long = createIntegerConversion(32, { unsigned: false });
exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });

exports["long long"] = createIntegerConversion(64, { unsigned: false });
exports["unsigned long long"] = createIntegerConversion(64, { unsigned: true });

exports.double = function (V, opts) {
    var x = +V;

    if (!Number.isFinite(x)) {
        throw new TypeError(_("is not a finite floating-point value", opts));
    }

    return x;
};

exports["unrestricted double"] = function (V) {
    var x = +V;

    return x;
};

exports.float = function (V, opts) {
    var x = +V;

    if (!Number.isFinite(x)) {
        throw new TypeError(_("is not a finite floating-point value", opts));
    }

    if (Object.is(x, -0)) {
        return x;
    }

    var y = Math.fround(x);

    if (!Number.isFinite(y)) {
        throw new TypeError(_("is outside the range of a single-precision floating-point value", opts));
    }

    return y;
};

exports["unrestricted float"] = function (V) {
    var x = +V;

    if (isNaN(x)) {
        return x;
    }

    if (Object.is(x, -0)) {
        return x;
    }

    return Math.fround(x);
};

exports.DOMString = function (V, opts) {
    if (opts === undefined) {
        opts = {};
    }

    if (opts.treatNullAsEmptyString && V === null) {
        return "";
    }

    if ((typeof V === "undefined" ? "undefined" : _typeof(V)) === "symbol") {
        throw new TypeError(_("is a symbol, which cannot be converted to a string", opts));
    }

    return String(V);
};

exports.ByteString = function (V, opts) {
    var x = exports.DOMString(V, opts);
    var c = void 0;
    for (var i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {
        if (c > 255) {
            throw new TypeError(_("is not a valid ByteString", opts));
        }
    }

    return x;
};

exports.USVString = function (V, opts) {
    var S = exports.DOMString(V, opts);
    var n = S.length;
    var U = [];
    for (var i = 0; i < n; ++i) {
        var c = S.charCodeAt(i);
        if (c < 0xD800 || c > 0xDFFF) {
            U.push(String.fromCodePoint(c));
        } else if (0xDC00 <= c && c <= 0xDFFF) {
            U.push(String.fromCodePoint(0xFFFD));
        } else if (i === n - 1) {
            U.push(String.fromCodePoint(0xFFFD));
        } else {
            var d = S.charCodeAt(i + 1);
            if (0xDC00 <= d && d <= 0xDFFF) {
                var a = c & 0x3FF;
                var b = d & 0x3FF;
                U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                ++i;
            } else {
                U.push(String.fromCodePoint(0xFFFD));
            }
        }
    }

    return U.join("");
};

exports.object = function (V, opts) {
    if (type(V) !== "Object") {
        throw new TypeError(_("is not an object", opts));
    }

    return V;
};

// Not exported, but used in Function and VoidFunction.

// Neither Function nor VoidFunction is defined with [TreatNonObjectAsNull], so
// handling for that is omitted.
function convertCallbackFunction(V, opts) {
    if (typeof V !== "function") {
        throw new TypeError(_("is not a function", opts));
    }
    return V;
}

[Error, ArrayBuffer, // The IsDetachedBuffer abstract operation is not exposed in JS
DataView, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array].forEach(function (func) {
    var name = func.name;
    var article = /^[AEIOU]/.test(name) ? "an" : "a";
    exports[name] = function (V, opts) {
        if (!(V instanceof func)) {
            throw new TypeError(_("is not " + article + " " + name + " object", opts));
        }

        return V;
    };
});

// Common definitions

exports.ArrayBufferView = function (V, opts) {
    if (!ArrayBuffer.isView(V)) {
        throw new TypeError(_("is not a view on an ArrayBuffer object", opts));
    }

    return V;
};

exports.BufferSource = function (V, opts) {
    if (!(ArrayBuffer.isView(V) || V instanceof ArrayBuffer)) {
        throw new TypeError(_("is not an ArrayBuffer object or a view on one", opts));
    }

    return V;
};

exports.DOMTimeStamp = exports["unsigned long long"];

exports.Function = convertCallbackFunction;

exports.VoidFunction = convertCallbackFunction;

},{}]},{},[1])(1)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":98}],589:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":98,"hash-base":495,"inherits":510}],590:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":98}],591:[function(require,module,exports){
(function (process,global){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":565}],592:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":590}],593:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":594,"./sha1":595,"./sha224":596,"./sha256":597,"./sha384":598,"./sha512":599}],594:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":592,"inherits":510,"safe-buffer":590}],595:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":592,"inherits":510,"safe-buffer":590}],596:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":592,"./sha256":597,"inherits":510,"safe-buffer":590}],597:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":592,"inherits":510,"safe-buffer":590}],598:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":592,"./sha512":599,"inherits":510,"safe-buffer":590}],599:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":592,"inherits":510,"safe-buffer":590}],600:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":463,"inherits":510,"readable-stream/duplex.js":575,"readable-stream/passthrough.js":584,"readable-stream/readable.js":585,"readable-stream/transform.js":586,"readable-stream/writable.js":587}],601:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":590}],602:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":565,"timers":602}],603:[function(require,module,exports){
(function (Buffer){
/**
 * Convert a typed array to a Buffer without a copy
 *
 * Author:   Feross Aboukhadijeh <https://feross.org>
 * License:  MIT
 *
 * `npm install typedarray-to-buffer`
 */

var isTypedArray = require('is-typedarray').strict

module.exports = function typedarrayToBuffer (arr) {
  if (isTypedArray(arr)) {
    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer
    var buf = Buffer.from(arr.buffer)
    if (arr.byteLength !== arr.buffer.byteLength) {
      // Respect the "view", i.e. byteOffset and byteLength, without doing a copy
      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)
    }
    return buf
  } else {
    // Pass through all other types to `Buffer.from`
    return Buffer.from(arr)
  }
}

}).call(this,require("buffer").Buffer)
},{"buffer":98,"is-typedarray":512}],604:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],605:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"dup":61}],606:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"dup":62}],607:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"./support/isBuffer":606,"_process":565,"dup":63,"inherits":605}],608:[function(require,module,exports){
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}],609:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}]},{},[13])(13)
});
